---
title: Прототипы функции | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- function prototypes
- function return types, function prototypes
- data types [C], function return types
- functions [C], return types
- prototypes [C++], function
ms.assetid: d152f8e6-971e-432c-93ca-5a91400653c2
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: cb058b9984cfcd34669f2691fa20245c14d49344
ms.sourcegitcommit: 92dbc4b9bf82fda96da80846c9cfcdba524035af
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/05/2018
ms.locfileid: "43752291"
---
# <a name="function-prototypes"></a>Прототипы функций

Объявление функции предшествует ее определению и указывает имя, тип возвращаемого значения, класс хранения и другие атрибуты функции. Чтобы объявление функции стало ее прототипом, оно должно также задавать типы и идентификаторы аргументов функции.

## <a name="syntax"></a>Синтаксис

*declaration*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declaration-specifiers* *attribute-seq*<sub>opt</sub> *init-declarator-list*<sub>opt</sub> **;**

/\* *attribute-seq*<sub>opt</sub> поддерживается только компилятором Microsoft\*/

*declaration-specifiers*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*storage-class-specifier* *declaration-specifiers*<sub>opt</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-specifier* *declaration-specifiers*<sub>opt</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-qualifier* *declaration-specifiers*<sub>opt</sub>

*init-declarator-list*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*init-declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*init-declarator-list*  **,**  *init-declarator*

*init-declarator*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator* **=** *initializer*

*declarator*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*pointer*<sub>opt</sub> *direct-declarator*

*direct-declarator*: /\* Декларатор функции \*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*direct-declarator*  **(**  *parameter-type-list*  **)**  /\* Декларатор нового стиля \*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*direct-declarator*  **(**  *identifier-list*<sub>opt</sub> **)** /\* Декларатор устаревшего стиля \*/

Прототип имеет ту же форму, что и определение функции, но завершается точкой с запятой сразу после закрывающей круглой скобки и поэтому не имеет тела. В любом случае возвращаемый тип должен соответствовать возвращаемому типу, указанному в определении функции.

Ниже перечислены важные случаи применения прототипов функций:

- Они указывают тип возвращаемого значения для функций, которые возвращают значения с типом, отличным от **int**. Хотя для функций, которые возвращают значения с типом **int**, прототипы не обязательны, рекомендуется их использовать.

- Без полных прототипов выполняются стандартные преобразования, но не производится попытка сравнения типа или количества аргументов с количеством параметров.

- Прототипы используются для инициализации указателей на функции до определения этих функций.

- Список параметров используется для проверки соответствия аргументов в вызове функции и параметров в ее определении.

Преобразованный тип каждого параметра определяет интерпретацию аргументов, помещаемых в стек при вызове функции. Несоответствие типов аргументов и параметров может приводить к неправильной интерпретации аргументов в стеке. Например, если на 16-разрядном компьютере в качестве аргумента передается 16-разрядный указатель, объявленный как параметр **long**, первые 32 бита в стеке интерпретируются как параметр **long**. Такая ошибка создает проблемы не только с параметром **long**, но и со всеми последующими параметрами. Ошибки такого типа можно обнаруживать, объявляя полные прототипы для всех функций.

Прототип задает атрибуты функции, поэтому вызовы функции, предшествующие ее определению (или производимые из других файлов исходного кода), можно проверять на соответствие типов аргументов и возвращаемого типа. Например, если в прототипе указан описатель класса хранения **static**, необходимо также задать класс хранения **static** в определении функции.

Полные объявления параметров (`int a`) могут использоваться совместно с абстрактными деклараторами (`int`) в одном объявлении. Например, следующее объявление является допустимым:

```C
int add( int a, int );
```

Прототип может содержать как тип, так и идентификатор для каждого выражения, которая передается в качестве аргумента. Однако область действия такие идентификатор распространяется только до конца объявления. Прототип также может отражать тот факт, что число аргументов является переменным, или что никакие аргументы не передаются. Без такого списка выявление несоответствий невозможно, поэтому компилятор не может создавать соответствующие диагностические сообщения. Дополнительные сведения о проверке типов содержатся в статье [Аргументы](../c-language/arguments.md).

Теперь область видимости прототипа в компиляторе Microsoft C соответствует стандарту ANSI при компиляции с параметром **/Za**. Таким образом, если вы объявите в прототипе тег **struct** или **union**, этот тег будет видимым именно в этой области, а не глобальной области. Например, если выполнять компиляцию с параметром **/Za** в соответствии со стандартом ANSI, эту функцию невозможно будет вызвать без получения ошибки несоответствия типов:

```C
void func1( struct S * );
```

Чтобы исправить код, определите или объявите **struct** либо **union** в глобальной области перед прототипом функции:

```C
struct S;
void func1( struct S * );
```

При использовании параметра **/Ze** этот тег будет по-прежнему находиться в глобальной области.

## <a name="see-also"></a>См. также

[Функции](../c-language/functions-c.md)