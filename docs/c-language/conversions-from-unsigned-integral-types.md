---
title: "Преобразования из целочисленных типов без знака | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- integers, converting
- type casts, involving integers
- data type conversion [C++], signed and unsigned integers
- type conversion [C++], signed and unsigned integers
- integral conversions, from unsigned
ms.assetid: 60fb7e10-bff9-4a13-8a48-e19f25a36a02
caps.latest.revision: 10
author: mikeblome
ms.author: mblome
manager: ghogen
ms.translationtype: HT
ms.sourcegitcommit: 16d1bf59dfd4b3ef5f037aed9c0f6febfdf1a2e8
ms.openlocfilehash: 15e1bc61e9b15293290098b9414642d8edf46707
ms.contentlocale: ru-ru
ms.lasthandoff: 10/09/2017

---
# <a name="conversions-from-unsigned-integral-types"></a>Преобразования из целочисленных типов без знака
Целое число без знака можно преобразовать в более короткое целое число без знака или со знаком путем усечения битов высокого порядка, или в более длинное целое число со знаком или без знака путем нулевого расширения (см. таблицу [Преобразования целочисленных типов без знака](#_clang_table_4..3)).  
  
 Если значение с целочисленным типом понижено до целого числа со знаком меньшего размера или целое число без знака преобразовано в соответствующее целое число со знаком, значение остается неизменным, если его можно представить в новом типе. Однако это значение представляет изменения, если бит знака задан, как показано в следующем примере.  
  
```  
int j;  
unsigned short k = 65533;  
  
j = k;  
printf_s( "%hd\n", j );   // Prints -3  
```  
  
 Если осуществить представление невозможно, результат определяется реализацией. См. статью [Преобразования приведений типов](../c-language/type-cast-conversions.md), чтобы получить сведения об обработке понижения целых чисел компилятором Microsoft C. То же поведение является результатом преобразования целого числа или типового приведения целого числа.  
  
 Для преобразования значений без знака используется метод, сохраняющий их значения, который не может быть представлен непосредственно на языке C. Единственным исключением является преобразование из `unsigned long` во **float**, при котором в предельном случае теряются младшие разряды. В противном случае значение сохраняется (со знаком или без). Если значение целочисленного типа преобразуется в тип с плавающей запятой и это значение находится за пределами представляемого диапазона, результат не определен. (Сведения о диапазонах для целочисленных типов и типов с плавающей запятой см. в статье [Хранение базовых типов](../c-language/storage-of-basic-types.md).)  
  
 В следующей таблице перечислены преобразования из целочисленных типов без знака.  
  
### <a name="conversions-from-unsigned-integral-types"></a>Преобразования из целочисленных типов без знака  
  
|Исходный тип|Целевой тип|Метод|  
|----------|--------|------------|  
|`unsigned char`|`char`|Сохранение битового шаблона; бит высокого порядка становится битом знака|  
|`unsigned char`|**short**|Нулевое расширение|  
|`unsigned char`|**long**|Нулевое расширение|  
|`unsigned char`|**unsigned short**|Нулевое расширение|  
|`unsigned char`|`unsigned long`|Нулевое расширение|  
|`unsigned char`|**float**|Преобразование в значение **long**; преобразование значения **long** в значение **float**|  
|`unsigned char`|**double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|  
|`unsigned char`|`long double`|Преобразование в значение **long**; преобразование значения **long** в значение **double**|  
|**unsigned short**|`char`|Сохранение байта низкого порядка|  
|**unsigned short**|**short**|Сохранение битового шаблона; бит высокого порядка становится битом знака|  
|**unsigned short**|**long**|Нулевое расширение|  
|**unsigned short**|`unsigned char`|Сохранение байта низкого порядка|  
|**unsigned short**|`unsigned long`|Нулевое расширение|  
|**unsigned short**|**float**|Преобразование в значение **long**; преобразование значения **long** в значение **float**|  
|**unsigned short**|**double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|  
|**unsigned short**|`long double`|Преобразование в значение **long**; преобразование значения **long** в значение **double**|  
|`unsigned long`|`char`|Сохранение байта низкого порядка|  
|`unsigned long`|**short**|Сохранение слова низкого порядка|  
|`unsigned long`|**long**|Сохранение битового шаблона; бит высокого порядка становится битом знака|  
|`unsigned long`|`unsigned char`|Сохранение байта низкого порядка|  
|`unsigned long`|**unsigned short**|Сохранение слова низкого порядка|  
|`unsigned long`|**float**|Преобразование в значение **long**; преобразование значения **long** в значение **float**|  
|`unsigned long`|**double**|Непосредственное преобразование в **double**|  
|`unsigned long`|`long double`|Преобразование в значение **long**; преобразование значения **long** в значение **double**|  
  
 **Блок, относящийся только к системам Майкрософт**  
  
 Для 32-разрядного компилятора Microsoft С тип `unsigned int` эквивалентен типу `unsigned long`. Преобразование значения `unsigned int` выполняется так же, как и преобразование `unsigned long`. Преобразования значений `unsigned long` во **float** не точны, если преобразуемое значение больше, чем максимально возможное положительное значение **long** со знаком.  
  
 **Завершение блока, относящегося только к системам Майкрософт**  
  
## <a name="see-also"></a>См. также  
 [Преобразования назначений](../c-language/assignment-conversions.md)
