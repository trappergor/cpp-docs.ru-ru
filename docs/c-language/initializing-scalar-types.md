---
title: Инициализация скалярных типов
ms.date: 11/04/2016
helpviewer_keywords:
- initializing scalar types
- register variables
- initialization, scalar types
- initializing variables, scalar types
- scalar types
- static variables, initializing
- automatic storage class, initializing scalar types
- automatic storage class
- types [C], initializing
ms.assetid: 73c516f5-c3ad-4d56-ab3b-f2a82b621104
ms.openlocfilehash: 063761abcbb1541893b9cbab463e3d121684d00a
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87211831"
---
# <a name="initializing-scalar-types"></a>Инициализация скалярных типов

При инициализации скалярных типов значение *`assignment-expression`* присваивается переменной. Применяются правила преобразования для присваивания. (См. сведения о правилах преобразования в статье [Преобразования типов (C)](../c-language/type-conversions-c.md).)

## <a name="syntax"></a>Синтаксис

*`declaration`* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`declaration-specifiers`* *`init-declarator-list`* <sub>необ.</sub> **`;`**

*`declaration-specifiers`* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`storage-class-specifier`* *`declaration-specifiers`* <sub>необ.</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`type-specifier`* *`declaration-specifiers`* <sub>необ.</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`type-qualifier`* *`declaration-specifiers`* <sub>необ.</sub>

*`init-declarator-list`* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`init-declarator`*<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`init-declarator-list`* **`,`** *`init-declarator`*

*`init-declarator`* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`declarator`*<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`declarator`* **`=`** *`initializer`*  /\* Для инициализации скалярных типов \*/

*`initializer`* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; *`assignment-expression`*

Можно инициализировать переменные любого типа при условии соблюдения следующих правил.

- Переменные, объявленные на уровне области файлов, можно инициализировать. Если явно не инициализировать переменную на внешнем уровне, она инициализируется значением 0 по умолчанию.

- Константное выражение можно использовать для инициализации любой глобальной переменной, объявленной с использованием описателя **`static`** *`storage-class-specifier`* . Переменные, объявленные как **`static`** , инициализируются в начале исполнения программы. Если глобальная переменная, объявленная как **`static`** , не инициализирована явным образом, она по умолчанию принимает значение 0, а все элементы с типом указателя принимают пустой указатель.

- Переменные, объявленные с описателем класса хранения **`auto`** или **`register`** , инициализируются каждый раз при передаче контроля исполнения блоку, в котором они объявлены. Если не включать инициализатор в объявление переменной **`auto`** или **`register`** , начальное значение переменной будет неопределенным. Для автоматических значений и значений регистра инициализатор не обязательно должен являться константой; он может быть любым выражением, включая ранее определенные значения (даже вызовами функции).

- Начальные значения для объявлений внешних переменных и для всех переменных **`static`** (как внешних, так и внутренних) должны представлять собой константные выражения. (Дополнительные сведения см. в разделе [Постоянные выражения в C](../c-language/c-constant-expressions.md).) Так как адрес объявленной внешне или статической переменной является константным, его можно использовать для инициализации объявленной внутренне переменной указателя **`static`** . Но адрес переменной **`auto`** невозможно использовать как статический инициализатор, так как он может быть разным для каждого исполнения блока. Для инициализации переменных **`auto`** и **`register`** можно использовать константные или переменные значения.

- Если объявление идентификатора имеет область видимости блока и идентификатор имеет внешнюю компоновку, объявление не может иметь инициализацию.

## <a name="examples"></a>Примеры

Инициализация иллюстрируется следующими примерами.

```C
int x = 10;
```

Целочисленная переменная `x` инициализируется с константным выражением `10`.

```C
register int *px = 0;
```

Указатель `px` инициализируется значением 0, создавая указатель null.

```C
const int c = (3 * 1024);
```

В этом примере константное выражение `(3 * 1024)` используется для инициализации `c` с константным значением, которое невозможно изменить из-за ключевого слова **`const`** .

```C
int *b = &x;
```

Этот оператор инициализирует указатель `b` адресом другой переменной, `x`.

```C
int *const a = &z;
```

Указатель `a` инициализируется с адресом переменной с именем `z`. Но так как он определен как **`const`** , переменную `a` можно только инициализировать, но не изменить. Она всегда указывает на одно и то же расположение.

```C
int GLOBAL ;

int function( void )
{
    int LOCAL ;
    static int *lp = &LOCAL;   /* Illegal initialization */
    static int *gp = &GLOBAL;  /* Legal initialization   */
    register int *rp = &LOCAL; /* Legal initialization   */
}
```

Глобальная переменная `GLOBAL` объявляется на внешнем уровне и поэтому имеет глобальное время существования. Локальная переменная `LOCAL` относится к классу хранения **`auto`** , и адрес у нее есть только во время исполнения функции, в которой она объявлена. Поэтому инициализировать переменную указателя **`static`** `lp` с использованием адреса `LOCAL` невозможно. Переменную указателя **`static`** `gp` можно инициализировать с использованием адреса `GLOBAL`, так как он всегда остается неизменным. Аналогично, `*rp` можно инициализировать, так как переменная `rp` является локальной и может иметь неконстантный инициализатор. Всякий раз при входе в блок `LOCAL` имеет новый адрес, который затем присваивается `rp`.

## <a name="see-also"></a>См. также

[Инициализация](../c-language/initialization.md)
