---
title: Операторы косвенного обращения и взятия адреса | Документация Майкрософт
ms.custom: ''
ms.date: 02/16/2018
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- address-of operator (&)
- '* operator'
- operators [C++], address-of
- ampersand operator (&)
- '* operator, indirection operator'
- addresses [C++], indirection
- addresses [C++]
- indirection operator
- '& operator, address-of operator'
- null pointers [C++]
- '* operator, address-of operator'
- operators [C++], indirection
ms.assetid: 10d62b00-12ba-4ea9-a2d5-09ac29ca2232
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 75afd44b8c0a31d9f3731a4c6f9fb86c15de4328
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32389424"
---
# <a name="indirection-and-address-of-operators"></a>Операторы косвенного обращения и адреса операнда

Унарный оператор косвенного обращения (__&#42;__) обращается к значению не напрямую, а через указатель. Операнд должен иметь тип указателя. Результатом операции является значение в том адресе, на который указывает операнд. Тип результата совпадает с типом значения в адресе операнда.

Результат выполнения оператора косвенного обращения представляет собой *тип*, если тип операнда — *указатель на тип*. Если операнд указывает на функцию, результатом является указатель функции. Если он указывает на объект, результатом является адресующее объект значение (lvalue).

Если значение указателя недопустимо, результат оператора косвенного обращения не определен. Вот некоторые типичные условия, при которых значение указателя становится недопустимым.

- Указатель является пустым указателем.

- Указатель задает в момент ссылки адрес объекта после окончания его времени существования (например, объекта, вышедшего из области или освобожденного из памяти).

- Указатель определяет адрес, выравнивание которого не подходит для типа указываемого объекта.

- Указатель определяет адрес, который не используется выполняемой программой.

Унарный оператор взятия адреса (**&**) предоставляет адрес своего операнда. Операнд может быть либо значением, адресующим объект, который не объявлен как __register__ и не является битовым полем, либо результатом унарного оператора __&#42;__ или оператора разыменования массива (__&#91;&#93;__), либо обозначением функции. Результат является *указателем на тип*, если тип операнда — *тип*.

Если операнд является результатом унарного оператора __&#42;__, ни один из операторов не вычисляется, как если бы они оба были пропущены. Результат не является адресующим значением, и к операторам по-прежнему применяются ограничения. Если операнд является результатом оператора __&#91;&#93;__, то ни оператор __&__, ни унарный оператор __&#42;__, подразумеваемый оператором __&#91;&#93;__, не вычисляются. Результат будет таким же, как при удалении оператора __&__ и смене оператора __&#91;&#93;__ на __+__. В противном случае будет получен указатель на объект или функцию, назначаемую операндом.


## <a name="examples"></a>Примеры

Далее в примерах используются следующие типичные объявления.

```C
int *pa, x;
int a[20];
double d;
```

Эта инструкция использует оператор взятия адреса (**&**) для получения адреса шестого элемента массива `a`. Результат сохраняется в переменной указателя `pa`:

```C  
pa = &a[5];
```

Оператор косвенного обращения (__&#42;__) в этом примере обращается к значению `int` по адресу, сохраненному в переменной `pa`. Значение присваивается целочисленной переменной `x`:

```C
x = *pa;
```

В этом примере показано, что косвенное обращение к адресу `x` дает результат, равный значению `x`.

```C
assert( x == *&x );
```

Этот пример показывает эквивалентные способы объявления указателя на функцию.

```C
int roundup( void );     /* Function declaration */

int  *proundup  = roundup;
int  *pround  = &roundup;
assert( pround == proundup );
```  

После объявления функции `roundup` объявляются и инициализируются два указателя на `roundup`. При инициализации первого из них, `proundup`, указывается только имя функции, а для второго, `pround`, используется оператор взятия адреса. Обе инициализации эквивалентны.

## <a name="see-also"></a>См. также

[Оператор косвенного обращения: &#42;](../cpp/indirection-operator-star.md)  
[Оператор address-of: &](../cpp/address-of-operator-amp.md)  
