---
title: "Тип float | Документы Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
helpviewer_keywords:
- type float
- exponent length
- float keyword [C]
- mantissas, length
- floating-point numbers, float type
- ranges, floating-point types
- floating-point numbers, variables
- lengths, mantissa
- double data type, type float
- IEEE floating-point representation
- lengths, exponent
ms.assetid: 706e332b-17a0-4a30-b7d8-5d6cd372524b
caps.latest.revision: "6"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: c0b1362d5cb0451f5190ca63ab0344f557256190
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="type-float"></a>Тип float
Числа с плавающей запятой используют формат IEEE (Института инженеров по электротехнике и электронике). Значения с одиночной точностью и типом float имеют 4 байта, состоят из бита знака, 8-разрядной двоичной экспоненты excess-127 и 23-битной мантиссы. Мантисса представляет число от 1,0 до 2,0. Поскольку бит высокого порядка мантиссы всегда равен 1, он не сохраняется в числе. Это представление обеспечивает для типа float диапазон примерно от 3,4E–38 до 3,4E+38.  
  
 Можно объявить переменные в качестве типа float или double в зависимости от нужд приложения. Основные различия между двумя типами значения заключаются в представляемой ими значимости, требуемых ресурсах хранения и диапазоне. В следующей таблице показана связь между значимостью и требованиями к хранению.  
  
### <a name="floating-point-types"></a>Типы с плавающей запятой  
  
|Тип|Значимые цифры|Число байтов|  
|----------|------------------------|---------------------|  
|float|6–7|4|  
|double|15–16|8|  
  
 Переменные с плавающей запятой представлены мантиссой, которая содержит значение числа, и экспонентой, которая содержит порядок возрастания числа.  
  
 В следующей таблице показано количество битов, выделенных мантиссе и экспоненте для каждого типа с плавающей запятой. Наиболее значимый бит любого типа float или double — всегда бит знака. Если он равен 1, число считается отрицательным; в противном случае — положительным.  
  
### <a name="lengths-of-exponents-and-mantissas"></a>Длина экспонент и мантисс  
  
|Тип|Длина экспоненты|Длина мантиссы|  
|----------|---------------------|---------------------|  
|float|8 бит|23 бита|  
|double|11 бит|52 бита|  
  
 Поскольку экспоненты хранятся в форме без знака, экспоненты смещены на половину своего возможного значения. Для типа float смещение составляет 127; для типа double это 1023. Можно вычислить фактическое значение экспоненты, вычтя значение смещения из значения экспоненты.  
  
 Мантисса хранится в виде бинарной доли, которая больше или равна 1 и меньше 2. Для типов float и double в мантиссе подразумевается наличие начального 1 в наиболее значимой битовой позиции, поэтому фактически длина мантисс составляет 24 и 53 бит соответственно, даже если наиболее значимый бит никогда не хранится в памяти.  
  
 Вместо только что описанного метода хранения пакет значений с плавающей запятой может хранить двоичные числа с плавающей запятой как денормализованные числа. Денормализованные числа — это ненулевые числа с плавающей запятой и зарезервированными значениями экспонент, в которых наиболее значимый бит мантиссы равен 0. Используя денормализованный формат, можно расширить диапазон числа с плавающей запятой в ущерб точности. Невозможно контролировать, в какой форме будет представлено число с плавающей запятой — нормализованной или денормализованной. Пакет значений с плавающей запятой определяет представление. В пакете значений с плавающей запятой никогда не используется денормализованная форма. Исключение составляют случаи, когда экспонента становится меньше, чем минимальное значение, которое может быть представлено в нормализованной форме.  
  
 В следующей таблице показаны минимальное и максимальное значения, которое можно сохранить в переменных каждого типа с плавающей запятой. Значения, указанные в этой таблице, применяются только к нормализованным числам с плавающей запятой; денормализованные числа с плавающей запятой имеют меньшее минимальное значение. Обратите внимание, что номера, сохраненные в регистрах 80*x*87, всегда представлены в 80-разрядной нормализованной форме; при сохранении в 32- или 64-разрядных переменных с плавающей запятой числа могут быть представлены только в ненормализованной форме (переменные типов float и long).  
  
### <a name="range-of-floating-point-types"></a>Диапазон типов с плавающей запятой  
  
|Тип|Минимальное значение|Максимальное значение|  
|----------|-------------------|-------------------|  
|плавающее|1,175494351 E – 38|3,402823466 E + 38|  
|double|2,2250738585072014 E – 308|1,7976931348623158 E + 308|  
  
 Если точность менее важна, чем размер хранимых данных, имеет смысл использовать тип float для переменных с плавающей запятой. И наоборот, если точность — наиболее важный критерий, используйте тип double.  
  
 Уровень переменных с плавающей запятой можно повысить до типа большей значимости (преобразование типа float в тип double). Повышение уровня часто происходит при выполнении арифметических действий с переменными плавающего типа. Это арифметическое действие всегда выполняется на том же уровне точности, что и переменная с наивысшим уровнем точности. Например, проанализируйте объявления следующих типов.  
  
```  
float f_short;  
double f_long;  
long double f_longer;  
  
f_short = f_short * f_long;  
```  
  
 В предыдущем примере уровень переменной `f_short` повышается до типа double, а затем переменная умножается на `f_long`; затем результат округляется до типа float и присваивается объекту `f_short`.  
  
 В следующем примере (с использованием объявлений из предыдущего примера) арифметическая операция выполняется на уровне точности переменной типа float (32-разрядной). Уровень результата затем повышается до уровня double.  
  
```  
f_longer = f_short * f_short;  
```  
  
## <a name="see-also"></a>См. также  
 [Хранение базовых типов](../c-language/storage-of-basic-types.md)