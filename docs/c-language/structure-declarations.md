---
title: Объявления структур
ms.date: 11/04/2016
helpviewer_keywords:
- structure declarations
- anonymous structures
- types [C], declarations
- structure members
- embedded structures
ms.assetid: 5be3be77-a236-4153-b574-7aa77675df7f
ms.openlocfilehash: a17bb996f13fdbe11bb569c8af5669a9d0c5363f
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62157811"
---
# <a name="structure-declarations"></a>Объявления структур

"Объявление структуры" именует тип и задает последовательность переменных значений ("элементы" или "поля" структуры), которые могут иметь разные типы. Необязательный идентификатор — тег — предоставляет имя типа структуры и может использоваться в последующих ссылках на тип структуры. Переменная этого типа структуры включает определенную этим типом последовательность целиком. Структуры в языке C аналогичны типам, известным в других языках как "записи".

## <a name="syntax"></a>Синтаксис

*спецификатор-структуры-или-объединения*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*struct-or-union* *identifier*<sub>opt</sub> **{** *struct-declaration-list* **}**<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*struct-or-union* *identifier*

*структура-или-объединение*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**struct**<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**union**

*список-объявлений-структуры*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*struct-declaration*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*struct-declaration-list* *struct-declaration*

*объявление-структуры*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*specifier-qualifier-list* *struct-declarator-list* **;**

*список-спецификаторов-и-квалификаторов*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-specifier* *specifier-qualifier-list*<sub>opt</sub><br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-qualifier* *specifier-qualifier-list*<sub>opt</sub>

*список-деклараторов-структуры*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*struct-declarator* *struct-declarator-list* **,** *struct-declarator*

*декларатор-структуры*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-specifier* *declarator*<sub>opt</sub> **:** *constant-expression*

Объявление типа структуры не оставляет места для структуры. Это всего лишь шаблон для последующих объявлений структурных переменных.

Ранее определенный *идентификатор* (тег) можно использовать для ссылки на структурный тип, определенный в другом месте. В этом случае *список-объявлений-структур* невозможно повторить, пока определение видно. Объявления указателей на структуры и объекты typedef для типов структуры могут использовать тег структуры до определения типа структуры. Однако определение структуры необходимо получить до выполнения каких-либо фактических действий с размером полей. Это неполное определение типа и тега типов. Для того чтобы это определение стало полным, определение типа должно отображаться позже в той же области.

*Список-объявлений-структуры* задает типы и имена элементов структуры. Аргумент *список-объявлений-структуры* содержит одну или несколько переменных или объявлений битовых полей.

Каждая переменная, объявленная в *списке-объявлений-структуры*, определяется как элемент структурного типа. Объявления переменных в *списке-объявлений-структуры* имеет ту же форму, что и другие объявления переменных, которые обсуждаются в этом разделе, с той разницей, что эти объявления не могут содержать описатели или инициализаторы класса хранения. Элементы структуры могут содержать любые типы переменной, кроме типа `void`, неполного типа или типа функции.

Невозможно объявить элемент так, чтобы он имел тип структуры, в которой отображается. Однако элемент можно объявить как указатель на структурный тип, в котором он отображается, при условии, что этот структурный тип имеет тег. Это позволяет создавать связанные списки структур.

Структуры имеют ту же область видимости, что и другие идентификаторы. Идентификаторы структур должны отличаться от всех тегов структур, объединений и перечислений с той же областью видимости.

Каждое *объявление-структуры* в *списке-объявления-структуры* должно быть уникальным в пределах списка. Однако имена идентификаторов в *списке-объявления-структуры* не должны отличаться от стандартных имен переменных или идентификаторов в других списках объявления структуры.

Доступ к вложенным структурам можно осуществлять так же, как если бы они были объявлены на уровне области файлов. Например, с данным объявлением

```C
struct a
{
    int x;
    struct b
    {
      int y;
    } var2;
} var1;
```

оба объявления являются допустимыми:

```C
struct a var3;
struct b var4;
```

## <a name="examples"></a>Примеры

В следующих примерах показаны объявления структуры.

```C
struct employee   /* Defines a structure variable named temp */
{
    char name[20];
    int id;
    long class;
} temp;
```

Структура `employee` содержит три члена: `name`, `id` и `class`. Член `name` — это 20-элементный массив, а `id` и `class` — простые элементы с типом `int` и **long** соответственно. Идентификатор `employee` является идентификатором структуры.

```C
struct employee student, faculty, staff;
```

В этом примере определяются три переменных структуры: `student`, `faculty` и `staff`. Каждая структура имеет такой же список из трех элементов. Эти элементы объявлены как имеющие структурный тип `employee`, определенный в предыдущем примере.

```C
struct           /* Defines an anonymous struct and a */
{                /* structure variable named complex  */
    float x, y;
} complex;
```

Структура `complex` содержит два элемента с типом **float** — `x` и `y`. Тип структуры не имеет тегов и, следовательно, является безымянным или анонимным.

```C
struct sample   /* Defines a structure named x */
{
    char c;
    float *pf;
    struct sample *next;
} x;
```

Первые два элемента структуры — это переменная `char` и указатель на значение **float**. Третий элемент, `next`, объявляется как указатель на определяемый структурный тип (`sample`).

Анонимные структуры могут быть полезны, если именованный тег не требуется. Это происходит в том случае, если одно объявление определяет все экземпляры структуры. Пример:

```C
struct
{
    int x;
    int y;
} mystruct;
```

Встроенные структуры часто являются анонимными.

```C
struct somestruct
{
    struct    /* Anonymous structure */
    {
        int x, y;
    } point;
    int type;
} w;
```

**Блок, относящийся только к системам Microsoft**

Компилятор позволяет использовать безразмерный массив или массив нулевого размера в качестве последнего члена структуры. Это полезно, если размер константного массива различается при использовании в разных ситуациях. Объявление такой структуры выглядит следующим образом.

**struct** *identifier* **{** *set-of-declarations* *type* <em>array-name</em> **\[]; };**

Безразмерные массивы могут отображаться только в качестве последнего члена структуры. Структуры, содержащие объявления безразмерных массивов, могут вкладываться в другие структуры при условии, что никакие другие элементы не объявлены ни в одной из внешних структур. Массивы таких структур использовать не разрешается. Оператор `sizeof`, если он применен к переменной этого типа или к самому типу, предполагает, что размер массива равен 0.

Объявления структуры также можно задать без декларатора, если они являются элементами другой структуры или объединения. Уровень имен полей повышается до уровня внешней структуры. Например, безыменная структура выглядит следующим образом:

```C
struct s
{
    float y;
    struct
    {
        int a, b, c;
    };
    char str[10];
} *p_s;
.
.
.
p_s->b = 100;  /* A reference to a field in the s structure */
```

См. справочные сведения о структурах в разделе [Элементы структур и объединений](../c-language/structure-and-union-members.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Деклараторы и объявления переменных](../c-language/declarators-and-variable-declarations.md)
