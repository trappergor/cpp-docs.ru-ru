---
title: Приоритет и порядок оценки | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- associativity of operators [C++]
- precedence [C++], operators
- data binding [C++], operator precedence
- operators [C++], precedence
ms.assetid: 201f7864-0c51-4c55-9d6f-39c5d013bcb0
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: ca8f77ee6d49aede8592d591241f8e2730fc15a8
ms.sourcegitcommit: 9a0905c03a73c904014ec9fd3d6e59e4fa7813cd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/29/2018
ms.locfileid: "43218460"
---
# <a name="precedence-and-order-of-evaluation"></a>Приоритет и порядок оценки
Приоритет и ассоциативность операторов C влияют на группировку и вычисление операндов в выражениях. Приоритет оператора имеет значение только в том случае, если рядом стоят другие операторы с более высоким или более низким приоритетом. Выражения с операторами с наивысшим приоритетом вычисляются первыми. Приоритет может также называться привязкой. Говорят, что операторы с более высоким приоритетом имеют более тесную привязку.  
  
 В следующей таблице указывается приоритет и ассоциативность (порядок вычисления операндов) операторов C, которые перечислены в порядке убывания приоритета. Если в одной строке отображается несколько операторов, они имеют равный приоритет и вычисляются с учетом их ассоциативности. Операторы, перечисленные в этой таблице, рассматриваются в разделе [Постфиксные операторы](../c-language/postfix-operators.md). В остальной части этого раздела приводятся общие сведения о приоритете и ассоциативности.  
  
## <a name="precedence-and-associativity-of-c-operators"></a>Приоритет и ассоциативность операторов C  
  
|Символ <sup>1</sup>|Тип операции|Ассоциативность|  
|-------------|-----------------------|-------------------|  
|**\[ ] ( ) . ->**<br /><br />**++** **--** (постфикс)|Выражение|Слева направо|  
**sizeof & \* + - ~ !**<br /><br />**++ --** (префикс)|Унарный|Справа налево|  
|*typecasts*|Унарный|Справа налево|  
|**\* / %**|Мультипликативный|Слева направо|  
|**+ -**|Аддитивный|Слева направо|  
|**\<\< >>**|Побитовый сдвиг|Слева направо|  
|**\< > \<= >=**|Реляционный|Слева направо|  
|**== !=**|Равенство|Слева направо|  
|**&**|Побитовое И|Слева направо|  
|**^**|Побитовое исключающее ИЛИ|Слева направо|  
|**&#124;**|Побитовое включающее ИЛИ|Слева направо|  
|**&&**|Логическое И|Слева направо|  
|**&#124;&#124;**|Логическое ИЛИ|Слева направо|  
|**? :**|Условное выражение|Справа налево|  
|**= \*= /= %=**<br /><br /> **+= -= \<\<= >>= &=**<br /><br /> **^= &#124;=**|Простое и составное присваивание <sup>2</sup>|Справа налево|  
|**,**|Последовательное вычисление|Слева направо|  
  
 1. Операторы перечислены в порядке убывания приоритета. Если в одной строке или группе находится несколько операторов, они имеют равный приоритет.  
  
 2. Все операторы простого и составного присваивания имеют равный приоритет.  
  
 Выражение может содержать несколько операторов с равным приоритетом. Если несколько таких операторов находятся в выражении на одном уровне, вычисление выполняется согласно их ассоциативности (либо справа налево, либо слева направо). Направление вычисления не влияет на результаты выражений, в которых на одном и том же уровне находится более одного оператора умножения (<strong>\*</strong>) или сложения (**+**) или бинарного побитового оператора (**&**, **&#124;** или **^**). Порядок операций не определен языком. Если компилятор может гарантировать согласованный результат, то он может вычислять такие выражения в любом порядке.  
  
 Только операторы последовательного вычисления (**,**), логический оператор AND (**&&**), логический оператор OR (**||**), операторы условных выражений (**? :**) и операторы вызова функции создают точки следования и тем самым гарантируют определенный порядок вычисления своих операндов. Оператор вызова функции представляет собой пару скобок, следующих за идентификатором функции. Оператор последовательного вычисления (**,**) гарантирует, что его операнды будут вычисляться слева направо. (Обратите внимание, что оператор-запятая в вызове функции не является оператором последовательного вычисления и не предоставляет таких гарантий.) Дополнительные сведения см. в разделе [Точки следования C](../c-language/c-sequence-points.md).  
  
 Логические операторы также гарантируют вычисление своих операндов слева направо. Однако они вычисляют наименьшее количество операндов, необходимое для определения результата выражения. Это называется "сокращенным вычислением". Таким образом, некоторые операнды в выражении могут не вычисляться. Например, в выражении:  
  
`x && y++`  
  
 второй операнд, `y++`, вычисляется, только если `x` имеет значение true (не равно нулю). Таким образом, если `y` дает значение false (0), то `x` не увеличивается.  
  
## <a name="examples"></a>Примеры
  
 Ниже приводится несколько примеров автоматической привязки выражений компилятором:  

|Выражение|Автоматическая привязка|  
|----------------|-----------------------|  
|a & b &#124;&#124; c|(a & b) &#124;&#124; c|  
|a = b &#124;&#124; c|a = (b &#124;&#124; c)|  
|q && r &#124;&#124; s--|(q && r) &#124;&#124; s--|  

 В первом выражении оператор побитового И (**&**) имеет более высокий приоритет, чем оператор логического ИЛИ (**||**), поэтому `a & b` формирует первый операнд операции логического ИЛИ.  
  
 Во втором выражении оператор логического ИЛИ (**||**) имеет более высокий приоритет, чем оператор простого присваивания (**=**), поэтому `b || c` группируется как правый операнд присваивания. Обратите внимание, что операнду `a` присваивается значение 0 или 1.  
  
 В третьем примере приводится правильно сформированное выражение, которое может дать непредвиденный результат. Оператор логического И (**&&**) имеет более высокий приоритет, чем оператор логического ИЛИ (**||**), поэтому `q && r` становится одним операндом. Так как логические операторы гарантируют вычисление операндов слева направо, то операция `q && r` вычисляется раньше, чем `s--`. Но если выражение `q && r` имеет ненулевое значение, то `s--` не вычисляется и `s` не уменьшается. Если то, что значение `s` не будет уменьшено, может вызвать проблемы в вашей программе, вы можете либо поставить `s--` первым операндом в выражении, либо выполнить декремент `s` в отдельной операции.  
  
 Следующее выражение недопустимо и приводит к созданию диагностического сообщения во время компиляции.  
  
|Недопустимое выражение|Группировка по умолчанию|  
|------------------------|----------------------|  
|p == 0 ? p += 1: p += 2|( p == 0 ? p += 1 : p ) += 2|  
  
 В этом выражении оператор равенства (**==**) имеет наибольший приоритет, поэтому выражение `p == 0` становится одним операндом. Далее по приоритету следует оператор условного выражения (**? :**). Его первым операндом является `p == 0`, а вторым — `p += 1`. Однако последним операндом оператора условного выражения считается не `p`, а `p += 2`, поскольку в этом случае `p` имеет более тесную привязку к оператору условного выражения, чем к оператору составного присваивания. Синтаксическая ошибка возникает потому, что операция `+= 2` не имеет левого операнда. Для того чтобы избежать ошибок такого рода и сделать код более читаемым, необходимо использовать скобки. Так, предыдущий пример можно исправить при помощи круглых скобок, как показано ниже:  
  
`( p == 0 ) ? ( p += 1 ) : ( p += 2 )`  
  
## <a name="see-also"></a>См. также  
 [Операторы в C](../c-language/c-operators.md)
