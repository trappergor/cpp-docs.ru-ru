---
title: Ошибка средств компоновщика LNK2005 | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- LNK2005
dev_langs:
- C++
helpviewer_keywords:
- LNK2005
ms.assetid: d9587adc-68be-425c-8a30-15dbc86717a4
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 8a3dbb1d63e7d7c6f5e036fc0cde967277c91a40
ms.sourcegitcommit: d3c41b16bf05af2149090e996d8e71cd6cd55c7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/09/2018
ms.locfileid: "48890131"
---
# <a name="linker-tools-error-lnk2005"></a>Ошибка средств компоновщика LNK2005

> *символ* уже определен в объекте

Символ *символ* был определен более одного раза.

Эта ошибка сопровождается неустранимой ошибки [LNK1169](../../error-messages/tool-errors/linker-tools-error-lnk1169.md).

### <a name="possible-causes-and-solutions"></a>Возможные причины и решения

Как правило, эта ошибка означает, что при разрыве *правило одного определения*, который обеспечивает только одно определение шаблона, функции, тип или объект в файл заданного объекта и только одно определение весь исполняемый файл для Видимый извне объекты или функции.

Ниже приведены некоторые распространенные причины этой ошибки.

- Эта ошибка может возникать, если файл заголовка определяет переменную. Например если включить файл заголовка в более чем один исходный файл в проект, результаты ошибку:

    ```h
    // LNK2005_global.h
    int global_int;  // LNK2005
    ```

   Ниже представлены возможные решения.

   - Объявите переменную `extern` в файле заголовка: `extern int global_int;`, определите его и инициализировать его при необходимости в один и только один исходный файл: `int global_int = 17;`. Эта переменная теперь является глобальным, можно использовать в любой файл, объявив ее `extern`, например, путем включения файла заголовка. Мы рекомендуем использовать это решение для переменных, которые должны быть глобальными, но хорошо программной инженерии подход сводит к минимуму глобальные переменные.

   - Объявите переменную [статический](../../cpp/storage-classes-cpp.md#static): `static int static_int = 17;`. Это ограничивает область определения в текущем файле объекта и несколько файлов объект имеет свою собственную копию переменной. Мы не рекомендуем статические переменные определяются в файлах заголовков из-за путаницы с глобальными переменными. Хотите переместить статического определения переменных в исходные файлы, которые их используют.

   - Объявите переменную [selectany](../../cpp/selectany.md): `__declspec(selectany) int global_int = 17;`. Это указывает компоновщику для выбора одного определения для использования, все внешние ссылки и отменить остальные. Это решение иногда бывает удобно при объединении библиотеки импорта. В противном случае не рекомендуется, чтобы избежать ошибки компоновщика.

- Эта ошибка может возникать, если файл заголовка определяет функции, не `inline`. Если включить этот файл заголовка в более чем один исходный файл, вы получите несколько определений функции в исполняемом файле.

    ```h
    // LNK2005_func.h
    int sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   Ниже представлены возможные решения.

   - Добавление `inline` ключевое слово в функцию:

        ```h
        // LNK2005_func_inline.h
        inline int sample_function(int k) { return 42 * (k % 167); }
        ```

   - Удалить тело функции из файла заголовка и оставьте только объявление, а затем реализовать функцию в один и только один исходный файл:

        ```h
        // LNK2005_func_decl.h
        int sample_function(int);
        ```

        ```cpp
        // LNK2005_func_impl.cpp
        int sample_function(int k) { return 42 * (k % 167); }
        ```

- Эта ошибка также может возникнуть при определении функций-членов вне объявления класса в файле заголовка:

    ```h
    // LNK2005_member_outside.h
    class Sample {
    public:
        int sample_function(int);
    };
    int Sample::sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   Чтобы устранить эту проблему, переместите определения функций элемента внутри класса. Член функции, определенные внутри объявления класса являются неявно встроенными.

    ```h
    // LNK2005_member_inline.h
    class Sample {
    public:
        int sample_function(int k) { return 42 * (k % 167); }
    };
    ```

- Эта ошибка может возникать при связывании более одной версии стандартной библиотеки или CRT. Например при попытке связать как розничной торговли и отладочные библиотеки CRT, а также статические и динамические версии библиотек или две различные версии стандартной библиотеки для исполняемого файла, эта ошибка регистрируется много раз. Чтобы устранить эту проблему, удалите все, кроме одного копирование каждой библиотеки из команды ссылку. Не рекомендуется смешивать розничной торговли и отладка библиотек или несколько версий библиотеки, в одном исполняемом объекте.

   Чтобы компоновщик для использования библиотеки, отличные от значения по умолчанию, в командной строке укажите библиотек и использовать [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) возможность отключения библиотеки по умолчанию. В интегрированной среде разработки, добавьте ссылки проекта, чтобы указать библиотеки для использования, а затем откройте **страницы свойств** диалоговое окно для проекта, а затем в **компоновщика**, **ввода** свойство либо задайте **игнорировать все стандартные библиотеки**, или **игнорировать определенные стандартные библиотеки** для отключения библиотеки по умолчанию.

- Эта ошибка может возникать, если перепутать использование статических и динамических библиотек при использовании [/CLR](../../build/reference/clr-common-language-runtime-compilation.md) параметр. Например Эта ошибка может возникать при построении библиотеки DLL для использования в исполняемый файл, ссылающийся на статической библиотеки CRT. Чтобы устранить эту проблему, используйте только статические библиотеки или только динамические библиотеки для всего исполняемого файла и любые библиотеки, создаваемые для использования в исполняемом файле.

- Эта ошибка может возникать, если символ является упакованной функцией (созданной путем компилирования с [/Gy](../../build/reference/gy-enable-function-level-linking.md)) и он был включен в несколько файлов, но изменен в промежутке между компиляциями. Чтобы устранить эту проблему, перекомпилируйте все файлы, включающие упакованной функцией.

- Эта ошибка может возникать, если этот символ определен по-разному в двух объектах-членах в различных библиотеках, и используются оба объекта-члена. Один из способов, чтобы устранить эту проблему, когда статически связанные библиотеки является объектом-участником из только к одной библиотеке, и включить эту библиотеку во-первых, в командной строке компоновщика. Чтобы использовать оба символа, необходимо создать способ их различать. Например если возможно выполнить построение библиотеки из источника, можно поместить каждую библиотеку в уникальное пространство имен. Кроме того можно создать новую библиотеку программы-оболочки, используются уникальные имена wrap ссылки на один из исходной библиотеки, связать новую библиотеку исходную библиотеку, а затем связать с вашей новой библиотеки, а не исходной библиотеки исполняемый файл.

- Эта ошибка может возникать, если `extern const` переменной значение определено дважды и имеет другое значение в каждое определение. Чтобы устранить эту проблему, определите константы только один раз или использовать пространства имен или `enum class` определения для различения константы.

- Эта ошибка может возникать, если вы используете uuid.lib в сочетании с другими файлами LIB, определяющими идентификаторы GUID (например, oledb.lib и adsiid.lib). Пример:

    ```Output
    oledb.lib(oledb_i.obj) : error LNK2005: _IID_ITransactionObject
    already defined in uuid.lib(go7.obj)
    ```

   Чтобы устранить эту проблему, добавьте [/FORCE: Multiple](../../build/reference/force-force-file-output.md) параметры командной строки компоновщика и убедитесь, что uuid.lib является первой библиотекой в ссылках.
