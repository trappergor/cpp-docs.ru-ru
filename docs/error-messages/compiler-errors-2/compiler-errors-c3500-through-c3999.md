---
title: Ошибки компилятора с C3500 по C3999 | Документация Майкрософт
ms.date: 11/17/2017
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
dev_langs:
- C++
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: d1a157bcd3ecdce16a25d5bb6523ed6962a94a18
ms.sourcegitcommit: e9ce38decc9f986edab5543de3464b11ebccb123
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/13/2018
ms.locfileid: "42541664"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Ошибки компилятора с C3500 по C3999

Статьи в этом разделе документации объясняется подмножество сообщения об ошибках, создаваемых компилятором.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Сообщения об ошибках

|Error|Сообщение|
|-----------|-------------|
|[Ошибка компилятора C3500](compiler-error-c3500.md)|Недопустимый ProgID "*progid*"|
|[Ошибка компилятора C3501](compiler-error-c3501.md)|нет библиотеки типов, зарегистрированной для ProgID "*progid*"|
|C3502 ошибки компилятора|Невозможно получить LIBID для ProgID "*progid*"|
|C3503 ошибки компилятора|символ "0 x*значение*" не допускается в необработанный строковый литерал|
|C3504 ошибки компилятора|не удается создать идентификатор GUID из строки "*строка*"|
|[Ошибка компилятора C3505](compiler-error-c3505.md)|не удается загрузить библиотеку типов "*библиотеки*"|
|[Ошибка компилятора C3506](compiler-error-c3506.md)|нет библиотеки типов, зарегистрированной для LIBID "*библиотеки*"|
|[Ошибка компилятора C3507](compiler-error-c3507.md)|ProgID не может иметь больше 39 символов*progid*"; не содержать знаки пунктуации '.'; и не может начинаться с цифры|
|[Ошибка компилятора C3508](compiler-error-c3508.md)|"*тип*": не является допустимым типом автоматизации|
|[Ошибка компилятора C3509](compiler-error-c3509.md)|"*тип*": недопустимый возвращаемый тип автоматизации; когда параметр помечен как «retval», тип возвращаемого значения должен быть «void», «HRESULT» или «SCODE»|
|[Ошибка компилятора C3510](compiler-error-c3510.md)|не удается найти библиотеку зависимых типов *библиотеки*|
|C3511 ошибки компилятора|"*идентификатор*": вызов делегирующего конструктора должен быть единственным инициализатором члена|
|C3512 ошибки компилятора|последовательность символов-разделителей для необработанные строковые литералы должны иметь не более 16 символов|
|C3513 ошибки компилятора|"*строка*": неподдерживаемый символ-разделитель литерала необработанной строки|
|C3514 ошибки компилятора|"*символ*" (*значение*): неподдерживаемый символ-разделитель литерала необработанной строки|
|C3515 ошибки компилятора|Если аргумент частичной специализации шаблона класса является раскрытием пакета, он должен быть последним аргументом|
|C3516 ошибки компилятора|непредвиденный конец файла найден при обработке необработанного строкового литерала; последовательность разделителей "*строка*" не соответствует|
|C3517 ошибки компилятора|"*идентификатор*": объявление псевдонима не может иметь тип, содержащий «auto»|
|Ошибка C3518 компилятора|"*идентификатор*": в контексте direct-list-initialization тип для "*тип*" можно вывести только из выражения с одним инициализатором|
|[Ошибка компилятора C3519](compiler-error-c3519.md)|"*параметр*": недопустимый параметр атрибута embedded_idl|
|C3520 ошибки компилятора|"*идентификатор*": пакет параметров должен раскрываться в этом контексте|
|C3521 ошибки компилятора|"*идентификатор*" не является пакетом параметров|
|C3522 ошибки компилятора|"*тип*": пакет параметров не может раскрываться в этом контексте|
|C3523 ошибки компилятора|«sizeof...» требует в качестве аргумента нераскрытый пакет параметров|
|C3524 ошибки компилятора|"*идентификатор*": «sizeof» не может использоваться для пакета параметров. Имелось в виду использование «sizeof...»?|
|C3525 ошибки компилятора|"*параметр*": Если в шаблоне класса имеется пакет параметров шаблона, он должен располагаться в конце списка параметров шаблона|
|C3526 ошибки компилятора|«...» не может применяться к «this»|
|C3527 ошибки компилятора|"*идентификатор*" не является допустимым операндом для «sizeof...». Имелось в виду использование «sizeof»?|
|C3528 ошибки компилятора|"*идентификатор1*": количество элементов в раскрытии пакета не соответствует числу элементов в "*идентификатор2*"|
|C3529 ошибки компилятора|"*параметр*": пакет параметров шаблона не может иметь аргумент по умолчанию|
|[Ошибка компилятора C3530](compiler-error-c3530.md)|"*тип*" нельзя использовать вместе с любой другими описателями типа|
|[Ошибка компилятора C3531](compiler-error-c3531.md)|"*идентификатор*": символ, тип которого содержит "*тип*" должно иметь инициализатор|
|[Ошибка компилятора C3532](compiler-error-c3532.md)|Тип элемента массива не может быть типом, содержащим "*тип*"|
|[Ошибка компилятора C3533](compiler-error-c3533.md)|параметр не может иметь тип, содержащий "*тип*"|
|Ошибка компилятора C3534|Является устаревшей.|
|[Ошибка компилятора C3535](compiler-error-c3535.md)|Невозможно вывести тип для "*тип1*«from»*тип2*"|
|[Ошибка компилятора C3536](compiler-error-c3536.md)|"*идентификатор*": нельзя использовать до инициализации|
|[Ошибка компилятора C3537](compiler-error-c3537.md)|не может быть приведен к типу, содержащему "*тип*"|
|[Ошибка компилятора C3538](compiler-error-c3538.md)|в списке объявлений "*тип*" всегда должен вывести к одному типу|
|[Ошибка компилятора C3539](compiler-error-c3539.md)|аргумент шаблона не может быть типом, содержащим "*тип*"|
|[Ошибка компилятора C3540](compiler-error-c3540.md)|Невозможно применить sizeof к типу, который содержит "*тип*"|
|[Ошибка компилятора C3541](compiler-error-c3541.md)|typeid нельзя применять к типу, содержащему "*тип*"|
|C3542 ошибки компилятора|"*идентификатор*": виртуальная функция-член не должен иметь тип возврата, который содержит "*тип*"|
|C3543 ошибки компилятора|"*тип*": не содержит пакет параметров|
|C3544 ошибки компилятора|"*параметр*": пакет параметров ожидает аргумент шаблона типа|
|C3545 ошибки компилятора|"*параметр*": пакет параметров ожидает аргумент шаблона не являющегося типом|
|C3546 ошибки компилятора|«...»: нет доступных для раскрытия пакетов параметров|
|C3547 ошибки компилятора|параметр шаблона "*параметр*«нельзя использовать, так как он пакет параметров шаблона и не может быть выведен из параметров функции»*функция*"|
|C3548 ошибки компилятора|"*идентификатор*": пакет параметров не может использоваться в этом контексте|
|C3549 ошибки компилятора|"*значение*": пакет параметров функции не может иметь аргумент по умолчанию|
|[Ошибка компилятора C3550](compiler-error-c3550.md)|только неструктурированный описатель "decltype(auto)" разрешен в этом контексте|
|[Ошибка компилятора C3551](compiler-error-c3551.md)|Если используется завершающий возвращаемый тип, то начальный возвращаемый тип должен быть одним спецификатором типа «auto» (не "*тип*")|
|[Ошибка компилятора C3552](compiler-error-c3552.md)|Ожидается «decltype(auto)»|
|[Ошибка компилятора C3553](compiler-error-c3553.md)|для "decltype" требуется выражение, а не тип|
|[Ошибка компилятора C3554](compiler-error-c3554.md)|"*тип*" нельзя использовать вместе с любой другими описателями типа|
|[Ошибка компилятора C3555](compiler-error-c3555.md)|неправильный аргумент для "decltype"|
|[Ошибка компилятора C3556](compiler-error-c3556.md)|"*выражение*": неправильный аргумент для «decltype»|
|Ошибка компилятора C3557|Является устаревшей.|
|Ошибка компилятора C3558|Является устаревшей.|
|C3559 ошибки компилятора|рекурсивный вызов "*функция*": рекурсия обнаруживается при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3560 ошибки компилятора|"*функция*": Встраивание недоступно при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3561 ошибки компилятора|Операция нарушения барьера найден в потоке управления с неравномерными не при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3562 ошибки компилятора|Встроенная функция "*функция*" ограничены не более чем *номер* параметров|
|C3563 ошибки компилятора|Обнаружен бесконечный цикл при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3564 ошибки компилятора|чтение неинициализированного значения при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3565 ошибки компилятора|Общий объем памяти tile_static (*номер* байт) превышает ограничение в *номер* байт при компиляции графа вызовов Concurrency::parallel_for_each по|
|C3566 ошибки компилятора|блоки с побочными эффектами вложены слишком глубоко при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3567 ошибки компилятора|деление на ноль или остаток от деления на ноль, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3568 ошибки компилятора|Сумма регистров превышает предел *номер* при компиляции графа вызовов Concurrency::parallel_for_each по. Упростите программы|
|C3569 ошибки компилятора|гонки, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|C3570 ошибки компилятора|Недопустимое использование amp ограниченные области при компиляции с параметром/CLR|
|C3571 ошибки компилятора|"*тип*": недопустимый аргумент домена вычислений; не тип класса|
|C3572 ошибки компилятора|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: «static const int rank» или значение ранга неположительно|
|C3573 ошибки компилятора|Количество экземпляров Concurrency::Graphics:: sampler, передаваемых в concurrency::parallel_for_each, не может превышать *номер*|
|C3574 ошибки компилятора|"*тип*": недопустимые размеры плитки: должны быть положительными и (1) Z < = *номер*; (2) Z*Y*X < = *номер*|
|C3575 ошибки компилятора|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: "concurrency::index <*номер*> _map_index (const concurrency::index <*номер*> &) restrict(amp) "|
|C3576 ошибки компилятора|"*тип*": аргумента Concurrency::Details:: #*номер* имеет неподдерживаемый тип|
|C3577 ошибки компилятора|Аргумент ядра Concurrency::parallel_for_each: не удается разрешить вызов члена "void operator() (*типа*) restrict(amp)"|
|C3578 ошибки компилятора|Размер объекта функции, передаваемых в concurrency::parallel_for_each, не может превышать *номер* байт|
|C3579 ошибки компилятора|Не может превышать число только для чтения экземпляров concurrency::array и Concurrency::Graphics:: Texture, передаваемых в concurrency::parallel_for_each *номер*|
|C3580 ошибки компилятора|Не может превышать количество доступных для записи экземпляров concurrency::array и Concurrency::Graphics:: Texture, передаваемых в concurrency::parallel_for_each *номер*|
|C3581 ошибки компилятора|"*тип*": неподдерживаемый тип в amp коде, ограниченном|
|C3582 ошибки компилятора|Является устаревшей.|
|C3583 ошибки компилятора|"*идентификатор*": размер переменной (*номер* байт) превышает максимальный размер (*номер* байт) поддерживается в коде, ограниченном amp|
|C3584 ошибки компилятора|не поддерживается использование tile_static в "*идентификатор*"|
|C3585 ошибки компилятора|"*идентификатор*" класс хранения не поддерживается в amp ограничил кода|
|C3586 ошибки компилятора|"*идентификатор*": Использование глобальных или статических переменных не поддерживается в коде, ограниченном amp|
|C3587 ошибки компилятора|dynamic_cast не поддерживается в коде, ограниченном amp|
|C3588 ошибки компилятора|приведение из "*тип1*«to»*тип2*" не поддерживается в коде, ограниченном amp|
|C3589 ошибки компилятора|"*строка*": неподдерживаемое использование строковых литералов в amp коде, ограниченном|
|C3590 ошибки компилятора|"*маркера*": по ссылке записи или записи «this» не поддерживается, если лямбда-выражение ограничено amp|
|C3591 ошибки компилятора|оператор typeid не поддерживается в коде, ограниченном amp|
|C3592 ошибки компилятора|Встраиваемая Машинная сборка (__asm) не поддерживается в коде, ограниченном amp|
|C3593 ошибки компилятора|Оператор «goto» не поддерживается в коде, ограниченном amp|
|C3594 ошибки компилятора|исключение обработки (try, catch, throw и т.д.) не поддерживается в коде, ограниченном amp|
|C3595 ошибки компилятора|постоянное значение находится вне допустимого диапазона в коде, ограниченном amp|
|C3596 ошибки компилятора|"*параметр*" ("*тип*"): переменная, захваченные лямбда-выражение имеет неподдерживаемый тип в коде, ограниченном amp|
|C3597 ошибки компилятора|"*параметр*": "*идентификатор*" не может быть захваченными значениями, если лямбда-выражение ограничено amp|
|C3598 ошибки компилятора|выражения меток не поддерживаются в коде, ограниченном amp|
|C3599 ошибки компилятора|"*оператор*": не удается выполнить расчеты с указателями на указатель на bool в коде, ограниченном amp|
|C3600 ошибки компилятора|"*функция*": используйте плитку\_статической памяти, обнаруженных при компиляции графа вызовов негруппируемого concurrency::parallel\_for_each в: "*функция*"|
|C3601 ошибки компилятора|"*тип*": недопустимый тип аргумента для диагностической функции amp "*функция*"|
|C3602 ошибки компилятора|Неподдерживаемая операция управления потоком, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|[Ошибка компилятора C3603](compiler-error-c3603.md)|"*символ*": тип "*тип*" еще не поддерживается|
|C3604 ошибки компилятора|"*идентификатор*": управляемый объект можно создать только в куче сборщика мусора|
|C3605 ошибки компилятора|Общее количество образцов (*номер* фиксируются и *номер* предопределенные) превышает *номер* при компиляции графа вызовов Concurrency::parallel_for_each по адресу: " *функция*"|
|C3606 ошибки компилятора|Является устаревшей.|
|Ошибка компилятора C3607|Является устаревшей.|
|C3608 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3609](compiler-error-c3609.md)|"*идентификатор*": функция «запечатанным или конечное» должна быть виртуальной|
|[Ошибка компилятора C3610](compiler-error-c3610.md)|"*идентификатор*": тип значения должен быть «упакован» перед методом "*метод*" может быть вызван|
|[Ошибка компилятора C3611](compiler-error-c3611.md)|"*идентификатор*": запечатанная функция не может иметь чистый спецификатор|
|[Ошибка компилятора C3612](compiler-error-c3612.md)|"*идентификатор*": у запечатанного класса не может быть чистые виртуальные методы|
|C3613 ошибки компилятора|отсутствует тип возвращаемого значения после «->» («предполагается int)|
|C3614 ошибки компилятора|Разные значения для размера пакета в рамках одного класса: предыдущим значением "*значение*«, новое значение —»*значение*"|
|[Ошибка компилятора C3615](compiler-error-c3615.md)|функция constexpr "*функция*" не может быть константным выражением|
|Ошибка компилятора C3616|Является устаревшей.|
|C3617 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3618](compiler-error-c3618.md)|"*объявление*": не может быть определен метод, помеченный как DllImport|
|[Ошибка компилятора C3619](compiler-error-c3619.md)|шаблон не может объявляться внутри типа управляемых/WinRT|
|C3620 ошибки компилятора|"*тип*": Задание выравнивания не допускается в типах WinRT|
|C3621 ошибки компилятора|"*тип*": только значение упаковки по умолчанию (*номер*) допускается для типов WinRT|
|[Ошибка компилятора C3622](compiler-error-c3622.md)|*Тип*": класс, объявленный как"*ключевое слово*"не может быть создан|
|[Ошибка компилятора C3623](compiler-error-c3623.md)|"*идентификатор*": битовые поля не поддерживаются в типах управляемых/WinRT|
|[Ошибка компилятора C3624](compiler-error-c3624.md)|"*тип*": использование этого типа необходима ссылка на сборки или модуля "*идентификатор*"|
|[Ошибка компилятора C3625](compiler-error-c3625.md)|"*класс*": собственный тип не может быть производным от типа управляемого/WinRT "*тип*"|
|[Ошибка компилятора C3626](compiler-error-c3626.md)|"*идентификатор*": "*ключевое слово*" ключевое слово может использоваться только в интерфейсах COM, функции-члены и члены данных, которые являются указателями на делегаты|
|[Ошибка компилятора C3627](compiler-error-c3627.md)|Только типы значений допускает упаковку-преобразование|
|[Ошибка компилятора C3628](compiler-error-c3628.md)|"*класс*': WinRT/управляемые классы поддерживают только открытое наследование|
|C3629 ошибки компилятора|"*маркера*": передаваемый параметр по умолчанию может использоваться только в начале списка захвата лямбда-выражения|
|[Ошибка компилятора C3630](compiler-error-c3630.md)|Ошибка при обработке лексемы "*маркера*"|
|[Ошибка компилятора C3631](compiler-error-c3631.md)|"*событий*": Невозможно перегрузить события управляемых/WinRT|
|[Ошибка компилятора C3632](compiler-error-c3632.md)|"*событий*": недопустимый тип события для *построения*|
|[Ошибка компилятора C3633](compiler-error-c3633.md)|не удается определить "*идентификатор*«как управляемую является членом»*класс*"|
|[Ошибка компилятора C3634](compiler-error-c3634.md)|"*член*": невозможно определить абстрактный метод класса управляемых/WinRT|
|C3635 ошибки компилятора|"*идентификатор*": не может применяться к классу управляемых/WinRT (используйте "*идентификатор*" вместо)|
|C3636 ошибки компилятора|"*идентификатор*": не может использоваться для этого типа|
|[Ошибка компилятора C3637](compiler-error-c3637.md)|"*функция*": определение дружественной функции не может быть специализацией функции шаблона или универсального класса|
|[Ошибка компилятора C3638](compiler-error-c3638.md)|"*оператор*": стандартный упаковки-преобразования и распаковки-операторы преобразования не может быть переопределен|
|C3639 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3640](compiler-error-c3640.md)|"*член*": функция адресуемая или виртуальная член локального класса должна быть определена|
|[Ошибка компилятора C3641](compiler-error-c3641.md)|"*функция*": недопустимое соглашение вызова "*соглашение*" для функции, скомпилированные с параметром/clr: pure или/CLR: safe|
|[Ошибка компилятора C3642](compiler-error-c3642.md)|"*функция*": невозможно вызвать функцию с соглашением вызова из машинного кода __clrcall|
|C3643 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3644](compiler-error-c3644.md)|"*функция*": не удается скомпилировать функцию для создания управляемого кода|
|[Ошибка компилятора C3645](compiler-error-c3645.md)|"*функция*": __clrcall невозможно использовать с функциями, скомпилированными в машинный код|
|[Ошибка компилятора C3646](compiler-error-c3646.md)|"*идентификатор*": Неизвестный спецификатор переопределения|
|C3647 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3648](compiler-error-c3648.md)|Этот синтаксис явного переопределения не поддерживается для управляемых типов|
|C3649 ошибки компилятора|Этот синтаксис явного переопределения нельзя использовать с параметром/zw|
|[Ошибка компилятора C3650](compiler-error-c3650.md)|"*член*": не может использоваться как явное переопределение, должен быть виртуальная функция-член базового класса|
|[Ошибка компилятора C3651](compiler-error-c3651.md)|"*член*": не может использоваться как явное переопределение, должен быть членом базового класса|
|[Ошибка компилятора C3652](compiler-error-c3652.md)|"*член*": явно переопределяющая функция должна быть виртуальной|
|[Ошибка компилятора C3653](compiler-error-c3653.md)|"*идентификатор*": нельзя использовать в качестве именованного переопределения: переопределяемая функция не найдена; возможно, вы забыли имя функции явно, с помощью ответ: оператор?|
|[Ошибка компилятора C3654](compiler-error-c3654.md)|"*маркера*": синтаксическая ошибка в явном переопределении|
|[Ошибка компилятора C3655](compiler-error-c3655.md)|"*член*": функция уже явно переопределена|
|[Ошибка компилятора C3656](compiler-error-c3656.md)|"*ключевое слово*": переопределение невозможно повторить, описатель|
|[Ошибка компилятора C3657](compiler-error-c3657.md)|деструктор или метод завершения не может явно переопределять или явно переопределяться|
|Ошибка компилятора C3658|Является устаревшей.|
|C3659 ошибки компилятора|"*член*": спецификатор переопределения "*ключевое слово*" не поддерживается|
|C3660 ошибки компилятора|"*член1*": скрывает унаследованный член "*член2*"|
|[Ошибка компилятора C3661](compiler-error-c3661.md)|в списке явных переопределений не обнаружил никаких методов для переопределения|
|[Ошибка компилятора C3662](compiler-error-c3662.md)|"*член*": спецификатор переопределения "*ключевое слово*" допустим только для функций-членов классов управляемых/WinRT|
|C3663 ошибки компилятора|Является устаревшей.|
|C3664 ошибки компилятора|"*член*": не может использоваться как явное переопределение, должен иметь режим доступа «public» или «защищенный»|
|[Ошибка компилятора C3665](compiler-error-c3665.md)|"*член*": спецификатор переопределения "*ключевое слово*" не разрешена для деструктора или метода завершения|
|[Ошибка компилятора C3666](compiler-error-c3666.md)|"*конструктор*": спецификатор переопределения "*ключевое слово*" не допускается в конструкторе|
|C3667 ошибки компилятора|"*атрибут*": атрибут не поддерживает расширение пакета|
|[Ошибка компилятора C3668](compiler-error-c3668.md)|"*член*": метод со спецификатором переопределения «override» не выполняли переопределение методов базового класса|
|[Ошибка компилятора C3669](compiler-error-c3669.md)|"*член*": спецификатор переопределения «override» не допускаются статические функции-члены или конструкторы|
|[Ошибка компилятора C3670](compiler-error-c3670.md)|"*член*": невозможно переопределить недоступный метод базового класса "*член*"|
|[Ошибка компилятора C3671](compiler-error-c3671.md)|"*член*": функция не переопределяет "*член*"|
|[Ошибка компилятора C3672](compiler-error-c3672.md)|выражение псевдо-деструктора можно использовать только как часть вызова функции|
|[Ошибка компилятора C3673](compiler-error-c3673.md)|"*класс*": класс не имеет конструктор копии|
|C3674 ошибки компилятора|не удалось найти модуль стандартной библиотеки "*модуль*"|
|[Ошибка компилятора C3675](compiler-error-c3675.md)|"*функция*": зарезервировано, поскольку "*свойство*" определяется|
|C3676 ошибки компилятора|"*класс*": класс ссылки и базовый класс имеют несовместимые атрибуты "[*атрибут*]"|
|C3677 ошибки компилятора|строковый литерал после «operator» не может иметь кодирующий префикс|
|C3678 ошибки компилятора|строковый литерал после «operator» должен быть пустая строка "»»»"|
|C3679 ошибки компилятора|Ожидается идентификатор литерального суффикса после "operator «»»"|
|C3680 ошибки компилятора|Невозможно объединить определенные пользователем строковые литералы с несоответствующими идентификаторами литеральных суффиксов|
|C3681 ошибки компилятора|«fallthrough»: атрибут может стоять только в закрывающем операторе switch|
|C3682 ошибки компилятора|"оператор *идентификатор*": шаблон оператора литерала оператор/literal не могут объявляться как «компоновку C»|
|C3683 ошибки компилятора|Невозможно определить необработанный литеральный оператор и шаблон литерального оператора с одинаковым идентификатором литерального суффикса|
|C3684 ошибки компилятора|"оператор *идентификатор*": объявление литерального оператора имеет недопустимый список параметров|
|C3685 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора не может иметь параметры функции|
|C3686 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора должен иметь ровно один параметр шаблона, — это пакет параметров|
|C3687 ошибки компилятора|"оператор *идентификатор*": шаблон литерального оператора должен иметь параметр шаблона не являющийся типом, имеющий тип «char»|
|Ошибка C3688 компилятора|Недопустимый литеральный суффикс "*суффикс*"; литерала оператор или литеральный шаблон оператора ' оператор *идентификатор*"не найден|
|C3689 ошибки компилятора|"оператор *идентификатор*": шаблон оператора литерала оператора или литерала должно быть в области глобальных или пространства имен|
|C3690 ошибки компилятора|ожидается строковый литерал, но обнаружен пользовательскую строку литерала вместо|
|C3691 ошибки компилятора|Недопустимый префикс литерала "*префикс*"|
|C3692 ошибки компилятора|Является устаревшей.|
|C3693 ошибки компилятора|Является устаревшей.|
|C3694 ошибки компилятора|Является устаревшей.|
|C3695 ошибки компилятора|Является устаревшей.|
|C3696 ошибки компилятора|"*ключевое слово*": этот квалификатор невозможно использовать на устройстве «%»|
|[Ошибка компилятора C3697](compiler-error-c3697.md)|"*ключевое слово*": этот квалификатор невозможно использовать для "^"|
|[Ошибка компилятора C3698](compiler-error-c3698.md)|"*тип*": нельзя использовать этот тип в качестве аргумента "*оператор*"|
|[Ошибка компилятора C3699](compiler-error-c3699.md)|"*оператор*": нельзя использовать перенаправление для типа "*тип*"|
|C3700 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3701](compiler-error-c3701.md)|"*функция*": источник событий не имеет событий|
|[Ошибка компилятора C3702](compiler-error-c3702.md)|Для событий COM требуется ATL|
|[Ошибка компилятора C3703](compiler-error-c3703.md)|"*event_handler*": метод обработчика событий должен возвращать такой же класс хранения, как и исходный "*событий*"|
|[Ошибка компилятора C3704](compiler-error-c3704.md)|"*член*": метод vararg не может порождать события|
|[Ошибка компилятора C3705](compiler-error-c3705.md)|"*функция*": невозможно найти интерфейс событий|
|[Ошибка компилятора C3706](compiler-error-c3706.md)|"*функция*": должен быть COM-интерфейс для порождения COM-событий|
|[Ошибка компилятора C3707](compiler-error-c3707.md)|"*член*": метод disp-интерфейса должен иметь dispid|
|[Ошибка компилятора C3708](compiler-error-c3708.md)|"*функция*": Неправильное использование "*ключевое слово*"; требуется член совместимого источника события|
|[Ошибка компилятора C3709](compiler-error-c3709.md)|"*функция*": неправильный синтаксис для задания события в __hook или __unhook|
|[Ошибка компилятора C3710](compiler-error-c3710.md)|"*функция*": неправильный синтаксис для задания обработчика событий в __hook или __unhook|
|[Ошибка компилятора C3711](compiler-error-c3711.md)|"*событий*": исходный метод неуправляемого события должен возвращать void или целый тип|
|[Ошибка компилятора C3712](compiler-error-c3712.md)|"*event_handler*": метод обработчика событий должен возвращать один и тот же тип как источник "*событий*"|
|[Ошибка компилятора C3713](compiler-error-c3713.md)|"*event_handler*": метод обработчика событий должен иметь такие же параметры функции в качестве источника "*событий*"|
|[Ошибка компилятора C3714](compiler-error-c3714.md)|"*event_handler*": метод обработчика событий должен возвращать соглашение о вызове как и исходный "*событий*"|
|[Ошибка компилятора C3715](compiler-error-c3715.md)|"*указатель*": должен быть указателем на "*тип*"|
|C3716 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3717](compiler-error-c3717.md)|"*член*": метод, порождающий события не может быть определен|
|[Ошибка компилятора C3718](compiler-error-c3718.md)|можно только вызов "__*ключевое слово*" в контексте функции-члена принимающего класса|
|[Ошибка компилятора C3719](compiler-error-c3719.md)|"*член*": источник событий на основе интерфейса может использоваться только для COM-событий|
|C3720 ошибки компилятора|"*тип*": IDispatch может реализовать только на двух или disp-интерфейс|
|[Ошибка компилятора C3721](compiler-error-c3721.md)|"*подписи*": несовместимая сигнатура для события|
|[Ошибка компилятора C3722](compiler-error-c3722.md)|Универсальное событие не допускается|
|[Ошибка компилятора C3723](compiler-error-c3723.md)|"*функция*": не удается разрешить событие|
|[Ошибка компилятора C3724](compiler-error-c3724.md)|необходимо #include < windows.h > для использования многопоточности в событиях|
|Ошибка компилятора C3725|Является устаревшей.|
|C3726 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3727](compiler-error-c3727.md)|"*событий*": управляемое событие должно быть функция-член или член данных, являющийся указателем на делегата|
|[Ошибка компилятора C3728](compiler-error-c3728.md)|"*событий*": событие не имеет метода raise|
|C3729 ошибки компилятора|Является устаревшей.|
|Ошибка компилятора C3730|Является устаревшей.|
|[Ошибка компилятора C3731](compiler-error-c3731.md)|несовместимые событие "*событий*«и обработчик»*event_handler*"; источник события и обработчик событий должен иметь один и тот же тип события|
|[Ошибка компилятора C3732](compiler-error-c3732.md)|"*интерфейс*": настраиваемый интерфейс, порождающий COM-события не может наследовать от интерфейса IDispatch|
|[Ошибка компилятора C3733](compiler-error-c3733.md)|"*событий*": неправильный синтаксис для задания COM-события; возможно, отсутствует «__interface»?|
|[Ошибка компилятора C3734](compiler-error-c3734.md)|"*класс*": класс управляемого/WinRT не может быть коклассом|
|C3735 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3736](compiler-error-c3736.md)|"*член*": должен быть методом или, в случае управляемых событий, при необходимости элемент данных|
|[Ошибка компилятора C3737](compiler-error-c3737.md)|"*идентификатор*": делегат не может иметь явное соглашение о вызове|
|[Ошибка компилятора C3738](compiler-error-c3738.md)|"*соглашение*": соглашение о вызове явном создании экземпляров должно совпадать со значением шаблона создаваемых экземпляров|
|[Ошибка компилятора C3739](compiler-error-c3739.md)|"*класс*": синтаксис является только поддерживается при "макет\_зависимые" параметр event_receiver имеет значение true|
|[Ошибка компилятора C3740](compiler-error-c3740.md)|"*шаблона*": шаблоны не источниками или приемниками событий|
|[Ошибка компилятора C3741](compiler-error-c3741.md)|"*класс*": должен быть компонентным классом при "макет\_зависимые" для event_receiver возвращает значение параметра равно true|
|C3742 ошибки компилятора|"*токен1*": Несбалансированная последовательность токенов в аргументе атрибута "*атрибут*«, ожидалось»*токен2*"|
|[Ошибка компилятора C3743](compiler-error-c3743.md)|можно только обработчик/откреплять весь интерфейс при «layout_dependent» для event_receiver имеет значение true|
|[Ошибка компилятора C3744](compiler-error-c3744.md)|для __unhook требуется по крайней мере 3 аргумента в случае управляемых событий|
|[Ошибка компилятора C3745](compiler-error-c3745.md)|"*функция*": только событие может быть «raised»|
|C3746 ошибки компилятора|стандартный атрибут "*идентификатор*" может отображаться не более одного раза в списке атрибутов|
|[Ошибка компилятора C3747](compiler-error-c3747.md)|отсутствует шаблон или универсальный параметр по умолчанию: параметр *номер*|
|[Ошибка компилятора C3748](compiler-error-c3748.md)|"*интерфейс*": неуправляемые интерфейсы не могут порождать события|
|[Ошибка компилятора C3749](compiler-error-c3749.md)|"*атрибут*": настраиваемый атрибут не может использоваться внутри функции|
|C3750 ошибки компилятора|"*маркера*": непредвиденный токен в список атрибутов|
|C3751 ошибки компилятора|"*идентификатор*": непредвиденный идентификатор в список атрибутов|
|[Ошибка компилятора C3752](compiler-error-c3752.md)|"*атрибут*": не удается классифицировать атрибут; "*ключевое слово*" не следует использовать в этом контексте|
|[Ошибка компилятора C3753](compiler-error-c3753.md)|универсальное свойство не допускается|
|[Ошибка компилятора C3754](compiler-error-c3754.md)|конструктор делегата: функцию-член "*член*«не может вызываться для экземпляра типа»*тип*"|
|[Ошибка компилятора C3755](compiler-error-c3755.md)|"*идентификатор*": делегат не могут быть определены|
|Ошибка компилятора C3756|Является устаревшей.|
|C3757 ошибки компилятора|"*тип*": тип не допускается для функции «constexpr»|
|C3758 ошибки компилятора|"*член*": виртуальная функция не может объявляться как «constexpr»|
|C3759 ошибки компилятора|"*член*": функция-член нелитерального типа не могут объявляться как «constexpr»|
|C3760 ошибки компилятора|Используйте ключевое слово __property для объявления свойства в управляемых/WinRT "*класс*"|
|[Ошибка компилятора C3761](compiler-error-c3761.md)|"*функция*": «retval» может присутствовать только в последнем аргументе функции|
|[Ошибка компилятора C3762](compiler-error-c3762.md)|не удается обработать атрибут "*атрибут*"|
|[Ошибка компилятора C3763](compiler-error-c3763.md)|"*тип*": «retval» и «out» могут использоваться только в тип данных указателя|
|[Ошибка компилятора C3764](compiler-error-c3764.md)|"*член*": невозможно переопределить метод базового класса "*член*"|
|[Ошибка компилятора C3765](compiler-error-c3765.md)|"*событий*": не удается определить события в классе или структуре "*тип*" с пометкой event_receiver|
|[Ошибка компилятора C3766](compiler-error-c3766.md)|"*тип*«необходимо обеспечить реализацию для метода интерфейса»*функция*"|
|[Ошибка компилятора C3767](compiler-error-c3767.md)|"*функция*": функции-кандидаты недоступны|
|[Ошибка компилятора C3768](compiler-error-c3768.md)|Невозможно получить адрес функции виртуального vararg в полностью управляемого кода|
|[Ошибка компилятора C3769](compiler-error-c3769.md)|"*идентификатор*": вложенный класс не может иметь имя, совпадающее с именем немедленно включающего класса|
|C3770 ошибки компилятора|"*тип*": не является допустимым базовым классом|
|[Ошибка компилятора C3771](compiler-error-c3771.md)|"*идентификатор*": в ближайшей области пространства имен не удалось найти дружественное объявление|
|[Ошибка компилятора C3772](compiler-error-c3772.md)|"*идентификатор*": Недопустимое объявление дружественного шаблона|
|C3773 ошибки компилятора|можно использовать параметр компилятора / await Чтобы включить соподпрограммы|
|C3774 ошибки компилятора|не удается найти "*область*::*идентификатор*": включите *заголовок* заголовка|
|C3775 ошибки компилятора|Тип возвращаемого значения "*функция*«не следует»*тип*"|
|C3776 ошибки компилятора|Невозможно вернуть выражение типа void в соподпрограмме с типом возвращаемого отличный от void|
|C3777 ошибки компилятора|"*функция*": соподпрограмма не может принимать переменное число аргументов|
|C3778 ошибки компилятора|alloca: невозможно использовать в соподпрограмме|
|C3779 ошибки компилятора|"*функция*": функция, возвращающая "*тип*" не может использоваться, пока она определена|
|C3780 ошибки компилятора|"*функция*": преобразование функции, которая возвращает*тип*"не может использоваться, пока она определена|
|C3781 ошибки компилятора|"*ключевое слово*": нельзя использовать в соподпрограмме типа "*тип*". Либо *ключевое слово* или *ключевое слово* должен присутствовать в связанных типе обещания promise_type|
|C3782 ошибки компилятора|*Тип*: обещание соподпрограммы не может одновременно содержать *ключевое слово* и *ключевое слово*|
|C3783 ошибки компилятора|"*идентификатор*": не может быть соподпрограммой|
|C3784 ошибки компилятора|*Ключевое слово* выражение не может указываться в этом контексте|
|C3785 ошибки компилятора|Первый аргумент шаблона для «std::integer_sequence» должен быть целочисленный тип|
|C3786 ошибки компилятора|Второй аргумент шаблона для «std::make_integer_sequence» должен быть целочисленной константой больше или равно нулю|
|C3787 ошибки компилятора|Невозможно вывести тип возвращаемого значения этой сопрограммы|
|C3788 ошибки компилятора|Является устаревшей.|
|C3789 ошибки компилятора|Является устаревшей.|
|C3790 ошибки компилятора|Является устаревшей.|
|C3791 ошибки компилятора|Является устаревшей.|
|C3792 ошибки компилятора|Является устаревшей.|
|C3793 ошибки компилятора|Является устаревшей.|
|C3794 ошибки компилятора|Является устаревшей.|
|C3795 ошибки компилятора|Является устаревшей.|
|C3796 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3797](compiler-error-c3797.md)|"*ключевое слово*": объявление события не может содержать спецификатор переопределения (должен быть размещен в методах добавления/remove/raise событий вместо)|
|[Ошибка компилятора C3798](compiler-error-c3798.md)|"*ключевое слово*": объявление свойства не может содержать спецификатор переопределения (должен быть размещен в свойства вместо get/set методы)|
|[Ошибка компилятора C3799](compiler-error-c3799.md)|индексированные свойства не может иметь пустой список параметров|
|[Ошибка компилятора C3800](compiler-error-c3800.md)|"*объявление*": нельзя смешивать свойства и события|
|C3801 ошибки компилятора|"*атрибут*": атрибут не может быть предложения аргумента|
|Ошибка компилятора C3802|Является устаревшей.|
|[Ошибка компилятора C3803](compiler-error-c3803.md)|"*свойство*": свойство имеет тип, который несовместим с одной из его методов доступа*доступа*"|
|[Ошибка компилятора C3804](compiler-error-c3804.md)|"*член*": методы доступа для свойства должны либо быть статическими, либо не статическими|
|[Ошибка компилятора C3805](compiler-error-c3805.md)|"*маркера*": непредвиденная лексема, требуется либо "} «, либо»,"|
|C3806 ошибки компилятора|"*маркера*": непредвиденная лексема, требуется либо "{" или инициализатор члена|
|[Ошибка компилятора C3807](compiler-error-c3807.md)|"*тип*": класс с атрибутом ComImport не может наследовать от "*тип*", допускается только реализация интерфейса|
|[Ошибка компилятора C3808](compiler-error-c3808.md)|"*тип*": класс с атрибутом ComImport не может определять член "*член*", только абстрактный или функции dllimport разрешены|
|[Ошибка компилятора C3809](compiler-error-c3809.md)|"*тип*": тип управляемых/WinRT не может иметь любой дружественные функции, классы и интерфейсы|
|C3810 ошибки компилятора|Является устаревшей.|
|Ошибка компилятора C3811|Является устаревшей.|
|[Ошибка компилятора C3812](compiler-error-c3812.md)|«__property» должна быть первой лексемой в объявлении свойства|
|[Ошибка компилятора C3813](compiler-error-c3813.md)|объявление свойства может присутствовать только в определение типа управляемых/WinRT|
|Ошибка компилятора C3814|Является устаревшей.|
|[Ошибка компилятора C3815](compiler-error-c3815.md)|Тип возвращаемого значения метода "*член*" должен соответствовать типу последнего параметра метода задания|
|[Ошибка компилятора C3816](compiler-error-c3816.md)|"класс или структура *член*" ранее объявлен или определен с другим модификатором управляемых/WinRT|
|[Ошибка компилятора C3817](compiler-error-c3817.md)|"*объявление*": свойство может применяться только к функции|
|[Ошибка компилятора C3818](compiler-error-c3818.md)|объявление свойства массива "*свойство*«не будет перегружать свойство индекса»*свойство*"|
|Ошибка компилятора C3819|Является устаревшей.|
|[Ошибка компилятора C3820](compiler-error-c3820.md)|"*идентификатор*": инициализаторы должны быть управляемыми|
|[Ошибка компилятора C3821](compiler-error-c3821.md)|"*функция*": управляемый тип или функция не может использоваться в неуправляемую функцию|
|Ошибка компилятора C3822|Является устаревшей.|
|Ошибка компилятора C3823|Является устаревшей.|
|[Ошибка компилятора C3824](compiler-error-c3824.md)|"*тип*": этот тип не может использоваться в этом контексте (параметр функции, тип возвращаемого значения или статический член)|
|[Ошибка компилятора C3825](compiler-error-c3825.md)|"*тип*": класс управляемого/WinRT поддерживает только управляемые/WinRT события|
|Ошибка компилятора C3826|Является устаревшей.|
|C3827 ошибки компилятора|стандартный атрибут «deprecated» может иметь без аргументов или один строковый литерал, описывающий причину|
|[Ошибка компилятора C3828](compiler-error-c3828.md)|аргументы размещения невозможно указать для "*ключевое слово*«выражение для типа»*тип*"|
|C3829 ошибки компилятора|стандартный атрибут «noreturn» можно применять только к функциям|
|[Ошибка компилятора C3830](compiler-error-c3830.md)|"*тип1*": не может наследовать от "*тип2*", типы значений могут наследовать только от классов интерфейсов|
|[Ошибка компилятора C3831](compiler-error-c3831.md)|"*идентификатор*": "*тип*" не может иметь закрепленные данные-член или функция-член, возвращающую закрепляющий указатель|
|[Ошибка компилятора C3832](compiler-error-c3832.md)|"*typelib*": тип библиотеки выглядит так, как если бы оно было создано для 32-разрядных указателей; измените квалификатор «ptrsize»|
|[Ошибка компилятора C3833](compiler-error-c3833.md)|"*тип*": недопустимый целевой тип для *идентификатор*|
|[Ошибка компилятора C3834](compiler-error-c3834.md)|недопустимое явное приведение к Закрепляющему указателю; Вместо этого используйте закрепленную локальную переменную|
|C3835 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3836](compiler-error-c3836.md)|статический конструктор не должна содержать список инициализации членов|
|C3837 ошибки компилятора|атрибуты не допускаются в этом контексте|
|[Ошибка компилятора C3838](compiler-error-c3838.md)|не может наследовать от "*тип*"|
|[Ошибка компилятора C3839](compiler-error-c3839.md)|Нельзя изменять выравнивание в типе управляемых/WinRT|
|Ошибка компилятора C3840|Является устаревшей.|
|Ошибка компилятора C3841|Является устаревшей.|
|[Ошибка компилятора C3842](compiler-error-c3842.md)|"*идентификатор*": квалификаторы «const» и «volatile» для функций-членов управляемых/WinRT типов не поддерживаются.|
|C3843 ошибки компилятора|"*идентификатор*": квалификаторы ref в функциях-членах типов управляемых/WinRT не поддерживаются.|
|C3844 ошибки компилятора|"*идентификатор*": не удается импортировать символ из "*источника*": как*идентификатор*"уже существует в текущей области|
|Ошибка компилятора C3845|Является устаревшей.|
|[Ошибка компилятора C3846](compiler-error-c3846.md)|"*идентификатор*": не удается импортировать символ из "*источника*": как*идентификатор*«уже был импортирован из другой сборки»*сборки*'|
|C3847 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3848](compiler-error-c3848.md)|выражение, имеющее тип "*тип*«потеряет некоторые квалификаторы const или volatile для вызова»*идентификатор*"|
|[Ошибка компилятора C3849](compiler-error-c3849.md)|вызов в стиле функции выражения типа "*тип*" будут потеряны квалификаторы const и volatile для всех *номер* доступных перегрузок операторов|
|[Ошибка компилятора C3850](compiler-error-c3850.md)|"*маркера*": универсальное имя символа определяет недопустимый символ.|
|[Ошибка компилятора C3851](compiler-error-c3851.md)|"*маркера*": универсальное имя символа не может обозначать символ в базовом наборе символов|
|[Ошибка компилятора C3852](compiler-error-c3852.md)|"*член*«с типом»*тип*": агрегатной инициализации не удалось инициализировать этот член|
|[Ошибка компилятора C3853](compiler-error-c3853.md)|«=»: повторная инициализация ссылки или присвоение через ссылку на функцию не допускается|
|[Ошибка компилятора C3854](compiler-error-c3854.md)|выражение слева от «=» дает функцию. Не удается назначить функцию (функция не является l значение)|
|[Ошибка компилятора C3855](compiler-error-c3855.md)|"*функция*": шаблон или универсальный параметр "*идентификатор*" несовместим с объявлением|
|[Ошибка компилятора C3856](compiler-error-c3856.md)|"*класс*": класс не является шаблон класса или универсальный|
|[Ошибка компилятора C3857](compiler-error-c3857.md)|"*шаблона*": не допускается несколько списки вложенных или универсальных параметров|
|[Ошибка компилятора C3858](compiler-error-c3858.md)|"*идентификатор*": невозможно повторно объявить в текущей области|
|[Ошибка компилятора C3859](compiler-error-c3859.md)|диапазон виртуальной памяти для PCH превышено; Повторите компиляцию с параметром командной строки "-Zm*номер*" или более поздней версии|
|[Ошибка компилятора C3860](compiler-error-c3860.md)|список аргументов шаблона или универсальный после имени шаблона или универсальный класс параметры должны перечисляться в порядок, используемый в списке или универсальных параметров|
|[Ошибка компилятора C3861](compiler-error-c3861.md)|"*идентификатор*": идентификатор не найден|
|[Ошибка компилятора C3862](compiler-error-c3862.md)|"*функция*": не удается скомпилировать неуправляемую функцию с параметром/clr: pure или/CLR: safe|
|C3863 ошибки компилятора|тип массива "*тип*" не может быть назначен|
|C3864 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3865](compiler-error-c3865.md)|"*ключевое слово*": может использоваться только в собственных функциях-членах|
|[Ошибка компилятора C3866](compiler-error-c3866.md)|отсутствует список аргументов вызова деструктора или метода завершения|
|[Ошибка компилятора C3867](compiler-error-c3867.md)|"*функция*": нестандартный синтаксис; используйте «&», чтобы создать указатель на член|
|[Ошибка компилятора C3868](compiler-error-c3868.md)|"*тип*": ограничения на универсальный параметр "*параметр*" отличаются от ограничений на объявление|
|[Ошибка компилятора C3869](compiler-error-c3869.md)|в ограничении gcnew отсутствует пустой параметр list «()»|
|C3870 ошибки компилятора|"*параметр*": "__declspec (*описатель*)" может применяться только к параметрам целочисленных типов|
|C3871 ошибки компилятора|"*параметр*": «__declspec(guard(overflow))» поддерживается только для первых 64 параметров функции|
|[Ошибка компилятора C3872](compiler-error-c3872.md)|"0 x*значение*": этот символ невозможно использовать в идентификаторе|
|[Ошибка компилятора C3873](compiler-error-c3873.md)|"0 x*значение*": этот символ недопустим как первый символ идентификатора|
|[Ошибка компилятора C3874](compiler-error-c3874.md)|Тип возвращаемого значения "*идентификатор*«должно быть»*тип1*«вместо of»*тип2*"|
|C3875 ошибки компилятора|вызов-нестатической функции члена отсутствует список аргументов|
|C3876 ошибки компилятора|Является устаревшей.|
|C3877 ошибки компилятора|Является устаревшей.|
|C3878 ошибки компилятора|Является устаревшей.|
|C3879 ошибки компилятора|"*член*": не может быть данными-членом initonly|
|[Ошибка компилятора C3880](compiler-error-c3880.md)|"*член*": не может быть данными-членом литерала|
|C3881 ошибки компилятора|конструктор может наследовать только от прямого базового|
|C3882 ошибки компилятора|"*класс*": конструктор уже унаследован от "*класс*"|
|Ошибка компилятора C3883|"*член*": статические данные-член initonly должен быть инициализирован|
|C3884 ошибки компилятора|"*тип*": массив неизвестного размера не может инициализироваться значением|
|C3885 ошибки компилятора|"*тип*": не удается инициализировать массив неизвестного размера с помощью пустого списка инициализаторов|
|[Ошибка компилятора C3886](compiler-error-c3886.md)|"*член*": данные-член литерала должны инициализироваться|
|[Ошибка компилятора C3887](compiler-error-c3887.md)|"*член*": инициализатор данные-член литерала должно быть константным выражением|
|[Ошибка компилятора C3888](compiler-error-c3888.md)|"*член*": выражение константы, связанное с этом данными-членом литерала не поддерживается в C + +/ CLI|
|C3889 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3890](compiler-error-c3890.md)|"*член*": невозможно получить адрес данные-член литерала|
|[Ошибка компилятора C3891](compiler-error-c3891.md)|"*член*": данные-член литерала нельзя использовать в качестве левого операнда|
|[Ошибка компилятора C3892](compiler-error-c3892.md)|"*переменной*": Невозможно присвоить переменной, которая является константным выражением|
|[Ошибка компилятора C3893](compiler-error-c3893.md)|"*член*": l значения можно использовать данные-член initonly допускается только в конструкторе экземпляра класса*класс*"|
|[Ошибка компилятора C3894](compiler-error-c3894.md)|"*член*": l значения можно использовать статические данные-член initonly допускается только в конструкторе класса для класса*класс*"|
|[Ошибка компилятора C3895](compiler-error-c3895.md)|"*член*": *тип* элементы данных не может быть «volatile»|
|[Ошибка компилятора C3896](compiler-error-c3896.md)|"*член*": недопустимый инициализатор: этот член данных литерала можно инициализировать только с «nullptr»|
|Ошибка компилятора C3897|Является устаревшей.|
|[Ошибка компилятора C3898](compiler-error-c3898.md)|"*член*": *тип* данные-члены могут быть только членами управляемых типов|
|[Ошибка компилятора C3899](compiler-error-c3899.md)|"*член*": l значения можно использовать данные-член initonly не допускается непосредственно внутри параллельной области в классе*класс*"|
|[Ошибка компилятора C3900](compiler-error-c3900.md)|"*член*": не допускается в текущей области|
|[Ошибка компилятора C3901](compiler-error-c3901.md)|"*функция*": должен иметь тип возвращаемого значения "*тип*"|
|[Ошибка компилятора C3902](compiler-error-c3902.md)|"*функция*": тип последнего параметра должен быть "*тип*"|
|[Ошибка компилятора C3903](compiler-error-c3903.md)|"*свойство*": does не установлен или get-метод|
|[Ошибка компилятора C3904](compiler-error-c3904.md)|"*свойство*": необходимо указать *номер* следующими параметрами:|
|C3905 ошибки компилятора|Невыровненные обращения не поддерживаются для подставляемого типа "*тип*"|
|C3906 ошибки компилятора|подставляемого типа "*тип*" не является поддерживаемым типом возврата или аргумент для функции с переменным количеством аргументов или без прототипа|
|C3907 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3908](compiler-error-c3908.md)|менее строгие, чем уровень доступа "*идентификатор*"|
|[Ошибка компилятора C3909](compiler-error-c3909.md)|объявление события WinRT или управляемого должно находиться в типе управляемых/WinRT|
|[Ошибка компилятора C3910](compiler-error-c3910.md)|"*событий*": должен определять член "*член*"|
|[Ошибка компилятора C3911](compiler-error-c3911.md)|"*член*": функция должна иметь тип "*тип*"|
|[Ошибка компилятора C3912](compiler-error-c3912.md)|"*событий*": тип события должен быть типом делегата|
|[Ошибка компилятора C3913](compiler-error-c3913.md)|свойство по умолчанию должно быть индексировано|
|[Ошибка компилятора C3914](compiler-error-c3914.md)|свойство по умолчанию не может быть статическим|
|[Ошибка компилятора C3915](compiler-error-c3915.md)|"*идентификатор*" имеет по умолчанию индексированное свойство (индексатора класса)|
|C3916 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3917](compiler-error-c3917.md)|"*маркера*": устаревшие *создания* стиль объявления (предполагалось использовать "[" "]" вместо?)|
|[Ошибка компилятора C3918](compiler-error-c3918.md)|требует использования "*идентификатор*" в качестве члена данных|
|[Ошибка компилятора C3919](compiler-error-c3919.md)|"*функция*": функция должна иметь тип "*return_type* (*типа*)"|
|[Ошибка компилятора C3920](compiler-error-c3920.md)|"*оператор*": не удается определить постфиксный увеличить или уменьшить значение вызове постфиксного оператора CLR или WinRT оператор CLR или WinRT будет вызов соответствующего префиксного CLR или WinRT оператор (op_Increment/op_Decrement), но со постфиксный семантика|
|Ошибка компилятора C3921|Является устаревшей.|
|C3922 ошибки компилятора|Является устаревшей.|
|[Ошибка компилятора C3923](compiler-error-c3923.md)|"*член*": определения локальных классов, структуры или объединения не разрешены в функции-члене класса WinRT или управляемого|
|C3924 ошибки компилятора|Ошибка в аргументе #*номер* вызова конструктора делегата "*конструктор*":|
|C3925 ошибки компилятора|Ожидался тип (for, while или do) следующих "*директива*" директива|
|C3926 ошибки компилятора|Недопустимая константа в директиве «parallel»|
|C3927 ошибки компилятора|«->»: завершающего возвращаемого типа не допускается после декларатора функции, не являющейся|
|C3928 ошибки компилятора|«->»: завершающего возвращаемого типа не допускается после декларатора в скобках|
|C3929 ошибки компилятора|Является устаревшей.|
|C3930 ошибки компилятора|"*функция*": нет перегруженной функции имеет описатели ограничений, совместимых с внешним контекстом "*контекст*"|
|C3931 ошибки компилятора|"*тип*": невозможно вызвать функцию, имеющую спецификаторы ограничений, несовместимые с внешним контекстом|
|C3932 ошибки компилятора|Является устаревшей.|
|C3933 ошибки компилятора|"*класс*": спецификаторы ограничения деструктора должны покрывать объединение ограничений для всех конструкторов|
|C3934 ошибки компилятора|функция, которая находится в любой форме «main» не может быть спецификаторов ограничений, отличных от restrict(cpu)|
|C3935 ошибки компилятора|"*идентификатор*": переопределение; перекрывающиеся спецификаторы ограничений|
|C3936 ошибки компилятора|"*идентификатор*": нераспознаваемый спецификатор ограничений|
|C3937 ошибки компилятора|пустой спецификатор ограничений не допускается|
|C3938 ошибки компилятора|"*идентификатор*": несколько описателей ограничений не поддерживаются для функций \042C\042 extern|
|C3939 ошибки компилятора|"*идентификатор*": указатель на функции-члены, указатели функций, ссылки на функции с описателем ограничения «amp» не допускаются|
|C3940 ошибки компилятора|"*идентификатор*": идентификатор не найден - возможное несоответствие между компилятора и версии библиотек. Следует обеспечить соответствие vccorlib.h/.lib, vccorlib120.dll и c1xx.dll|
|C3941 ошибки компилятора|"*условие*": требуется "/ clr" параметр командной строки|
|C3942 ошибки компилятора|Является устаревшей.|
|C3943 ошибки компилятора|Является устаревшей.|
|C3944 ошибки компилятора|Является устаревшей.|
|C3945 ошибки компилятора|"*тип*": невозможно выдать или перехватить объект winrt, не являющийся производным от Platform::Exception|
|C3946 ошибки компилятора|"*тип*": typeid невозможно применять к этому типу|
|C3947 ошибки компилятора|"*typeid*": typeid невозможно применять к раскрытию пакета|
|C3948 ошибки компилятора|"*ключевое слово*": раскрытие пакета не может использоваться в этом контексте|
|C3949 ошибки компилятора|Раскрытие пакета, «...», не может использоваться в абстрактного декларатора в скобках|
|C3950 ошибки компилятора|Является устаревшей.|
|C3951 ошибки компилятора|Нельзя использовать указатель на член в проецированном типе WinRT "*тип*". Вместо этого используйте делегат.|
|C3952 ошибки компилятора|"*тип*': WinRT не поддерживает массивы «in/out». Используйте "const Array<T>^" для «in» и "WriteOnlyArray<T>" или "Array<T>^ *" для «out» в открытых API|
|C3953 ошибки компилятора|Нельзя использовать управляемый класс*тип*"в модуле WinRT.|
|C3954 ошибки компилятора|"*тип*": массив, возвращаемый опубликованным методом в типе WinRT не может использовать форму "Array<T>^"|
|C3955 ошибки компилятора|"*тип*": открытый конструктор не может содержать параметр «out» или "WriteOnlyArray<T>"|
|C3956 ошибки компилятора|"*тип*": тип помечен как эксклюзивный для "*тип*«и не может использоваться в качестве базового тип»*производный_тип*"|
|C3957 ошибки компилятора|"*тип*": невозможно использовать «new» для WinRT типа; вместо этого используйте «ref new»|
|C3958 ошибки компилятора|"*тип*": нельзя использовать «gcnew» на WinRT типа; вместо этого используйте «ref new»|
|C3959 ошибки компилятора|«ref new» может использоваться только для создания объекта типа WinRT|
|C3960 ошибки компилятора|Является устаревшей.|
|C3961 ошибки компилятора|статический конструктор не поддерживается.|
|C3962 ошибки компилятора|Универсальный класс не поддерживается.|
|C3963 ошибки компилятора|многомерный массив не поддерживается.|
|C3964 ошибки компилятора|Массив массивов не поддерживается.|
|C3965 ошибки компилятора|Массив параметров не поддерживается.|
|C3966 ошибки компилятора|"*функция*": универсальная функция не поддерживается.|
|C3967 ошибки компилятора|Ошибка при импорте "*идентификатор*«из модуля»*модуль*"|
|C3968 ошибки компилятора|токен "*маркера*" является недопустимым разделителем имени модуля; использовать точку (".") вместо|
|C3969 ошибки компилятора|несогласованные имена модулей: "*module1*«и»*module1*"|
|C3970 ошибки компилятора|"*идентификатор*": "*ключевое слово*" может применяться только к «ref class» или «ref struct» в глобальной области или области видимости пространства имен|
|C3971 ошибки компилятора|"*тип*": разделяемое определение не может располагаться после полного определения|
|C3972 ошибки компилятора|"*тип*": «partial» может применяться только к объявлениям и определениям классов|
|C3973 ошибки компилятора|Является устаревшей.|
|C3974 ошибки компилятора|Является устаревшей.|
|C3975 ошибки компилятора|"класс или структура *идентификатор*" был ранее объявлен или определен с другим модификатором|
|C3976 ошибки компилятора|"*идентификатор1*«должен быть объявлен как 'public' для использования»*идентификатор2*"|
|C3977 ошибки компилятора|Использование необходима ссылка на сборку, определяющую "*идентификатор*"|
|C3978 ошибки компилятора|"*идентификатор*": статические свойства не допускается в качестве члена типа значения или интерфейса WinRT|
|C3979 ошибки компилятора|"*тип*": используйте атрибут "*атрибут*«вместо of»*значение*"|
|C3980 ошибки компилятора|"*тип*" нельзя передать в метаданных|
|C3981 ошибки компилятора|"*тип*": тип значения не может иметь любые статические данные-члены*идентификатор*"|
|C3982 ошибки компилятора|"*тип*": тип значения не может иметь любые данные, не являющиеся открытыми члены*идентификатор*"|
|C3983 ошибки компилятора|"*тип*": тип значения не может иметь любой общедоступный членов данных не*идентификатор*"|
|C3984 ошибки компилятора|"*тип*": незначимый тип не может иметь открытых элементов данных*идентификатор*"|
|C3985 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит частный тип "*член*"|
|C3986 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*член*"|
|C3987 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*тип*"|
|C3988 ошибки компилятора|"*тип*": собственный тип не может быть открытым|
|C3989 ошибки компилятора|"*тип*": вложенный тип не может быть открытым|
|C3990 ошибки компилятора|"*тип*": атрибут "*атрибут*" не может быть закрытым или вложенным|
|C3991 ошибки компилятора|"*тип*": невозможно реализовать неоткрытый или вложенный интерфейс "*интерфейс*"|
|C3992 ошибки компилятора|"*идентификатор*": сигнатура открытого члена содержит недопустимый тип "*тип*"|
|C3993 ошибки компилятора|"*тип*": тип значения должен содержать по крайней мере одно открытое поле|
|C3994 ошибки компилятора|"*тип*": тип значения не может реализовывать интерфейсы или иметь виртуальные функции|
|C3995 ошибки компилятора|"*тип*": у типа значений не может быть членов событий*идентификатор*"|
|Ошибка компилятора C3996|Является устаревшей.|
|C3998 ошибки компилятора|"c ++*версии*": неподдерживаемая версия C++; по умолчанию принимается "c ++*версии*"|
|C3999 ошибки компилятора|НЕИЗВЕСТНАЯ ошибка выберите команду технической поддержки в меню справки Visual C++ или откройте Справочный файл технической поддержки, Дополнительные сведения|
