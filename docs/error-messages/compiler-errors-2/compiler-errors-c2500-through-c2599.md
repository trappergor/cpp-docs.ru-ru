---
title: "Ошибки компилятора C2500 – C2599 | Документы Microsoft"
ms.custom: 
ms.date: 11/17/2017
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: error-reference
f1_keywords:
- C2501
- C2508
- C2515
- C2519
- C2520
- C2522
- C2525
- C2527
- C2536
- C2538
- C2539
- C2546
- C2547
- C2559
- C2560
- C2564
- C2565
- C2576
- C2578
- C2580
- C2590
- C2591
- C2595
- C2596
helpviewer_keywords:
- C2501
- C2508
- C2515
- C2519
- C2520
- C2522
- C2525
- C2527
- C2536
- C2538
- C2539
- C2546
- C2547
- C2559
- C2560
- C2564
- C2565
- C2576
- C2578
- C2580
- C2590
- C2591
- C2595
- C2596
dev_langs: C++
ms.assetid: a869aaed-e9f6-49e3-b273-00ea7f45bed7
caps.latest.revision: "15"
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 93616954d94c2e8ae1d679e5c8181520fd306237
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="compiler-errors-c2500-through-c2599"></a>Ошибки компилятора C2500 – C2599

Статьи в этом разделе документации объясняется подмножество сообщения об ошибках, которые создаются компилятором.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Сообщения об ошибках

|Error|Сообщение|
|-----------|-------------|
|[Ошибка компилятора C2500](compiler-error-C2500.md)|"*идентификатор1*": "*идентификатор2*" уже является прямым базовым классом|
|C2501 ошибки компилятора|"*идентификатор*': ' __declspec (*описатель*)" может применяться только для структур, объединений, классов или членов беззнаковых битовых полей|
|[Ошибка компилятора C2502](compiler-error-C2502.md)|"*идентификатор*": слишком много модификаторов доступа для базового класса|
|[Ошибка компилятора C2503](compiler-error-C2503.md)|"*класс*": базовые классы не могут содержать массивы нулевого размера|
|[Ошибка компилятора C2504](compiler-error-C2504.md)|"*класс*": базовый класс не определен|
|[Ошибка компилятора C2505](compiler-error-C2505.md)|"*символ*': ' __declspec (*описатель*)" может применяться только в объявлениях или определениях глобальных объектов или статических элементов данных|
|[Ошибка компилятора C2506](compiler-error-C2506.md)|"*член*': ' __declspec (*описатель*)" не может применяться к этому символу|
|[Ошибка компилятора C2507](compiler-error-C2507.md)|"*идентификатор*": слишком много виртуальных модификаторов для базового класса|
|C2508 ошибки компилятора|"*идентификатор*': ' __declspec (*спецификатор1*)" нельзя использовать вместе с "__declspec (*спецификатор2*)"|
|[Ошибка компилятора C2509](compiler-error-C2509.md)|"*идентификатор*": функция-член не объявлена в "*класс*"|
|[Ошибка компилятора C2510](compiler-error-C2510.md)|"*идентификатор*": выражение слева от "::" должен быть класс, структура или объединение|
|[Ошибка компилятора C2511](compiler-error-C2511.md)|"*идентификатор*": перегруженная функция-член не найдена в "*класс*"|
|[Ошибка компилятора C2512](compiler-error-C2512.md)|"*идентификатор*": нет подходящего конструктора по умолчанию доступен|
|[Ошибка компилятора C2513](compiler-error-C2513.md)|"* тип": нет переменных, объявленных перед «=»|
|[Ошибка компилятора C2514](compiler-error-C2514.md)|"*класс*": класс не имеет конструкторов|
|C2515 ошибки компилятора|"*идентификатор*": «vtguard» может применяться только к объявлениям или определениям классов|
|[Ошибка компилятора C2516](compiler-error-C2516.md)|"*класс*": не является допустимым базовым классом|
|[Ошибка компилятора C2517](compiler-error-C2517.md)|"*идентификатор*": слева от "::" не определено|
|[Ошибка компилятора C2518](compiler-error-C2518.md)|Ключевое слово "*ключевое слово*" недопустим в списке базовых классов; пропускается|
|C2519 ошибки компилятора|"*идентификатор*": атрибуты WinRT могут содержать только открытые поля|
|C2520 ошибки компилятора|"*класс*": нет неявных конструкторов для неявного преобразования|
|[Ошибка компилятора C2521](compiler-error-C2521.md)|метод завершения или деструктор не принимает никаких аргументов|
|C2522 ошибки компилятора|"*идентификатор*": идентификатор перегрузки не может использоваться для "*идентификатор1*«как он уже указан в»*идентификатор2*"|
|[Ошибка компилятора C2523](compiler-error-C2523.md)|"*класса*:: ~*идентификатор*": несовпадение тегов деструктора или метода завершения|
|[Ошибка компилятора C2524](compiler-error-C2524.md)|"*идентификатор*": метод завершения или деструктор должен иметь список параметров «void»|
|C2525 ошибки компилятора|"*идентификатор*": параметр "*идентификатор1*«имеет имя»*идентификатор2*" на основе функции и должен совпадать в опубликованной реализации|
|[Ошибка компилятора C2526](compiler-error-C2526.md)|"*идентификатор1*": функция с компоновкой не может возвращать класс C++*идентификатор2*"|
|C2527 ошибки компилятора|"*идентификатор*": нельзя указывать DefaultOverload на обоих "*функция1*«и»*функция2*". Удалите одну спецификацию или переименуйте функцию на этапе реализации|
|[Ошибка компилятора C2528](compiler-error-C2528.md)|"*идентификатор*": недопустимый указатель на ссылку|
|[Ошибка компилятора C2529](compiler-error-C2529.md)|"*идентификатор*": ссылка на ссылку недопустима|
|[Ошибка компилятора C2530](compiler-error-C2530.md)|"*идентификатор*": ссылки должны быть инициализированы|
|[Ошибка компилятора C2531](compiler-error-C2531.md)|"*идентификатор*": ссылка на битовое поле недопустима|
|[Ошибка компилятора C2532](compiler-error-C2532.md)|"*идентификатор*": недопустимый модификатор для ссылки|
|[Ошибка компилятора C2533](compiler-error-C2533.md)|"*идентификатор*": конструкторы не разрешены для возвращаемого типа|
|[Ошибка компилятора C2534](compiler-error-C2534.md)|"*идентификатор*": конструктор не может возвращать значение|
|[Ошибка компилятора C2535](compiler-error-C2535.md)|"*идентификатор*": функция-член уже определена или объявлена|
|Ошибка компилятора C2536|Является устаревшей.|
|[Ошибка компилятора C2537](compiler-error-C2537.md)|"*описатель*": Недопустимая спецификация компоновки|
|Ошибка компилятора C2538|Является устаревшей.|
|Ошибка компилятора C2539|Является устаревшей.|
|[Ошибка компилятора C2540](compiler-error-C2540.md)|неконстантное выражение в качестве границы массива|
|[Ошибка компилятора C2541](compiler-error-C2541.md)|"*идентификатор*": не удается удалить объекты, не являющиеся указателями|
|[Ошибка компилятора C2542](compiler-error-C2542.md)|"*идентификатор*": класс не имеет конструктора для инициализации|
|[Ошибка компилятора C2543](compiler-error-C2543.md)|ожидается "]" для оператора «[]»|
|[Ошибка компилятора C2544](compiler-error-C2544.md)|Ожидалось ")" для оператора «()»|
|[Ошибка компилятора C2545](compiler-error-C2545.md)|"*оператор*": не удается найти перегруженный оператор|
|C2546 ошибки компилятора|"*идентификатор*": Если тип определен в сборках PIA и no-PIA PIA должна быть указана первой|
|C2547 ошибки компилятора|"*идентификатор*": все параметры опубликованного метода должны быть явно заданы в объявлении|
|[Ошибка компилятора C2548](compiler-error-C2548.md)|"*функция*": отсутствует параметр по умолчанию для параметра *параметр*|
|[Ошибка компилятора C2549](compiler-error-C2549.md)|определенное пользователем преобразование невозможно указать тип возвращаемого значения|
|[Ошибка компилятора C2550](compiler-error-C2550.md)|"*идентификатор*": списки инициализации допускаются только в определениях конструкторов|
|[Ошибка компилятора C2551](compiler-error-C2551.md)|для типа "void *" требуется явное приведение|
|[Ошибка компилятора C2552](compiler-error-C2552.md)|"*идентификатор*": не удается инициализировать нестатистические данные с помощью списка инициализаторов|
|[Ошибка компилятора C2553](compiler-error-C2553.md)|"*тип* *derived_class*::*функция*": переопределение возвращаемый тип виртуальной функции отличается от "*тип* *base_ Класс*::*функция*"|
|[Ошибка компилятора C2555](compiler-error-C2555.md)|"*derived_class*::*функция*": переопределение виртуальной функции возвращают тип отличается и не является ковариантным из "*base_class*::*функция*'|
|[Ошибка компилятора C2556](compiler-error-C2556.md)|"*тип1* *класса*::*функция*": перегруженная функция отличается только возвращаемым типом "*тип2* *класса*::*функция*"|
|[Ошибка компилятора C2557](compiler-error-C2557.md)|"*идентификатор*": закрытые и защищенные члены нельзя инициализировать без конструктора|
|[Ошибка компилятора C2558](compiler-error-C2558.md)|Класс*класс*": нет доступных конструкторов копии или конструктор копии объявлен как «explicit»|
|C2559 ошибки компилятора|"*идентификатор*": нельзя перегрузить функцию-член без квалификатора ref функцию-член с квалификатором ref|
|C2560 ошибки компилятора|"*идентификатор*": нельзя перегрузить функцию-член с квалификатором ref функцию-член без квалификатора ref|
|[Ошибка компилятора C2561](compiler-error-C2561.md)|"*функция*": функция должна возвращать значение|
|[Ошибка компилятора C2562](compiler-error-C2562.md)|"*функция*": «void» функция, возвращающая значение|
|[Ошибка компилятора C2563](compiler-error-C2563.md)|Несоответствие в списке формальных параметров|
|Ошибка компилятора C2564|Является устаревшей.|
|C2565 ошибки компилятора|"*идентификатор*": квалификатор ref недопустим для конструкторов и деструкторов|
|[Ошибка компилятора C2566](compiler-error-C2566.md)|перегруженная функция в условном выражении|
|[Ошибка компилятора C2567](compiler-error-C2567.md)|не удается открыть метаданные в "*filename*", *possible_reason*|
|[Ошибка компилятора C2568](compiler-error-C2568.md)|"*идентификатор*": не удалось разрешить перегрузку функции|
|[Ошибка компилятора C2569](compiler-error-C2569.md)|"*идентификатор*": перечисление или объединение не может использоваться как базовый класс|
|[Ошибка компилятора C2570](compiler-error-C2570.md)|"*идентификатор*": объединение не может иметь базовые классы|
|[Ошибка компилятора C2571](compiler-error-C2571.md)|"*идентификатор*": виртуальная функция не может быть в объединении "*объединение*"|
|[Ошибка компилятора C2572](compiler-error-C2572.md)|"*функция*": переопределение параметра по умолчанию: параметр *номер*|
|[Ошибка компилятора C2573](compiler-error-C2573.md)|"*класс*": невозможно удалить указатели на объекты этого типа; в классе имеется ни одна из перегрузок «operator delete» без аргументов размещения. Используйте:: удалите или добавьте в класс «operator delete(void*)»|
|[Ошибка компилятора C2574](compiler-error-C2574.md)|"*деструктор*": нельзя объявлять как статическое|
|[Ошибка компилятора C2575](compiler-error-C2575.md)|"*идентификатор*": только для функций-членов и базовых объектов могут быть виртуальными|
|C2576 ошибки компилятора|"*идентификатор*": не удается внести нового виртуального метода как 'public'. Попробуйте сделать метод невиртуальным или измените специальные возможности «internal» или «protected private»|
|[Ошибка компилятора C2577](compiler-error-C2577.md)|"*идентификатор*": метод завершения или деструктор не может иметь тип возвращаемого значения|
|C2578 ошибки компилятора|"*класс*": не может иметь тип «protected» или «protected public» конструктор|
|[Ошибка компилятора C2579](compiler-error-C2579.md)|не удалось разрешить тип *тип* (*смещение*). Ожидается в *имя файла*|
|C2580 ошибки компилятора|"*идентификатор*": не допускаются несколько версий по умолчанию специальные функции-члены|
|[Ошибка компилятора C2581](compiler-error-C2581.md)|"*типа*": статический "operator =" функции не допускается|
|[Ошибка компилятора C2582](compiler-error-C2582.md)|"оператор *оператор*«функция недоступна в»*типа*"|
|[Ошибка компилятора C2583](compiler-error-C2583.md)|"*идентификатор*": «const или volatile» указатель «this» является недопустимым для конструкторов и деструкторов|
|[Ошибка компилятора C2584](compiler-error-C2584.md)|"*класса*": прямым базовым классом "*base_class2*" недоступен; уже является базовым классом "*base_class1*"|
|[Ошибка компилятора C2585](compiler-error-C2585.md)|явное преобразование в "*типа*" является неоднозначным|
|[Ошибка компилятора C2586](compiler-error-C2586.md)|Неверное преобразование определяемых пользователем синтаксис: недопустимые косвенные обращения|
|[Ошибка компилятора C2587](compiler-error-C2587.md)|"*идентификатор*": Недопустимое использование локальной переменной в качестве параметра по умолчанию|
|[Ошибка компилятора C2588](compiler-error-C2588.md)|":: ~*идентификатор*": недопустимый глобальный деструктор или метод завершения|
|[Ошибка компилятора C2589](compiler-error-C2589.md)|"*идентификатор*": недопустимый маркер справа от "::"|
|C2590 ошибки компилятора|"*идентификатор*": конструктор может иметь список инициализаторов членов и базовых только|
|C2591 ошибки компилятора|ExclusiveTo не может использовать "*типа*" в качестве аргумента. Только «ref class» является допустимым аргументом|
|[Ошибка компилятора C2592](compiler-error-C2592.md)|"*класса*": "*base_class2*«наследуется от»*base_class1*" и не может быть указан повторно|
|[Ошибка компилятора C2593](compiler-error-C2593.md)|"оператор *идентификатор*" является неоднозначным|
|[Ошибка компилятора C2594](compiler-error-C2594.md)|"*оператор*": неоднозначные преобразования "*тип1*«to»*тип2*"|
|C2595 ошибки компилятора|"*идентификатор*" тип атрибута WinRT должны быть запечатаны|
|C2596 ошибки компилятора|"*идентификатор*" поле атрибута WinRT может быть только «public enum class», «int», «unsigned int», «bool», «Platform::Type», «Platform::String» или «Windows: Foundation:: HResult»|
|[Ошибка компилятора C2597](compiler-error-C2597.md)|Недопустимая ссылка на нестатический член "*идентификатор*"|
|[Ошибка компилятора C2598](compiler-error-C2598.md)|компоновки должен определяться в глобальной области видимости|
|[Ошибка компилятора C2599](compiler-error-C2599.md)|"*идентификатор*": опережающее объявление перечисляемого типа управляемых WinRT не допускается|  