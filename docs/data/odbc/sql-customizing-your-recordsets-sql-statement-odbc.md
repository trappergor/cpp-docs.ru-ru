---
title: 'SQL: Настройка инструкции SQL набора записей (ODBC) | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-data
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- recordsets, SQL statements
- ODBC recordsets, SQL statements
- SQL statements, customizing
- SQL statements, recordset
- customizing SQL statements
- overriding, SQL statements
- SQL, opening recordsets
ms.assetid: 72293a08-cef2-4be2-aa1c-30565fcfbaf9
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: c6562689450aab15a766d315f9a948772613c5dd
ms.sourcegitcommit: 7eadb968405bcb92ffa505e3ad8ac73483e59685
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2018
ms.locfileid: "39209252"
---
# <a name="sql-customizing-your-recordsets-sql-statement-odbc"></a>SQL. Настройка инструкции SQL набора записей (ODBC)
Содержание раздела:  
  
-   Как платформа создает инструкцию SQL  
  
-   Переопределение инструкции SQL  
  
> [!NOTE]
>  Эти сведения относятся к классам ODBC библиотеки MFC. Если вы работаете с классами MFC DAO, см. в разделе «Сравнения Microsoft Jet базы данных ядра SQL и ANSI SQL» в справке DAO.  
  
## <a name="sql-statement-construction"></a>Конструирование инструкций SQL  
 Набор записей выполняет выделение записи в основном на SQL **ВЫБЕРИТЕ** инструкции. При объявлении класса с помощью мастера, он записывает переопределение `GetDefaultSQL` функция-член, выглядит примерно следующим образом (для класса набора записей называется `CAuthors`).  
  
```  
CString CAuthors::GetDefaultSQL()  
{  
    return "AUTHORS";  
}  
```  
  
 По умолчанию это переопределение возвращает имя таблицы, указанное с помощью мастера. В этом примере имя таблицы — «АВТОРЫ». При последующем вызове набора записей **откройте** функции-члена **откройте** создает окончательную **ВЫБЕРИТЕ** инструкцию для формы:  
  
```  
SELECT rfx-field-list FROM table-name [WHERE m_strFilter]   
       [ORDER BY m_strSort]  
```  
  
 где `table-name` получается путем вызова `GetDefaultSQL` и `rfx-field-list` получается из вызова функций RFX в `DoFieldExchange`. Это именно **ВЫБЕРИТЕ** инструкции, если не будет заменена переопределением во время выполнения, несмотря на то, что также можно изменить инструкцию по умолчанию с параметрами или фильтр.  
  
> [!NOTE]
>  Если указать имя столбца, который содержит (или может содержать) пробелы, необходимо заключить имя в квадратные скобки. Например «First Name» должны называться «[имя]».  
  
 Чтобы переопределить значение по умолчанию **ВЫБЕРИТЕ** инструкции, передайте этот строка, содержащая полный **ВЫБЕРИТЕ** инструкции при вызове **откройте**. Вместо создания собственной строки по умолчанию, набор записей использует строку, которую вы указали. Если замещающая инструкция содержит **ГДЕ** предложение, задают фильтр в **m_strFilter** так, как будет получено два фильтра инструкций. Аналогично Если замещающая инструкция содержит **ORDER BY** предложение, не указать порядок сортировки в `m_strSort` таким образом, чтобы не нужно будет двух инструкций сортировки.  
  
> [!NOTE]
>  Если вы используете строковых литералов в фильтрах (или других частей инструкции SQL), может потребоваться «Квота» (заключить в указанные разделители) такие строки с префиксом литерала СУБД и литералов суффикс, символ (или символы).  
  
 Особые требования к синтаксису для операций, таких как внешние соединения также могут возникнуть в зависимости от используемой СУБД. Использование функции ODBC для получения этих сведений от драйвера для СУБД. Например, вызвать **:: SQLGetTypeInfo** для определенного типа данных, таких как **SQL_VARCHAR**, чтобы запросить **LITERAL_PREFIX** и **LITERAL_SUFFIX** символов. При написании кода базы данных, см в *ODBC SDK ** справочнике программиста* на компакт-диске библиотеки MSDN подробные сведения о синтаксисе.  
  
 Объект набора записей создает инструкцию SQL, которая используется для выбора записей в том случае, если не передать пользовательские инструкции SQL. Как это можно сделать главным образом зависит от значения, передаваемого в `lpszSQL` параметр **откройте** функция-член.  
  
 Общий вид SQL **ВЫБЕРИТЕ** инструкция является:  
  
```  
SELECT [ALL | DISTINCT] column-list FROM table-list  
    [WHERE search-condition][ORDER BY column-list [ASC | DESC]]  
```  
  
 Можно добавить **DISTINCT** ключевое слово для инструкции SQL набора записей является внедрение ключевого слова в первый вызов функции RFX в `DoFieldExchange`. Пример:  
  
```  
...  
    RFX_Text(pFX, "DISTINCT CourseID", m_strCourseID);  
...  
```  
  
> [!NOTE]
>  Этот метод можно используйте только с набором записей, открыт только для чтения.  
  
## <a name="overriding-the-sql-statement"></a>Переопределение инструкции SQL  
 В следующей таблице показаны возможности `lpszSQL` параметр **откройте**. В таблице случаи описаны в следующей таблице.  
  
 **LpszSQL параметр и результирующая строка SQL**  
  
|Case|Передайте lpszSQL|Результирующая инструкция SELECT|  
|----------|------------------------------|------------------------------------|  
|1|**NULL**|**ВЫБЕРИТЕ** *rfx список полей* **FROM** *имя таблицы*<br /><br /> `CRecordset::Open` вызовы `GetDefaultSQL` для получения имени таблицы. Результирующая строка является одним из случаев 2 – 5, в зависимости от того, что `GetDefaultSQL` возвращает.|  
|2|Имя таблицы|**ВЫБЕРИТЕ** *rfx список полей* **FROM** *имя таблицы*<br /><br /> Список полей берется из инструкций RFX в `DoFieldExchange`. Если **m_strFilter** и `m_strSort` не пусты, добавляет **ГДЕ** и/или **ORDER BY** предложения.|  
|3 \*|Полный **ВЫБЕРИТЕ** инструкции но без **ГДЕ** или **ORDER BY** предложение|Как пройденный. Если **m_strFilter** и `m_strSort` не пусты, добавляет **ГДЕ** и/или **ORDER BY** предложения.|  
|4 \*|Полный **ВЫБЕРИТЕ** инструкции с **ГДЕ** и/или **ORDER BY** предложение|Как пройденный. **m_strFilter** и/или `m_strSort` должен оставаться пустым или два фильтра или сортировки инструкций.|  
|5 \*|Вызов хранимой процедуры|Как пройденный.|  
  
 \* `m_nFields` должно быть меньше или равно количеству столбцов, указанных в **ВЫБЕРИТЕ** инструкции. Тип данных каждого столбца, указанного в **ВЫБЕРИТЕ** инструкция должна быть совпадал с типом данных соответствующего выходного столбца RFX.  
  
### <a name="case-1---lpszsql--null"></a>Case 1 lpszSQL = NULL  
 Выбор набора записей зависит от что `GetDefaultSQL` возвращает, если `CRecordset::Open` вызывает ее. Случаев 2 – 5 описываются возможные строки.  
  
### <a name="case-2---lpszsql--a-table-name"></a>Вариант 2 lpszSQL = имя таблицы  
 Набор записей использует обмен полями записей (RFX) для создания списка имен столбцов, предоставляемых в RFX вызовы функции в класс записей переопределение `DoFieldExchange`. Если мастер используется для объявления класса набора записей, в этом случае будет тот же результат, в случае 1 (при условии, что можно передать то же имя таблицы, которые вы указали в мастере). Если вы не используете мастер для создания класса, вариант 2 — это самый простой способ создания инструкции SQL.  
  
 Следующий пример создает инструкцию SQL, для отбора записей из базы данных приложения MFC. Когда платформа вызывает `GetDefaultSQL` функция-член, функция возвращает имя таблицы, `SECTION`.  
  
```  
CString CEnrollSet::GetDefaultSQL()  
{  
    return "SECTION";  
}  
```  
  
 Для получения имен столбцов для SQL **ВЫБЕРИТЕ** инструкции, платформа вызывает `DoFieldExchange` функция-член.  
  
```  
void CEnrollSet::DoFieldExchange(CFieldExchange* pFX)  
{  
    pFX->SetFieldType(CFieldExchange::outputColumn);  
    RFX_Text(pFX, "CourseID", m_strCourseID);  
    RFX_Text(pFX, "InstructorID", m_strInstructorID);  
    RFX_Text(pFX, "RoomNo", m_strRoomNo);  
    RFX_Text(pFX, "Schedule", m_strSchedule);  
    RFX_Text(pFX, "SectionNo", m_strSectionNo);  
}  
```  
  
 По завершении инструкции SQL выглядит следующим образом:  
  
```  
SELECT CourseID, InstructorID, RoomNo, Schedule, SectionNo   
    FROM SECTION  
```  
  
### <a name="case-3---lpszsql--a-selectfrom-statement"></a>Вариант 3 lpszSQL = SELECT / FROM инструкция  
 Укажите список столбцов вручную вместо того чтобы полагаться на RFX автоматического создания. Вы можете это сделать, если:  
  
-   Вы хотите указать **DISTINCT** ключевое слово после **ВЫБЕРИТЕ**.  
  
     Список столбцов должны соответствовать имена столбцов и типы в том же порядке, как они указаны в `DoFieldExchange`.  
  
-   У вас есть необходимо вручную извлечь значения столбцов с помощью функции ODBC **:: SQLGetData** вместо того чтобы полагаться на RFX для привязки и извлечения столбцов.  
  
     Например, можно разместить новые столбцы, которые пользователь приложения добавлены в таблицы базы данных после распространения приложения. Необходимо добавить эти дополнительные поля элементов данных, которые не были известны во время объявления класса с помощью мастера.  
  
     Список столбцов должны соответствовать имена столбцов и типы в том же порядке, как они указаны в `DoFieldExchange`, а затем по названиям вручную привязанные столбцы. Дополнительные сведения см. в разделе [набор записей: динамическая привязка столбцов данных (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).  
  
-   Вы хотите присоединиться к таблицам, указав несколько таблиц в **FROM** предложение.  
  
     Сведения и пример см. в разделе [набор записей: выполнение Join (ODBC)](../../data/odbc/recordset-performing-a-join-odbc.md).  
  
### <a name="case-4---lpszsql--selectfrom-plus-where-andor-order-by"></a>Вариант 4 lpszSQL = SELECT / с, а также ГДЕ и/или ORDER BY  
 Указывается все: список столбцов (на основе вызовов RFX в `DoFieldExchange`), список таблиц и содержимое **ГДЕ** и/или **ORDER BY** предложение. Если указать ваш **ГДЕ** и/или **ORDER BY** предложений таким образом, не используйте **m_strFilter** и/или `m_strSort`.  
  
### <a name="case-5---lpszsql--a-stored-procedure-call"></a>Вариант 5 lpszSQL = вызов хранимой процедуры  
 Если необходимо вызвать предопределенного запроса (например, хранимая процедура в базе данных Microsoft SQL Server), необходимо написать **вызвать** инструкцией в строке, передаваемой в `lpszSQL`. Мастера не поддерживают объявление класса набора записей для вызова предопределенного запроса. Не все предопределенные запросы возвращают записи.  
  
 Если предопределенного запроса не возвращает записей, вы можете использовать `CDatabase` функция-член `ExecuteSQL` напрямую. Для предопределенных запросов, возвращающих записи, необходимо вручную записать вызовы RFX в `DoFieldExchange` для всех столбцов, процедура возвращает результат. Вызовы функций RFX должна находиться в том же порядке и возвращать те же типы, что предопределенного запроса. Дополнительные сведения см. в разделе [набор записей: объявление класса для предопределенных запросов (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md).  
  
## <a name="see-also"></a>См. также  
 [SQL: SQL и типы данных C++ (ODBC)](../../data/odbc/sql-sql-and-cpp-data-types-odbc.md)   
 [SQL. Выполнение прямых вызовов SQL (ODBC)](../../data/odbc/sql-making-direct-sql-calls-odbc.md)
