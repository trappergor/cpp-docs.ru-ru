---
title: 'Набор записей: Дополнительные сведения об обновлениях (ODBC) | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-data
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- records, updating
- transactions, updating recordsets
- ODBC recordsets, updating
- multiuser environments, updates to recordsets
- scrolling, updates to recordsets
- updating recordsets
- recordsets, updating
ms.assetid: 0353a742-d226-4fe2-8881-a7daeffe86cd
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: 9b781935a43c8ac4626385b5e2ea683f9c481978
ms.sourcegitcommit: 889a75be1232817150be1e0e8d4d7f48f5993af2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2018
ms.locfileid: "39339631"
---
# <a name="recordset-more-about-updates-odbc"></a>Набор записей. Дополнительные сведения об обновлениях (ODBC)
Этот раздел относится к классам ODBC библиотеки MFC.  
  
 Содержание раздела:  
  
-   [Влияние обновления других операций, таких как транзакции,](#_core_how_transactions_affect_updates).  
  
-   [Обновления и других пользователей](#_core_your_updates_and_the_updates_of_other_users).  
  
-   [Дополнительные сведения о функции-члены Update и Delete](#_core_more_about_update_and_delete).  
  
> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset` в какой строке массовой выборка не был реализован. Если вы реализовали выборка строк, некоторые данные не применяется. Например, нельзя вызывать `AddNew`, `Edit`, `Delete`, и `Update` функций-членов; тем не менее, можно выполнять транзакции. Дополнительные сведения о массовой выборке строк см. в разделе [набор записей: получение записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).  
  
##  <a name="_core_how_other_operations_affect_updates"></a> Влияние на другие операции обновления  
 Обновления, подвержены транзакций действует во время обновления, закрыв набор записей до завершения транзакции и прокручивается до завершения транзакции.  
  
###  <a name="_core_how_transactions_affect_updates"></a> Влияние транзакций на обновления  
 Помимо понимания как `AddNew`, `Edit`, и `Delete` работы, важно понять, как `BeginTrans`, `CommitTrans`, и `Rollback` функциями-членами [CDatabase](../../mfc/reference/cdatabase-class.md) работают с функции обновления [CRecordset](../../mfc/reference/crecordset-class.md).  
  
 По умолчанию вызывает `AddNew` и `Edit` влияют на источник данных, немедленно при вызове `Update`. `Delete` вызовы вступают в силу немедленно. Но можно создать транзакцию и выполнить пакет такие вызовы. Обновления не являются постоянными, до их фиксации. Если вы передумаете, выполнить откат транзакции, а его фиксацией.  
  
 Дополнительные сведения о транзакциях см. в разделе [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).  
  
###  <a name="_core_how_closing_the_recordset_affects_updates"></a> Влияние закрытия набора записей на обновление  
 Если вы закроете набор записей или связанный с ним `CDatabase` из объектов, во время выполнения транзакции (не вызывался [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) или [CDatabase::Rollback](../../mfc/reference/cdatabase-class.md#rollback)), откат транзакции обратно автоматически (если серверной части базы данных не базы данных Microsoft Jet).  
  
> [!CAUTION]
>  Если вы используете базы данных Microsoft Jet, закрытии набора записей в явной транзакции не приводит освобождение строк, которые были изменены или блокировок, которые были размещены пока явная транзакция фиксируется или откатывается назад. Рекомендуется, вы всегда как открывающие и закрывающие наборы записей внутри или вне явной транзакции Jet.  
  
###  <a name="_core_how_scrolling_affects_updates"></a> Влияние прокрутки на обновление  
 Когда вы [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) в наборе записей, в буфере заполняется каждая новая текущая запись (предыдущая запись при этом не сохраняется). При прокрутке пропускаются ранее удаленные записи. Если прокрутить после `AddNew` или `Edit` вызов без вызова `Update`, `CommitTrans`, или `Rollback` во-первых, все изменения будут потеряны (предупреждение при этом не отображается) при записи в буфер. В буфере заполняется новая запись, сохраненная запись освобождается и не произойдет никаких изменений в источнике данных. Это относится как `AddNew` и `Edit`.  
  
##  <a name="_core_your_updates_and_the_updates_of_other_users"></a> Обновления и обновления других пользователей  
 При использовании набора записей для обновления данных, изменения влияют на других пользователей. Аналогичным образом обновления других пользователей в течение времени существования набора записей затрагивают именно вас.  
  
 В многопользовательской среде другие пользователи могут открывать наборы записей, которые содержат некоторые из записей, выбранных в набор записей. Изменения в записи до ее извлечения, отражаются в наборе записей. Так как динамических подмножеств данных извлекают записи каждый раз при переходе на нее, динамических подмножеств данных отражают изменения каждый раз при переходе к записи. Моментальные снимки извлечение записи при первом переходе на нее, поэтому моментальные снимки отражены только те изменения, которые произойти, прежде чем перейти к записи, изначально.  
  
 Записи, добавленные другими пользователями после открытия набора записей не отображаются в наборе данных только по отдельному запросу. Если набор записей является динамическим подмножеством данных, изменения существующих записей, другие пользователи будут отображаться динамического набора при прокрутке к измененной записи. Если набор записей является моментальным снимком, изменения не отображаются до requery моментального снимка. Если вы хотите просмотреть записи, добавленные или удаленные другими пользователями в моментальный снимок или записи, добавленные другими пользователями динамического набора, вызовите метод [метод CRecordset::Requery](../../mfc/reference/crecordset-class.md#requery) для перестроения набор записей. (Обратите внимание, что удаления других пользователей будут отображаться динамического набора). Также можно вызвать метод `Requery` для просмотра записей, добавленные, но не см. в разделе удаления.  
  
> [!TIP]
>  Чтобы выполнить принудительное кэширование всего моментального снимка за один раз, вызовите `MoveLast` сразу же после открытия моментального снимка. Затем вызовите `MoveFirst` для начала работы с записями. `MoveLast` эквивалентно прокрутке все записи, но он извлекает все сразу. Обратите внимание, что это может снизить производительность и может не потребоваться для некоторых драйверов.  
  
 Влияние обновления на других пользователей, аналогичны их воздействия на вас.  
  
##  <a name="_core_more_about_update_and_delete"></a> Дополнительные сведения о Update и Delete  
 Этот раздел содержит дополнительные сведения, которые помогают работать с `Update` и `Delete`.  
  
### <a name="update-success-and-failure"></a>Обновление Успех и отказ  
 Если `Update` завершается успешно, `AddNew` или `Edit` режиме заканчивается. Чтобы начать `AddNew` или `Edit` режим, вызов `AddNew` или `Edit`.  
  
 Если `Update` завершается сбоем (возвращает значение FALSE или создает исключение), остаются в `AddNew` или `Edit` режим, в зависимости от того, какая функция вызывается последнего. Затем можно выполнить одно из следующих:  
  
-   Изменить член поля данных и повторите `Update` еще раз.  
  
-   Вызовите `AddNew` сбросить элементами данных полей в значение Null, задайте значения свойств поля элементов данных, а затем вызовите `Update` еще раз.  
  
-   Вызовите `Edit` перезагрузить значений, сохраненных в наборе записей до первого вызова `AddNew` или `Edit`, задайте значения свойств поля элементов данных, а затем вызовите `Update` еще раз. После успешной `Update` вызова (Кроме запуска после `AddNew` вызова), элементами данных полей сохраняются новые значения.  
  
-   Вызовите `Move` (включая `Move` с параметром AFX_MOVE_REFRESH или 0), который очищает любые изменения и завершает `AddNew` или `Edit` действующий режим.  
  
### <a name="update-and-delete"></a>Update и Delete  
 Этот раздел относится к обоим `Update` и `Delete`.  
  
 На `Update` или `Delete` операции, должны обновляться только одна запись. Этой записи является текущей записи, соответствующее значениям данных в полях набора записей. Если для какой-либо причине записи не изменяются или несколько записей, создается исключение с одним из следующих **RETCODE** значения:  
  
-   AFX_SQL_ERROR_NO_ROWS_AFFECTED  
  
-   AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED  
  
 При возникновении этих исключений, позволяя держать `AddNew` или `Edit` состояние, при вызове `Update` или `Delete`. Ниже приведены наиболее распространенные сценарии, в которых будет видеть эти исключения. Вы скорее всего, см. в разделе:  
  
-   AFX_SQL_ERROR_NO_ROWS_AFFECTED при использовании режима оптимистичной блокировки и другой пользователь изменил запись таким образом, предотвращает платформы идентификации запись update или delete.  
  
-   AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED при обновлении таблицы не имеет первичного ключа или уникального индекса, а не содержит достаточного количества столбцов в наборе записей для уникальной идентификации строки таблицы.  
  
## <a name="see-also"></a>См. также  
 [Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)   
 [Набор записей: Порядок выборки записей (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)   
 [Обмен полями записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)   
 [SQL](../../data/odbc/sql.md)   
 [Исключения. Исключения баз данных](../../mfc/exceptions-database-exceptions.md)