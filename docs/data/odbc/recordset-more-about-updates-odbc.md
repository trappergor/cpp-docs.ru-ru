---
title: Набор записей. Дополнительные сведения об обновлениях (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records, updating
- transactions, updating recordsets
- ODBC recordsets, updating
- multiuser environments, updates to recordsets
- scrolling, updates to recordsets
- updating recordsets
- recordsets, updating
ms.assetid: 0353a742-d226-4fe2-8881-a7daeffe86cd
ms.openlocfilehash: f11c723e4589cb28a3f38100050a69a78fc0809e
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80212853"
---
# <a name="recordset-more-about-updates-odbc"></a>Набор записей. Дополнительные сведения об обновлениях (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

В этом разделе рассматриваются следующие вопросы.

- [Влияние других операций, таких как транзакции, на обновления](#_core_how_transactions_affect_updates).

- [Ваши обновления и другие пользователи](#_core_your_updates_and_the_updates_of_other_users).

- [Дополнительные сведения о функциях элементов Update и DELETE](#_core_more_about_update_and_delete).

> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset`, в которых пакетное получение строк не реализовано. При реализации групповой выборки строк некоторые сведения не применяются. Например, нельзя вызывать функции члена `AddNew`, `Edit`, `Delete`и `Update`. Тем не менее можно выполнять транзакции. Дополнительные сведения о групповой выборке строк см. [в разделе набор записей. сбор записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

##  <a name="how-other-operations-affect-updates"></a><a name="_core_how_other_operations_affect_updates"></a>Влияние других операций на обновления

На обновления влияют транзакции, действующие во время обновления, закрывая набор записей перед завершением транзакции и прокруткой перед завершением транзакции.

###  <a name="how-transactions-affect-updates"></a><a name="_core_how_transactions_affect_updates"></a>Влияние транзакций на обновления

Помимо понимания того, как работают `AddNew`, `Edit`и `Delete`, важно понимать, как функции-члены `BeginTrans`, `CommitTrans`и [`Rollback` работают с](../../mfc/reference/cdatabase-class.md) функциями Update класса [CRecordset](../../mfc/reference/crecordset-class.md).

По умолчанию вызовы `AddNew` и `Edit` немедленно влияют на источник данных при вызове `Update`. `Delete` вызовы вступают в силу немедленно. Но можно создать транзакцию и выполнить пакет таких вызовов. Обновления не являются постоянными, пока вы не зафиксируете их. Если вы передумали, то можете откатить транзакцию, а не фиксировать ее.

Дополнительные сведения о транзакциях см. в разделе [Transaction (ODBC)](../../data/odbc/transaction-odbc.md).

###  <a name="how-closing-the-recordset-affects-updates"></a><a name="_core_how_closing_the_recordset_affects_updates"></a>Влияние закрытия набора записей на обновления

Если закрывается набор записей или связанный с ним `CDatabase` объект с выполняющейся транзакцией (не был вызван метод [CDatabase:: CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) или [CDatabase:: ROLLBACK](../../mfc/reference/cdatabase-class.md#rollback)), то транзакция откатывается автоматически (если серверная часть базы данных не является ядром СУБД Microsoft Jet).

> [!CAUTION]
>  Если используется ядро СУБД Microsoft Jet, закрытие набора записей внутри явной транзакции не приводит к освобождению каких-либо измененных строк или блокировок, которые были помещены до фиксации или отката явной транзакции. Рекомендуется всегда открывать и закрывать наборы записей внутри или за пределами явной транзакции Jet.

###  <a name="how-scrolling-affects-updates"></a><a name="_core_how_scrolling_affects_updates"></a>Влияние прокрутки на обновления

При [наборе записей с прокруткой (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) в наборе записей буфер редактирования заполняется каждой новой текущей записью (Предыдущая запись не сохраняется первой). Прокрутка пропускает ранее удаленные записи. При прокрутке после `AddNew` или `Edit` вызове без вызова `Update`, `CommitTrans`или `Rollback`, все изменения теряются (без предупреждения), так как новая запись помещается в буфер редактирования. Буфер редактирования заполняется записью, а хранимая запись освобождается, и в источнике данных не происходит никаких изменений. Это относится как к `AddNew`, так и к `Edit`.

##  <a name="your-updates-and-the-updates-of-other-users"></a><a name="_core_your_updates_and_the_updates_of_other_users"></a>Обновления и обновления других пользователей

При использовании набора записей для обновления данных обновления влияют на других пользователей. Аналогичным образом обновления других пользователей в течение времени существования набора записей повлияют на вас.

В многопользовательской среде другие пользователи могут открывать наборы записей, содержащие некоторые из тех записей, которые были выбраны в наборе записей. Изменения записи перед ее извлечением отражаются в наборе записей. Так как динамические подмножества данных извлекают запись при каждой прокрутке, динамические подмножества отображают изменения при каждой прокрутке до записи. Моментальные снимки извлекают запись при первой прокрутке до нее, поэтому моментальные снимки отображают только те изменения, которые происходят до первоначальной прокрутки к записи.

Записи, добавленные другими пользователями после открытия набора записей, не отображаются в наборе записей, если не выполняется запрос. Если набор записей является динамическим, изменения, внесенные другими пользователями, будут отображаться в динамическом виде при прокрутке к затронутой записи. Если набор записей является моментальным снимком, изменения не отображаются до тех пор, пока не будет выполнен запрос моментального снимка. Если вы хотите просмотреть записи, добавленные или удаленные другими пользователями в вашем моментальном снимке, или записи, добавленные другими пользователями в динамическом наборе, вызовите метод [CRecordset:: Requery](../../mfc/reference/crecordset-class.md#requery) для перестроения набора записей. (Обратите внимание, что в динамическом наборе отображаются удаления других пользователей.) Вы также можете вызвать `Requery`, чтобы просмотреть записи, которые вы добавили, но не можете видеть их удаления.

> [!TIP]
>  Чтобы принудительно выполнить кэширование всего моментального снимка одновременно, вызовите `MoveLast` сразу после открытия моментального снимка. Затем вызовите `MoveFirst`, чтобы начать работу с записями. `MoveLast` эквивалентен прокрутке всех записей, но все они извлекаются сразу. Однако обратите внимание, что это может снизить производительность и может не требоваться для некоторых драйверов.

Влияние обновлений на других пользователей аналогично их влиянию на вас.

##  <a name="more-about-update-and-delete"></a><a name="_core_more_about_update_and_delete"></a>Дополнительные сведения об обновлении и удалении

В этом разделе содержатся дополнительные сведения, помогающие работать с `Update` и `Delete`.

### <a name="update-success-and-failure"></a>Успешное завершение и сбой обновления

Если `Update` завершается, `AddNew` или режим `Edit` заканчивается. Чтобы снова начать `AddNew` или режим `Edit`, вызовите метод `AddNew` или `Edit`.

Если `Update` завершается ошибкой (Возвращает значение FALSE или вызывает исключение), то остается в режиме `AddNew` или `Edit` в зависимости от того, какая функция была вызвана последней. При этом можно предпринять одно из следующих действий:

- Измените элемент данных поля и повторите `Update`.

- Вызовите `AddNew`, чтобы сбросить элементы данных поля до значения NULL, задать значения элементов данных поля, а затем вызвать метод `Update` еще раз.

- Вызовите `Edit` для повторной загрузки значений, которые были в наборе записей перед первым вызовом `AddNew` или `Edit`, задайте значения элементов данных поля, а затем снова вызовите `Update`. После успешного вызова `Update` (за исключением вызова `AddNew`) элементы данных поля сохраняют свои новые значения.

- Вызовите `Move` (в том числе `Move` с параметром AFX_MOVE_REFRESH или 0), в результате чего все изменения сбрасываются и завершается любой `AddNew` или режим `Edit`.

### <a name="update-and-delete"></a>Обновление и удаление

Этот раздел относится как к `Update`, так и к `Delete`.

При выполнении операции `Update` или `Delete` необходимо обновить одну и только одну запись. Эта запись является текущей записью, которая соответствует значениям данных в полях набора записей. Если по какой-либо причине не затрагивается ни одна запись или не затрагивается несколько записей, создается исключение, содержащее одно из следующих значений **реткоде** :

- AFX_SQL_ERROR_NO_ROWS_AFFECTED

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED

При возникновении этих исключений вы остается в `AddNew` или `Edit`ном состоянии при вызове `Update` или `Delete`. Ниже приведены наиболее распространенные сценарии, в которых можно увидеть эти исключения. Скорее всего, вы увидите следующее:

- AFX_SQL_ERROR_NO_ROWS_AFFECTED, когда используется режим оптимистической блокировки и другой пользователь изменил запись таким образом, чтобы платформа не определила правильную запись для обновления или удаления.

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED, когда обновляемая таблица не имеет первичного ключа или уникального индекса и в наборе записей недостаточно столбцов для уникальной идентификации строки таблицы.

## <a name="see-also"></a>См. также раздел

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Порядок выборки записей в наборе (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)<br/>
[Обмен данными полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)<br/>
[SQL](../../data/odbc/sql.md)<br/>
[Исключения. Исключения баз данных](../../mfc/exceptions-database-exceptions.md)
