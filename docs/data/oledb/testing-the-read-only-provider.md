---
title: Проверка поставщика только для чтения | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-data
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- testing, OLE DB providers
- testing providers
- OLE DB providers, calling
- OLE DB providers, testing
ms.assetid: e4aa30c1-391b-41f8-ac73-5270e46fd712
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- data-storage
ms.openlocfilehash: 4630391d9bce319c35af18767d7133bd34a92362
ms.sourcegitcommit: c045c3a7e9f2c7e3e0de5b7f9513e41d8b6d19b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2018
ms.locfileid: "49990208"
---
# <a name="testing-the-read-only-provider"></a>Проверка поставщика в режиме "только для чтения"

Для проверки поставщика требуется объект-получатель. Это полезно, если потребитель может совпадать с поставщиком. Шаблоны потребителей OLE DB являются оболочками для OLE DB и соответствуют поставщику COM-объектов. Так как источник поставляется с шаблонами объекта-получателя, это можно легко выполнять отладку поставщика с ними. Шаблоны потребителей также являются простой и быстрый способ разработки приложения-потребители.  
  
В примере в этом разделе создается приложение по умолчанию мастер приложений MFC для проверки объекта-получателя. Тестовое приложение представляет собой простой диалог с добавленным кодом шаблона потребителя OLE DB.  
  
## <a name="to-create-the-test-application"></a>Создание тестового приложения  
  
1. В меню **Файл** последовательно выберите пункты **Создать**и **Проект**.  
  
1. В **типы проектов** области выберите **проекты Visual C++** папки. В **шаблоны** области выберите **приложения MFC**.  
  
1. Имя проекта, введите *TestProv*, а затем нажмите кнопку **ОК**.  
  
     Появится мастер приложений MFC.  
  
1. На **тип приложения** выберите **на основе диалоговых окон**.  
  
1. На **дополнительные функции** выберите **автоматизации**, а затем нажмите кнопку **Готово**.  
  
> [!NOTE]
> При добавлении приложения не требуется поддержка модели автоматизации `CoInitialize` в `CTestProvApp::InitInstance`.  
  
Можно просматривать и изменять **TestProv** диалоговое окно (IDD_TESTPROV_DIALOG), выбрав ее в **представление ресурсов**. Поместите два окна списка, по одному для каждой строки в наборе строк, в диалоговом окне. Отключить свойство sort для обоих списках, нажав клавишу **Alt**+**ввод** при выборе поле со списком, щелкнув **стили** вкладку и очистке  **Сортировка** "флажок". Кроме того, поместите **запуска** кнопку в диалоговом окне для выбора файла. Готовый **TestProv** диалоговое окно должно быть два окна с меткой «Строка 1» и «строка 2", того, он также имеет **ОК**, **отменить**, и **запуска**  кнопки.  
  
Откройте файл заголовка для класса диалогового окна (в случае этого, файл TestProvDlg.h). Добавьте следующий код в файл заголовка (вне объявлений классов):  
  
```cpp
////////////////////////////////////////////////////////////////////////  
// TestProvDlg.h  
  
class CProvider   
{  
// Attributes  
public:  
   char   szField1[16];  
   char   szField2[16];  
  
   // Binding Maps  
BEGIN_COLUMN_MAP(CProvider)  
   COLUMN_ENTRY(1, szField1)  
   COLUMN_ENTRY(2, szField2)  
END_COLUMN_MAP()  
};  
```  
  
Код представляет запись пользователя, который определяет, какие столбцы будут в наборе строк. Когда клиент вызывает `IAccessor::CreateAccessor`, эти записи используются для определения столбцов для привязки. Шаблоны потребителей OLE DB также позволяют динамическая привязка столбцов. COLUMN_ENTRY они версию PROVIDER_COLUMN_ENTRY в клиентские. Два макроса COLUMN_ENTRY указать порядковый номер, тип, длина и элемент данных для двух строк.  
  
Добавьте функцию обработчика событий для **запуска** кнопку, нажав клавишу **Ctrl** и дважды щелкнув **запуска** кнопки. Поместите следующий код в функцию:  
  
```cpp
///////////////////////////////////////////////////////////////////////  
// TestProvDlg.cpp  
  
void CtestProvDlg::OnRun()  
{  
   CCommand<CAccessor<CProvider>> table;  
   CDataSource source;  
   CSession   session;  
  
   if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
      return;  
  
   if (session.Open(source) != S_OK)  
      return;  
  
   if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
      return;  
  
   while (table.MoveNext() == S_OK)  
   {  
      m_ctlString1.AddString(table.szField1);  
      m_ctlString2.AddString(table.szField2);  
   }  
}  
```  
  
`CCommand`, `CDataSource`, И `CSession` классы, которые принадлежат к числу Шаблоны потребителей OLE DB. Каждый класс имитирует COM-объект в поставщике. `CCommand` Объекта принимает `CProvider` класс, объявленный в файле заголовка, в качестве параметра шаблона. `CProvider` Представляет параметр привязки, которые используются для доступа к данным от поставщика. Вот `Open` код для источника данных, сеанса и команды:  
  
```cpp  
if (source.Open("MyProvider.MyProvider.1", NULL) != S_OK)  
   return;  
  
if (session.Open(source) != S_OK)  
   return;  
  
if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)  
   return;  
```  
  
Строки для открытия каждого класса создайте каждого COM-объект в поставщике. Чтобы найти поставщика, используйте `ProgID` поставщика. Вы можете получить `ProgID` из системного реестра, либо в файле MyProvider.rgs (откройте каталог поставщика и выполните поиск `ProgID` ключ).  
  
Файл MyData.txt входит в состав `MyProv` образца. Для создания собственного файла, используйте редактор и введите четное число строк, нажав клавишу ВВОД после каждой строки. Измените имя пути, при перемещении файла.  
  
Передайте строку «c:\\\samples\\\myprov\\\MyData.txt» в `table.Open` строки. При выполнении шага с заходом `Open` вызова, появится эта строка передается `SetCommandText` метод в поставщике. Обратите внимание, что `ICommandText::Execute` метод, используемый этой строки.  
  
Чтобы извлечь данные, вызовите `MoveNext` для таблицы. `MoveNext` вызовы `IRowset::GetNextRows`, `GetRowCount`, и `GetData` функции. При наличии больше нет строк (то есть текущей позиции в наборе строк больше, чем `GetRowCount`), цикл завершается:  
  
```cpp  
while (table.MoveNext() == S_OK)  
{  
   m_ctlString1.AddString(table.szField1);  
   m_ctlString2.AddString(table.szField2);  
}  
```  
  
Обратите внимание, что если больше нет строк, поставщики, возвращают DB_S_ENDOFROWSET. Значение DB_S_ENDOFROWSET не ошибка. Всегда следует проверять значение S_OK для отмены цикла выборки и не использовать макрос SUCCEEDED.  
  
Теперь можно создавать и тестировать программу.  
  
## <a name="see-also"></a>См. также  

[Усовершенствование простого поставщика только для чтения](../../data/oledb/enhancing-the-simple-read-only-provider.md)