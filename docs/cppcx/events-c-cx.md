---
title: События (C + +/ CX) | Документация Майкрософт
ms.custom: ''
ms.date: 01/22/2017
ms.technology: cpp-windows
ms.topic: language-reference
ms.assetid: 31c8e08a-00ad-40f9-8f7e-124864aaad58
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 8465572cf5b921f56e357ae554ecdeaf9943b725
ms.sourcegitcommit: 92dbc4b9bf82fda96da80846c9cfcdba524035af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/05/2018
ms.locfileid: "43767582"
---
# <a name="events-ccx"></a>События (C++/CX)
Среду выполнения Windows, можно объявить тип (которая публиковать) события, а код клиента, в том же компоненте или в других компонентах может подписываться на эти события, связывая методы, вызываемые *обработчики событий* с событием. С одним событием можно связать несколько обработчиков событий. Когда публикующий объект создает событие, это вызывает срабатывание все обработчиков событий. Таким образом, подписывающийся класс может выполнять любые действия, зависящие от конкретной ситуации, когда публикующий объект создает событие. Событие имеет тип делегата, определяющего сигнатуру, которую должны иметь все обработчики событий, чтобы подписаться на данное событие.  
  
## <a name="consuming-events-in-windows-components"></a>Использование событий в компонентах Windows  
 Многие компоненты в среде выполнения Windows предоставляют события. Например, объект LightSensor инициирует событие ReadingChanged, когда изменяются показания датчика освещенности. При использовании в программе объекта LightSensor можно определить метод, который будет вызываться при возникновении события ReadingChanged. Этот метод может выполнять любые необходимые для выполнения; Единственное требование заключается в том, что его сигнатура должна соответствовать сигнатуре делегата, Дополнительные сведения о способах создания делегата обработчика события и подписаться на событие, см. в разделе [делегаты](../cppcx/delegates-c-cx.md).  
  
## <a name="creating-custom-events"></a>Создание пользовательских событий  
  
### <a name="declaration"></a>Объявление  
 Событие можно объявить в классе ссылки или интерфейсе, задав для него режим доступа public, internal (public/private), public protected, protected, private protected или private accessibility. При объявлении события компилятор автоматически создает объект, имеющий два метода доступа: add и remove. Когда подписывающиеся объекты регистрируют обработчики событий, объект события сохраняет их в коллекции. Когда происходит событие, объект события по очереди вызывает все обработчики в списке. Тривиальное событие (такое как в следующем примере) имеет неявно заданное резервное хранилище, а также неявно заданные методы доступа `add` и `remove` . Разработчик также может определять собственные методы доступа, аналогично тому как задаются пользовательские методы доступа `get` и `set` в случае свойств.  Реализующий класс не может "вручную" перебирать список подписчиков на событие при возникновении тривиального события.  
  
 В следующем примере показан способ объявления и инициации события. Обратите внимание, что событие имеет тип делегата и объявлено с помощью символа "^".  
  
 [!code-cpp[cx_events#01](../cppcx/codesnippet/CPP/cx_events/class1.h#01)]  
  
### <a name="usage"></a>Использование  
 В следующем примере показано, как подписывающийся класс с помощью оператора `+=` подписывается на событие и предоставляет обработчик событий, вызываемый при возникновении этого события. Обратите внимание, что указанная функция соответствует сигнатуре делегата, который определен на стороне издателя в пространстве имен `EventTest` .  
  
 [!code-cpp[cx_events#02](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#02)]  
  
> [!WARNING]
>  Как правило, для обработчика событий лучше использовать именованную функцию, а не лямбда-выражение, чтобы не пришлось внимательно следить за возникновением циклических ссылок. Именованная функция перехватывает указатель this с помощью слабой ссылки, в то время как лямбда-выражение перехватывает его с помощью строгой ссылки и создает циклическую ссылку. Дополнительные сведения см. в разделе [Слабые ссылки и разрыв циклов (C++/CX)](../cppcx/weak-references-and-breaking-cycles-c-cx.md).  
  
### <a name="custom-add-and-remove-methods"></a>Пользовательские методы добавления и удаления  
 Изнутри у события имеются методы add(), remove() и raise(). Когда клиентский код подписывается на событие, вызывается метод add() и переданный делегат добавляется в список вызова события. Класс публикации вызывает событие, оно вызывает метод raise() и по очереди вызываются все делегаты в списке. Подписчик может удалить себя из списка делегата, в результате чего будет вызван метод remove() события. Компилятор предоставляет версии этих методов по умолчанию, если разработчик не определил их в своем коде; эти события называются тривиальными. Во многих случаях тривиальных событий бывает достаточно.  
  
 Для события можно определить пользовательские методы добавления, удаления и инициации, если требуется реализовать пользовательскую логику, выполняемую при добавлении или удалении подписчиков. Например, если имеется ресурсоемкий объект, который требуется только для уведомления о событиях, можно отложить его создание до момента, когда клиент подпишется на событие.  
  
 В следующем примере показано, как добавить пользовательские методы добавления, удаления и инициации для события.  
  
 [!code-cpp[cx_events#03](../cppcx/codesnippet/CPP/cx_events/class1.h#03)]  
  
## <a name="removing-an-event-handler-from-the-subscriber-side"></a>Удаление обработчика событий со стороны подписчика  
 В некоторых редких случаях может потребоваться удалить обработчик событий для события, на которое вы подписались ранее. Например, может потребоваться заменить его другим обработчиком событий или удалить некоторые удерживаемые им ресурсы. Чтобы удалить обработчик, необходим сохраненный токен EventRegistrationToken, возвращаемый операцией `+=` . Можно использовать оператор `-=` с этим токеном для удаления обработчика событий.  Однако исходный обработчик может по-прежнему вызываться даже после его удаления. Поэтому если планируется удалить обработчик событий, создайте флаг, установите его в случае, если событие удалено, а в обработчике событий задайте проверку наличия флага и немедленный возврат, если флаг установлен. В следующем примере демонстрируется использование основного шаблона.  
  
 [!code-cpp[cx_events#04](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#04)]  
  
### <a name="remarks"></a>Примечания  
 С одним событием может быть связано несколько обработчиков. Источник события поочередно вызывает все обработчики событий из одного потока. Если приемник события выполняет блокировку в методе обработчика событий, он не позволяет источнику события вызывать другие обработчики для этого события.  
  
 Порядок, в котором источник события вызывает обработчики событий в приемниках события не является предопределенным и может отличаться от вызова к вызову.  
  
## <a name="see-also"></a>См. также  
 [Система типов](../cppcx/type-system-c-cx.md)   
 [Делегаты](../cppcx/delegates-c-cx.md)   
 [Справочник по языку Visual C++](../cppcx/visual-c-language-reference-c-cx.md)   
 [Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)