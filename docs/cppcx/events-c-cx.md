---
title: События (C++/CX)
description: Как использовать C++/CX для создания и использования обработчиков событий в среда выполнения Windows.
ms.date: 02/03/2020
ms.assetid: 31c8e08a-00ad-40f9-8f7e-124864aaad58
ms.openlocfilehash: 45f9a7bc17d9a695613ce551dae796b2cd2e0e6f
ms.sourcegitcommit: ba4180a2d79d7e391f2f705797505d4aedbc2a5e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2020
ms.locfileid: "76972202"
---
# <a name="events-ccx"></a>События (C++/CX)

Тип среда выполнения Windows может объявлять (то есть публиковать) события, а клиентский код в том же компоненте или в других компонентах может подписываться на эти события, связав методы, называемые *обработчиками событий* , с событием. С одним событием можно связать несколько обработчиков событий. Когда публикующий объект создает событие, это вызывает срабатывание все обработчиков событий. Таким образом, подписывающийся класс может выполнять любые действия, зависящие от конкретной ситуации, когда публикующий объект создает событие. Событие имеет тип делегата, определяющего сигнатуру, которую должны иметь все обработчики событий, чтобы подписаться на данное событие.

## <a name="consuming-events-in-windows-components"></a>Использование событий в компонентах Windows

Многие компоненты в среда выполнения Windows предоставляют события. Например, объект LightSensor инициирует событие ReadingChanged, когда изменяются показания датчика освещенности. При использовании в программе объекта LightSensor можно определить метод, который будет вызываться при возникновении события ReadingChanged. Метод может выполнять любые действия, которые вы хотите сделать. Единственное требование заключается в том, что его сигнатура должна соответствовать сигнатуре вызываемого делегата. Дополнительные сведения о создании обработчика событий делегата и оформлении подписки на событие см. в разделе [делегаты](../cppcx/delegates-c-cx.md).

## <a name="creating-custom-events"></a>Создание пользовательских событий

### <a name="declaration"></a>Декларация

Событие можно объявить в классе ссылки или интерфейсе, задав для него режим доступа public, internal (public/private), public protected, protected, private protected или private accessibility. При объявлении события компилятор автоматически создает объект, имеющий два метода доступа: add и remove. Когда подписывающиеся объекты регистрируют обработчики событий, объект события сохраняет их в коллекции. Когда происходит событие, объект события по очереди вызывает все обработчики в списке. Тривиальное событие (такое как в следующем примере) имеет неявно заданное резервное хранилище, а также неявно заданные методы доступа `add` и `remove` . Разработчик также может определять собственные методы доступа, аналогично тому как задаются пользовательские методы доступа `get` и `set` в случае свойств.  Реализующий класс не может "вручную" перебирать список подписчиков на событие при возникновении тривиального события.

В следующем примере показан способ объявления и инициации события. Обратите внимание, что событие имеет тип делегата и объявлено с помощью символа "^".

[!code-cpp[cx_events#01](../cppcx/codesnippet/CPP/cx_events/class1.h#01)]

### <a name="usage"></a>Метрики

В следующем примере показано, как подписывающийся класс с помощью оператора `+=` подписывается на событие и предоставляет обработчик событий, вызываемый при возникновении этого события. Обратите внимание, что указанная функция соответствует сигнатуре делегата, который определен на стороне издателя в пространстве имен `EventTest` .

[!code-cpp[cx_events#02](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#02)]

> [!WARNING]
> Как правило, для обработчика событий лучше использовать именованную функцию, а не лямбда-выражение, чтобы не пришлось внимательно следить за возникновением циклических ссылок. Именованная функция перехватывает указатель this с помощью слабой ссылки, в то время как лямбда-выражение перехватывает его с помощью строгой ссылки и создает циклическую ссылку. Дополнительные сведения см. в разделе [Слабые ссылки и разрыв циклов (C++/CX)](../cppcx/weak-references-and-breaking-cycles-c-cx.md).

### <a name="custom-add-and-remove-methods"></a>Пользовательские методы добавления и удаления

Изнутри у события имеются методы add(), remove() и raise(). Когда клиентский код подписывается на событие, вызывается метод add() и переданный делегат добавляется в список вызова события. Класс публикации вызывает событие, оно вызывает метод raise() и по очереди вызываются все делегаты в списке. Подписчик может удалить себя из списка делегата, в результате чего будет вызван метод remove() события. Компилятор предоставляет версии этих методов по умолчанию, если разработчик не определил их в своем коде; эти события называются тривиальными. Во многих случаях тривиальных событий бывает достаточно.

Для события можно определить пользовательские методы добавления, удаления и инициации, если требуется реализовать пользовательскую логику, выполняемую при добавлении или удалении подписчиков. Например, если имеется ресурсоемкий объект, который требуется только для уведомления о событиях, можно отложить его создание до момента, когда клиент подпишется на событие.

В следующем примере показано, как добавить пользовательские методы добавления, удаления и инициации для события.

[!code-cpp[cx_events#03](../cppcx/codesnippet/CPP/cx_events/class1.h#03)]

## <a name="removing-an-event-handler-from-the-subscriber-side"></a>Удаление обработчика событий со стороны подписчика

В некоторых редких случаях может потребоваться удалить обработчик событий для события, на которое вы подписались ранее. Например, может потребоваться заменить его другим обработчиком событий или удалить некоторые удерживаемые им ресурсы. Чтобы удалить обработчик, необходим сохраненный токен EventRegistrationToken, возвращаемый операцией `+=` . Можно использовать оператор `-=` с этим токеном для удаления обработчика событий.  Однако исходный обработчик может по-прежнему вызываться даже после его удаления. Например, состояние гонки может возникнуть, когда источник события получает список обработчиков и начинает их вызывать. Если обработчик событий удаляется в этом случае, список становится устаревшим. Таким образом, если планируется удалить обработчик событий, создайте флаг члена. Задайте его, если событие удаляется, а затем в обработчике событий проверьте флаг и немедленно возвратите значение, если оно задано. В следующем примере демонстрируется использование основного шаблона.

[!code-cpp[cx_events#04](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#04)]

### <a name="remarks"></a>Заметки

С одним событием может быть связано несколько обработчиков. Источник события поочередно вызывает все обработчики событий из одного потока. Если приемник события выполняет блокировку в методе обработчика событий, он не позволяет источнику события вызывать другие обработчики для этого события.

Порядок, в котором источник события вызывает обработчики событий в приемниках события не является предопределенным и может отличаться от вызова к вызову.

## <a name="see-also"></a>См. также:

[Система типов](../cppcx/type-system-c-cx.md)<br/>
[Делегаты](../cppcx/delegates-c-cx.md)<br/>
[Справочник по языку C++/CX](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)
