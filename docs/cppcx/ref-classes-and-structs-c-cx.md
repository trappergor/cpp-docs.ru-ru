---
title: "Классы и структуры ссылки (C + +/ CX) | Документы Microsoft"
ms.custom: 
ms.date: 01/22/2017
ms.technology: cpp-windows
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 3d736b82-0bf0-48cf-bac1-cc9d110b70d1
caps.latest.revision: "42"
author: ghogen
ms.author: ghogen
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 405f1890dc99e5a20102b7602ac83534cb5ded8f
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="ref-classes-and-structs-ccx"></a>Классы и структуры ссылки (C++/CX)
C + +/ CX поддерживает определяемые пользователем *классы* и *структуры ссылок*и пользовательские *значение классы* и *значение структуры*. Эти структуры данных являются основными контейнерами, в которых C + +/ CX поддерживает систему типов среды выполнения Windows. Их содержимое передается в метаданные в соответствии с определенными правилами, что позволяет передавать их между компонентами среды выполнения Windows и приложений универсальной платформы Windows, написанных на C++ и других языках их.  
  
 Класс ссылки и структура ссылки имеют следующие основные особенности:  
  
-   они должны объявляться в пространстве имен, в области пространства имен, и в этом пространстве имен они могут иметь режим доступа public (открытый) или private (закрытый). Только открытые типы формируют метаданные; Определения вложенных открытых классов не допускаются, в том числе определения вложенных открытых классов [enum](../cppcx/enums-c-cx.md) . Дополнительные сведения см. в разделе [пространства имен и видимость типов](../cppcx/namespaces-and-type-visibility-c-cx.md).  
  
-   Он может содержать в качестве членов C + +/ CX, включая классы ссылок, классы значений, структуры ссылок, структуры значений или допускающие значение NULL. Он также может содержать скалярные типы, такие как float64, bool и т. д. Он также может содержать стандартные типы C++, например `std::vector` , или пользовательский класс при условии, что они не являются открытыми. C + +/ CX конструкции может иметь `public`, `protected`, `internal`, `private`, или `protected private` специальных возможностей. Все члены `public` или `protected` передаются в метаданные. Стандартные типы C++ должны иметь доступность `private`, `internal`или `protected private` , что не позволит им быть переданным в метаданные.  
  
-   они могут реализовывать один или несколько *классов интерфейсов* или *структур интерфейсов*;  
  
-   они могут наследовать одному базовому классу, а на сами базовые классы налагаются дополнительные ограничения. Наследование в иерархиях открытых классов ссылок имеет больше ограничений, чем наследование закрытых классов ссылок;  
  
-   они не могут объявляться как универсальные. Если они имеют закрытый доступ, они могут быть шаблонами;  
  
-   Их время жизни управляется автоматическим подсчетом ссылок.  
  
## <a name="declaration"></a>Объявление  
 В следующем фрагменте кода объявляется класс ссылки `Person` . Обратите внимание, что standard C++ `std::map` тип используется в закрытых членов и среды выполнения Windows`IMapView` в открытом интерфейсе используется интерфейс. Также обратите внимание, что в конце объявлений ссылочных типов используется оператор "^".  
  
 [!code-cpp[cx_classes#03](../cppcx/codesnippet/CPP/classesstructs/class1.h#03)]  
  
## <a name="implementation"></a>Реализация  
 В этом примере кода демонстрируется реализация класса ссылки `Person` .  
  
 [!code-cpp[cx_classes#04](../cppcx/codesnippet/CPP/classesstructs/class1.cpp#04)]  
  
## <a name="usage"></a>Использование  
 В следующем примере кода показано, как клиентский код использует класс ссылки `Person` .  
  
 [!code-cpp[cx_classes#05](../cppcx/codesnippet/CPP/classesstructs/class1.cpp#05)]  
  
 Также можно также объявить локальную переменную класса ссылки с помощью семантики стека. Поведение такого объекта аналогично поведению стековой переменной, несмотря на то что память все же выделяется динамически. Важное отличие заключается в том, что нельзя присвоить отслеживаемую ссылку (%) переменной, объявленной с использованием семантики стека: таким образом гарантируется, что счетчик ссылок уменьшается до нуля, когда выполняется выход из функции. В этом примере показаны базовый класс ссылки `Uri`и функция, в которой он используется с семантикой стека:  
  
 [!code-cpp[cx_classes#06](../cppcx/codesnippet/CPP/classesstructs/class1.cpp#06)]  
  
## <a name="memory-management"></a>Управление памятью  
 Класс ссылки размещается в динамической памяти с помощью ключевого слова `ref new` .  
  
 [!code-cpp[cx_classes#01](../cppcx/codesnippet/CPP/classesstructs/class1.h#01)]  
  
 Оператор дескриптора объекта ^ (называемый "крышкой") по сути является интеллектуальным указателем C++. Память, на которую он указывает, автоматически освобождается, когда последний дескриптор оказывается вне области или ему явно задается значение `nullptr`.  
  
 По определению класс ссылки имеет семантику ссылки. Когда вы присваиваете значение переменной класса ссылки, копируется не сам объект, а его дескриптор. В следующем примере после операции присваивания оба объекта `myClass` и `myClass2` указывают на одно и то же расположение в памяти.  
  
 [!code-cpp[cx_classes#02](../cppcx/codesnippet/CPP/classesstructs/class1.h#02)]  
  
 Когда создается экземпляр класса ссылки C++/CX, его память перед вызовом конструктора инициализируется нулями, поэтому такая инициализация для отдельных членов, включая свойства, не требуется. Если класс C++/CX является производным от класса библиотеки C++ для среды выполнения Windows (WRL), инициализация нулями осуществляется только для области производного класса C++/CX.  
  
### <a name="members"></a>Участники  
 Класс ссылки может содержать функции-члены `public`, `protected`и `private` ; только члены `public` и `protected` передаются в метаданные. Вложенные классы и классы ссылок разрешены, однако они не могут быть `public`. Открытые поля не допускаются; открытые члены данных должны объявляться как свойства. Закрытые и защищенные внутренние данные-члены могут быть полями. По умолчанию в классе ссылки доступность всех членов равна `private`.  
  
 Структура ссылки аналогична классу ссылки за тем исключением, что ее члены по умолчанию имеют доступность `public` .  
  
 Объект `public` ссылочного класса или структуры ссылки передается в метаданные, но для использования из других приложений универсальной платформы Windows и компоненты среды выполнения Windows должен иметь по крайней мере один открытый или защищенный конструктор. Класс ссылки, являющийся открытым и имеющий открытый конструктор, необходимо также объявлять как `sealed` , чтобы предотвратить его дальнейшее изменение через двоичный интерфейс приложений (ABI).  
  
 Открытые члены не могут объявляться как константное выражение, потому что система типов среды выполнения Windows не поддерживает const. Можно использовать статическое свойство для объявления открытого члена данных с постоянным значением.  
  
 При определении открытого класса или структуры ссылок компилятор применяет необходимые атрибуты к классу и сохраняет эти сведения в файле WinMD приложения. Однако при определении открытого незапечатанного класса необходимо вручную применить `Windows::Foundation::Metadata::WebHostHidden` атрибута, чтобы гарантировать, что класс не является видимым для приложений универсальной платформы Windows, написанных на языке JavaScript.  
  
 Класс ссылки может содержать стандартные типы C++, включая типы `const` , в любых членах `private`, `internal`или `protected private` .  
  
 Открытые классы ссылки, имеющие параметры-типы, не допускаются. Определяемые пользователем универсальные классы ссылок не допускаются. Класс ссылки с атрибутами private, internal или protected private может быть шаблоном.  
  
## <a name="destructors"></a>Деструкторы  
 В C + +/ CX, вызвав `delete` в общем деструкторе вызывает деструктор независимо от счетчика ссылок объекта. Это позволяет определить деструктор, который будет выполнять пользовательскую очистку ресурсов, не относящихся к RAII, детерминированным образом. Однако даже в этом случае сам объект не удаляется из памяти. Память для объекта освобождается, только когда число ссылок достигает нуля.  
  
 Если деструктор класса не является общим, он вызывается только в случае, когда число ссылок достигает нуля. При вызове метода `delete` на объекте, который имеет закрытый деструктор, компилятор выдает предупреждение C4493, что «выражение delete не делает ничего как деструктор класса \<имя типа > не имеет специальных возможностей 'public'.»  
  
 Деструкторы классов ссылок можно объявлять только следующим образом:  
  
-   открытый и виртуальный (допускается только для запечатанных и незапечатанных типов);  
  
-   защищенный закрытый и невиртуальный (допускается только для незапечатанных типов);  
  
-   закрытый и невиртуальный (допускается только для запечатанных типов).  
  
 Никакие другие сочетания режимов доступа, виртуальности и запечатанности не допускаются.  Если деструктор явно не объявлен, компилятор создает открытый виртуальный деструктор, если у базового класса типа или любого из его членов имеется открытый деструктор. В противном случае компилятор создает защищенный закрытый невиртуальный деструктор для незапечатанных типов и закрытый невиртуальный деструктор для запечатанных типов.  
  
 При попытке обращения к членам класса, для которого уже запускался деструктор, поведение будет неопределенным; это наиболее вероятная причина сбоя программы. При вызове `delete t` для типа, у которого нет открытого деструктора, ничего не происходит. При вызове `delete this` для типа или базового класса, не имеющих деструктора `private` или `protected private` в иерархии типов, также ничего не происходит.  
  
 При объявлении открытого деструктора компилятор создает код таким образом, чтобы класс ссылки реализовывал интерфейс `Platform::IDisposable` , а деструктор реализовывал метод `Dispose` . `Platform::IDisposable`является C + +/ CX проекцию `Windows::Foundation::IClosable`. Никогда не следует явным образом реализовывать эти интерфейсы.  
  
## <a name="inheritance"></a>Наследование  
 Platform::Object является универсальным базовым классом для всех классов ссылок. Все классы ссылок неявно преобразуются в Platform::Object и могут переопределять [Object::ToString](../cppcx/platform-object-class.md#tostring). Однако модель наследования среды выполнения Windows не подразумевает как общая модель наследования; в C + +/ CX это означает, что определяемые пользователем открытый класс ссылки не может использоваться как базовый класс.  
  
 При создании пользовательского элемента управления XAML можно использовать в качестве базового класса `Windows::UI::Xaml::DependencyObject` , если объект участвует в системе свойств зависимостей.  
  
 После определения незапечатанного класса `MyBase` , который наследует классу `DependencyObject`, другие открытые или закрытые классы ссылок в компоненте или приложении могут наследовать этому классу `MyBase`. Наследование в открытых классах ссылок должно использоваться только для поддержки переопределений виртуальных методов, полиморфной идентичности и инкапсуляции.  
  
 Закрытый базовый класс ссылки не требуется для наследования от существующего незапечатанного класса. Если требуется, чтобы иерархия объектов моделировала собственную структуру программы или обеспечивала повторное использование кода, используйте закрытые или внутренние классы ссылок, а лучше стандартные классы C++. Доступ к функциональности закрытой иерархии объектов можно реализовать с помощью оболочки открытого запечатанного класса ссылки.  
  
 Класс ссылки, имеющий открытый или защищенный конструктор, в C + +/ CX должен быть объявлен как запечатанный. Это ограничение означает, что классы, написанные на других языках, например C# или Visual Basic могут наследовать от типов, объявленных в компоненте среды выполнения Windows, написанного на языке C + +/ CX.  
  
 Ниже приведены основные правила наследования в C + +/ CX:  
  
-   классы ссылок могут напрямую наследовать не более чем от одного базового класса, но могут реализовывать любое количество интерфейсов;  
  
-   если у класса имеется открытый конструктор, он должен объявляться как запечатанный, чтобы запретить его дальнейшее наследование;  
  
-   можно создавать открытые незапечатанные базовые классы, которые имеют внутренние или защищенные закрытые конструкторы, при условии что базовый класс является производным (прямо или косвенно) от существующего незапечатанного базового класса, такого как `Windows::UI::Xaml::DependencyObject`. Наследование определяемых пользователем классов ссылок между файлами WinMD не поддерживается; однако класс ссылки может наследовать от интерфейса, определенного в другом файле WinMD. Можно создать производные классы от определяемого пользователем базового класса только в пределах одного компонента среды выполнения Windows или приложения универсальной платформы Windows.  
  
-   для классов ссылок поддерживается только открытое наследование.  
  
     [!code-cpp[cx_classes#08](../cppcx/codesnippet/CPP/classesstructs/class1.h#08)]  
  
 В следующем примере показано, как предоставлять доступ к открытому классу ссылки, производному от других классов ссылки в иерархии наследования.  
  
 [!code-cpp[cx_classes#09](../cppcx/codesnippet/CPP/classesstructs/class1.h#09)]  
  
## <a name="see-also"></a>См. также  
 [Система типов](../cppcx/type-system-c-cx.md)   
 [Классы и структуры значений](../cppcx/value-classes-and-structs-c-cx.md)   
 [Справочник по языку Visual C++](../cppcx/visual-c-language-reference-c-cx.md)   
 [Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)