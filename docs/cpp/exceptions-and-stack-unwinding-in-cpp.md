---
title: Исключения и освобождение стека в C++
ms.date: 11/19/2019
ms.assetid: a1a57eae-5fc5-4c49-824f-3ce2eb8129ed
ms.openlocfilehash: e0dadc90f85caeea359fca4ed0b45868ea77177e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87221566"
---
# <a name="exceptions-and-stack-unwinding-in-c"></a>Исключения и освобождение стека в C++

В механизме исключений C++ элемент управления перемещается из оператора throw в первый оператор catch, который может обработать выданный тип. При достижении оператора Catch все автоматические переменные, которые находятся в области между операторами Throw и catch, уничтожаются в процессе, известном как *Очистка стека*. При очистке стека выполнение продолжается следующим образом.

1. Управление достигает **`try`** оператора с помощью обычного последовательного выполнения. В **`try`** блоке выполняется защищенный раздел.

1. Если во время выполнения защищенного раздела исключение не возникает, то **`catch`** предложения, следующие за **`try`** блоком, не выполняются. Выполнение продолжится в операторе после последнего **`catch`** предложения, следующего за соответствующим **`try`** блоком.

1. Если исключение возникает во время выполнения защищенного раздела или в любой подпрограмме, что защищенный раздел вызывает напрямую или косвенно, объект исключения создается из объекта, созданного **`throw`** операндом. (Это означает, что может быть вовлечен конструктор копии.) На этом этапе компилятор ищет **`catch`** предложение в более высоком контексте выполнения, который может управлять исключением вызываемого типа или **`catch`** обработчиком, который может обработать любые типы исключений. **`catch`** Обработчики анализируются в порядке их отображения после **`try`** блока. Если соответствующий обработчик не найден, проверяется следующий динамически охватывающий **`try`** блок. Этот процесс будет продолжен до тех пор, пока **`try`** не будет проверен внешний внешний блок.

1. Если соответствующий обработчик по-прежнему не найден или исключение возникает во время процесса очистки до получения элемента управления обработчиком, вызывается предопределенная функция времени выполнения `terminate`. Если исключение возникает после создания исключения, но до начала процесса очистки, вызывается функция `terminate`.

1. Если найден соответствующий **`catch`** обработчик, который перехватывается по значению, его формальный параметр инициализируется путем копирования объекта исключения. Если обработчик выполняет перехват по ссылке, параметр инициализируется для ссылки на объект исключения. После инициализации формального параметра начинается процесс очистки стека. Это подразумевает уничтожение всех автоматически созданных объектов, которые были полностью созданы, но еще не были удалены, между началом **`try`** блока, который связан с **`catch`** обработчиком, и исключением из-за исключения. Удаление происходит в порядке, обратном созданию. **`catch`** Обработчик выполняется, и программа возобновляет выполнение после последнего обработчика, то есть в первой инструкции или конструкции, которая не является **`catch`** обработчиком. Элемент управления может вводить **`catch`** обработчик только через выданное исключение, никогда через **`goto`** оператор или **`case`** метку в **`switch`** инструкции.

## <a name="stack-unwinding-example"></a>Пример раскрутки стека

В следующем примере показано, как очистить стек при создании исключения. Выполнение потока переходит от оператора throw в `C` к оператору catch в `main`, и при этом удаляются все функции. Обратите внимание, что порядок создания и удаления объектов `Dummy` соответствует порядку их выхода из области видимости. Также обратите внимание, что завершается выполнение только функции `main`, содержащей оператор catch. Функция `A` никогда не возвращается после вызова `B()`, и `B` никогда не возвращается после вызова `C()`. Обратите внимание, что если раскомментировать определение указателя `Dummy` и соответствующую инструкцию DELETE, а затем запустить программу, указатель не удаляется. Это показывает, что может произойти, если функции не предоставляют гарантию исключения. Дополнительные сведения см. в разделе "Практическое руководство. Разработка исключений". Если закомментировать оператор catch, можно наблюдать за тем, что происходит при завершении выполнения программы в результате необработанного исключения.

```cpp
#include <string>
#include <iostream>
using namespace std;

class MyException{};
class Dummy
{
    public:
    Dummy(string s) : MyName(s) { PrintMsg("Created Dummy:"); }
    Dummy(const Dummy& other) : MyName(other.MyName){ PrintMsg("Copy created Dummy:"); }
    ~Dummy(){ PrintMsg("Destroyed Dummy:"); }
    void PrintMsg(string s) { cout << s  << MyName <<  endl; }
    string MyName;
    int level;
};

void C(Dummy d, int i)
{
    cout << "Entering FunctionC" << endl;
    d.MyName = " C";
    throw MyException();

    cout << "Exiting FunctionC" << endl;
}

void B(Dummy d, int i)
{
    cout << "Entering FunctionB" << endl;
    d.MyName = "B";
    C(d, i + 1);
    cout << "Exiting FunctionB" << endl;
}

void A(Dummy d, int i)
{
    cout << "Entering FunctionA" << endl;
    d.MyName = " A" ;
  //  Dummy* pd = new Dummy("new Dummy"); //Not exception safe!!!
    B(d, i + 1);
 //   delete pd;
    cout << "Exiting FunctionA" << endl;
}

int main()
{
    cout << "Entering main" << endl;
    try
    {
        Dummy d(" M");
        A(d,1);
    }
    catch (MyException& e)
    {
        cout << "Caught an exception of type: " << typeid(e).name() << endl;
    }

    cout << "Exiting main." << endl;
    char c;
    cin >> c;
}

/* Output:
    Entering main
    Created Dummy: M
    Copy created Dummy: M
    Entering FunctionA
    Copy created Dummy: A
    Entering FunctionB
    Copy created Dummy: B
    Entering FunctionC
    Destroyed Dummy: C
    Destroyed Dummy: B
    Destroyed Dummy: A
    Destroyed Dummy: M
    Caught an exception of type: class MyException
    Exiting main.

*/
```
