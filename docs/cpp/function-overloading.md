---
title: Перегрузка функций | Документация Майкрософт
ms.custom: ''
ms.date: 1/25/2018
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- function overloading [C++], about function overloading
- function overloading
- declaring functions [C++], overloading
ms.assetid: 3c9884cb-1d5e-42e8-9a49-6f46141f929e
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: f57ae6a7d084a497ec41c9b66b314ad1fdb3e7fc
ms.sourcegitcommit: 2b9e8af9b7138f502ffcba64e2721f7ef52af23b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/01/2018
ms.locfileid: "39406575"
---
# <a name="function-overloading"></a>Перегрузка функций
C++ позволяет определять несколько функций с одинаковым именем в одной области. Они называются *перегружены* функции. Перегруженные функции позволяют указать различную семантику для функции, в зависимости от типов и числа аргументов. 
  
 Например `print` функцию, которая принимает `std::string` аргумент может выполнять совершенно разные задачи, чем та, которая принимает аргумент типа **двойные**. Перегрузка избавляет от необходимости использовать имена, такие как `print_string` или `print_double`. Во время компиляции компилятор выбирает перегрузку, которую нужно использовать в зависимости от типа аргументов, передаваемых в вызывающим объектом.  При вызове метода `print(42.0)` то `void print(double d)` функция будет вызываться. При вызове метода `print("hello world")` то `void print(std::string)` перегрузки будет вызываться.

Можно перегрузить функции-члены и функции, не являющихся членами. В следующей таблице указаны компоненты объявления функций, используемые языком C++ для различения групп функций с одинаковым именем в одной области.  
  
### <a name="overloading-considerations"></a>Заметки по перегрузке  
  
|Элемент объявления функции|Использование для перегрузки|  
|----------------------------------|---------------------------|  
|Тип возвращаемого функцией значения|Нет|  
|Число аргументов|Да|  
|Тип аргументов|Да|  
|Наличие или отсутствие многоточия|Да|  
|Использование **typedef** имена|Нет|  
|Незаданные границы массива|Нет|  
|**const** или **volatile**|Да, при применении к всей функции|
|[Квалификатор ref](#ref-qualifier)|Да|  
  
## <a name="example"></a>Пример  
 В следующем примере показано использование перегрузки.  
  
```cpp 
// function_overloading.cpp  
// compile with: /EHsc  
#include <iostream>  
#include <math.h>  
#include <string>

// Prototype three print functions.  
int print(std::string s);             // Print a string.  
int print(double dvalue);            // Print a double.  
int print(double dvalue, int prec);  // Print a double with a  
                                     //  given precision.  
using namespace std;
int main(int argc, char *argv[])
{
    const double d = 893094.2987;
    if (argc < 2)
    {
        // These calls to print invoke print( char *s ).  
        print("This program requires one argument.");
        print("The argument specifies the number of");
        print("digits precision for the second number");
        print("printed.");
        exit(0);
    }

    // Invoke print( double dvalue ).  
    print(d);

    // Invoke print( double dvalue, int prec ).  
    print(d, atoi(argv[1]));
}

// Print a string.  
int print(string s)
{
    cout << s << endl;
    return cout.good();
}

// Print a double in default precision.  
int print(double dvalue)
{
    cout << dvalue << endl;
    return cout.good();
}

//  Print a double in specified precision.  
//  Positive numbers for precision indicate how many digits  
//  precision after the decimal point to show. Negative  
//  numbers for precision indicate where to round the number  
//  to the left of the decimal point.  
int print(double dvalue, int prec)
{
    // Use table-lookup for rounding/truncation.  
    static const double rgPow10[] = {
        10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1, 
        10E0, 10E1,  10E2,  10E3,  10E4, 10E5,  10E6 };
    const int iPowZero = 6;

    // If precision out of range, just print the number.  
    if (prec < -6 || prec > 7)
    {
        return print(dvalue);
    }
    // Scale, truncate, then rescale.  
    dvalue = floor(dvalue / rgPow10[iPowZero - prec]) *
        rgPow10[iPowZero - prec];
    cout << dvalue << endl;
    return cout.good();
}  
```  
  
 В приведенном выше коде отображается перегрузка функции `print` в области видимости файла.  
  
 Аргумент по умолчанию не считается частью типа функции. Следовательно, он не используется для выбора перегруженных функций. Две функции, которые различаются только в своих аргументах, считаются множественными определениями, а не перегруженными функциями.  
  
 Аргументы по умолчанию не поставляются для перегруженных операторов.  
  
  
## <a name="argument-matching"></a>Сопоставление аргументов  
 Перегруженные функции выбираются для оптимального соответствия объявлений функций в текущей области аргументам, предоставленным в вызове функции. Если подходящая функция найдена, эта функция вызывается. "Подходящая" в данном контексте означает одно из следующего.  
  
-   Точное соответствие найдено.  
  
-   Тривиальное преобразование выполнено.  
  
-   Восходящее приведение целого типа выполнено.  
  
-   Стандартное преобразование в требуемый тип аргумента существует.  
  
-   Пользовательское преобразование (оператор преобразования или конструктор) в требуемый тип аргумента существует.  
  
-   Аргументы, представленные многоточием, найдены.  
  
 Компилятор создает набор функций-кандидатов для каждого аргумента. Функции-кандидаты — это функции, в которых фактический аргумент в данной позиции можно преобразовать в тип формального аргумента.  
  
 Для каждого аргумента создается набор наиболее подходящих функций, и выбранная функция представляет собой пересечение всех наборов. Если на пересечении находится несколько функций, перегрузка является неоднозначной и выдает ошибку. Функция, которая выбирается в конечном итоге, всегда является самой подходящей по сравнению с остальными функциями в группе по крайней мере для одного аргумента. В противном случае (если невозможно определить наиболее подходящую функцию) при вызове функции выдается ошибка.  
  
 Рассмотрим следующие объявления (функции отмечены как `Variant 1`, `Variant 2` и `Variant 3` для ссылки в последующем обсуждении).  
  
```cpp 
Fraction &Add( Fraction &f, long l );       // Variant 1  
Fraction &Add( long l, Fraction &f );       // Variant 2  
Fraction &Add( Fraction &f, Fraction &f );  // Variant 3  
  
Fraction F1, F2;  
```
  
 Рассмотрим следующий оператор.  
  
```cpp 
F1 = Add( F2, 23 );  
```  
  
 Представленный выше оператор создает два набора.  
  
|Набор 1. Функции-кандидаты, имеющие первый аргумент дробного типа|Набор 2: Кандидата функции которых второй аргумент можно преобразовать к типу **int**|  
|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------|  
|Variant 1|Вариант 1 (**int** может быть преобразован в **long** с помощью стандартного преобразования)|  
|Variant 3||  
  
 Функции в наборе 2 представляют собой функции, для которых выполнены неявные преобразования из типа фактического параметра в тип формального параметра. Среди таких функций имеется функция, для которой затраты преобразования из типа фактического параметра в тип формального параметра являются наименьшими.  
  
 Пересечением этих двух наборов является функция Variant 1. Ниже представлен пример неоднозначного вызова функции.  
  
```cpp 
F1 = Add( 3, 6 );  
```  
  
 В предыдущем вызове функции создаются следующие наборы.  
  
|Набор 1: Кандидата функции, имеющие первый аргумент типа **int**|Набор 2: Кандидата функции, имеющие второй аргумент типа **int**|  
|---------------------------------------------------------------------|----------------------------------------------------------------------|  
|Variant 2 (**int** может быть преобразован в **long** с помощью стандартного преобразования)|Вариант 1 (**int** может быть преобразован в **long** с помощью стандартного преобразования)|  
  
 Обратите внимание, что на пересечении этих наборов функция отсутствует. Поэтому компилятор создает сообщение об ошибке.  
  
 Для сопоставления функции с помощью аргументов *n* аргументы по умолчанию рассматривается как *n*+ 1 отдельные функции, каждая из которых Разное количество аргументов.  
  
 Многоточие (...) выступает в качестве подстановочного знака; оно соответствует любому фактическому аргументу. Это может привести к появлению множества неоднозначных наборов, если не соблюдать предельную осторожность при разработке наборов перегруженных функций.  
  
> [!NOTE]
>  Неоднозначность перегруженных функций невозможно определить, пока не будет обнаружен вызов функции. На этом этапе наборы создаются для каждого аргумента в вызове функции, и можно определить, существует ли неоднозначная перегрузка. Это означает, что неоднозначности могут оставаться в коде до тех пор, пока они не будут вызваны конкретным вызовом функции.  
  
## <a name="argument-type-differences"></a>Различия типов аргументов  
 Перегруженные функции различают типы аргументов, имеющие разные инициализаторы. Следовательно, аргумент заданного типа и ссылка на этот тип считаются одинаковыми для перегрузки, поскольку имеют одни и те же инициализаторы. Например, `max( double, double )` — то же самое, что и `max( double &, double & )`. Объявление двух таких функций приводит к ошибке.  
  
 По этой же причине аргументы функций, тип которых изменен с **const** или **volatile** не обрабатываются иначе, чем базовый тип для перегрузки.  
  
 Однако механизм перегрузки функций может различать ссылки, которые определяются **const** и **volatile** и ссылки на базовый тип. Это позволяет создать код, аналогичный приведенному ниже.  
  
```cpp 
// argument_type_differences.cpp  
// compile with: /EHsc /W3  
// C4521 expected  
#include <iostream>  
  
using namespace std;  
class Over {  
public:  
   Over() { cout << "Over default constructor\n"; }  
   Over( Over &o ) { cout << "Over&\n"; }  
   Over( const Over &co ) { cout << "const Over&\n"; }  
   Over( volatile Over &vo ) { cout << "volatile Over&\n"; }  
};  
  
int main() {  
   Over o1;            // Calls default constructor.  
   Over o2( o1 );      // Calls Over( Over& ).  
   const Over o3;      // Calls default constructor.  
   Over o4( o3 );      // Calls Over( const Over& ).  
   volatile Over o5;   // Calls default constructor.  
   Over o6( o5 );      // Calls Over( volatile Over& ).  
}  
```  
  
### <a name="output"></a>Вывод  
  
```Output  
Over default constructor  
Over&  
Over default constructor  
const Over&  
Over default constructor  
volatile Over&  
```  
  
 Указатели на **const** и **volatile** объекты также считаются отличными от указателей на базовый тип для перегрузки.  
  
## <a name="argument-matching-and-conversions"></a>Сопоставление аргументов и преобразования  
 Когда компилятор пытается сопоставить фактические аргументы с аргументами в объявлениях функций и точное соответствие найти не удается, для получения правильного типа он может выполнять стандартные или пользовательские преобразования. Для преобразований действуют следующие правила:  
  
-   последовательности преобразований, содержащие несколько пользовательских преобразований, не учитываются;  
  
-   последовательности преобразований, которые могут быть сокращены путем удаления промежуточных преобразований, не учитываются.  
  
 Получающаяся последовательность преобразований (если таковые имеются), называется наилучшей последовательностью сопоставления. Существует несколько способов преобразования объекта типа **int** ввода **unsigned long** с использованием стандартных преобразований (описанных в [стандартные преобразования](../cpp/standard-conversions.md)):  
  
-   Преобразование из **int** для **long** и затем из **long** для **unsigned long**.  
  
-   Преобразование из **int** для **unsigned long**.  
  
 Первая последовательность, хотя и обеспечивает достижение требуемой цели, не является наилучшей последовательностью сопоставления, так как существует более короткая последовательность.  
  
 В представленной ниже таблице показана группа преобразований, называемых тривиальными. Они оказывают ограниченное влияние на определение наилучшей последовательности сопоставления. В списке, приведенном после таблицы, рассматриваются экземпляры, в которых тривиальные преобразования влияют на выбор последовательности.  
  
### <a name="trivial-conversions"></a>Тривиальные преобразования  
  
|Тип, из которого выполняется преобразование|Тип, в который выполняется преобразование|  
|-----------------------|---------------------|  
|*Имя типа*|*Имя типа* **&**|  
|*Имя типа* **&**|*Имя типа*|  
|*Имя типа* **]**|*type-name\***|  
|*Имя типа* **(** *список аргументов* **)**|**(**  *\*имя типа* **) (** *список аргументов* **)**|  
|*Имя типа*|**const** *имя типа*|  
|*Имя типа*|**volatile** *имя типа*|  
|*type-name\***|**const** *имя типа\***|  
|*type-name\***|**volatile** *имя типа\**|  
  
 Ниже приведена последовательность, в которой делаются попытки выполнения преобразований.  
  
1.  Точное соответствие. Точное соответствие между типами, с которыми функция вызывается, и типами, объявленными в прототипе функции, всегда является наилучшим соответствием. Последовательности тривиальных преобразований классифицируются как точные соответствия. Однако последовательности, не выполняющие никакие из этих преобразований, считаются лучше, чем последовательности, осуществляющие следующие преобразования:  
  
    -   Из указателя в указатель на **const** (`type` **\*** для **const** `type` **\*** ).  
  
    -   Из указателя в указатель на **volatile** (`type` **\*** для **volatile** `type` **\***).  
  
    -   Из указателя в указатель на **const** (`type` **&** для **const** `type` **&**).  
  
    -   Из указателя в указатель на **volatile** (`type` **&** для **volatile** `type` **&**).  
  
2.  Сопоставление с использованием повышений. Любая последовательность, не классифицированная как точное соответствие, содержащий только восходящие приведения целого типа, преобразования из **float** для **двойные**, и тривиальные преобразования, классифицируется как сопоставление с использованием повышений. Хотя сопоставление с использованием повышений не такое хорошее, как точное, оно лучше сопоставления с использованием стандартных преобразований.  
  
3.  Сопоставление с использованием стандартных преобразований. Любая последовательность, не классифицированная как точное соответствие или сопоставление с использованием повышений и содержащая только стандартные и тривиальные преобразования, классифицируется как сопоставление с использованием стандартных преобразований. В этой категории применяются следующие правила:  
  
    -   Преобразование из указателя на производный класс в указатель на прямой или косвенный базовый класс предпочтительнее преобразования в `void *` или `const void *`.  
  
    -   преобразование из указателя на производный класс в указатель на базовый класс создает тем более хорошее соответствие, чем ближе базовый класс к прямому базовому классу. Предположим, что иерархия классов имеет вид, показанный на следующем рисунке.  
  
 ![Предпочтительные преобразования](../cpp/media/vc391t1.gif "vc391T1")  
Граф, иллюстрирующий предпочтительные преобразования  
  
 Преобразование из типа `D*` в тип `C*` предпочтительнее преобразования из типа `D*` в тип `B*`. Аналогично, преобразование из типа `D*` в тип `B*` предпочтительнее преобразования из типа `D*` в тип `A*`.  
  
 Это же правило применяется для преобразований ссылок. Преобразование из типа `D&` в тип `C&` предпочтительнее преобразования из типа `D&` в тип `B&` и т. д.  
  
 Это же правило применяется для преобразований указателей на член. Преобразование из типа `T D::*` в тип `T C::*` предпочтительнее преобразования из типа `T D::*` в тип `T B::*` и т. д. (`T` — тип члена.)  
  
 Предыдущее правило применяется только в определенном пути наследования. Рассмотрим граф, показанный на следующем рисунке.  
  
 ![С несколькими&#45;наследование, показывающее предпочтительные преобразования](../cpp/media/vc391t2.gif "vc391T2")  
Граф множественного наследования, иллюстрирующий предпочтительные преобразования  
  
 Преобразование из типа `C*` в тип `B*` предпочтительнее преобразования из типа `C*` в тип `A*`. Причина заключается в том, что эти преобразования находятся на одном пути и узел `B*` ближе. Однако преобразование из типа `C*` в тип `D*` не предпочтительнее преобразования в тип `A*`. Предпочтение отсутствует, поскольку преобразования осуществляются с использованием разных путей.  
  
1.  Сопоставление с пользовательскими преобразованиями. Эту последовательность невозможно классифицировать как точное сопоставление, сопоставление с использованием повышений или сопоставление с использованием стандартных преобразований. Чтобы последовательность можно было классифицировать как сопоставление с пользовательскими преобразованиями, она должна содержать только пользовательские, стандартные или тривиальные преобразования. Сопоставление с пользовательскими преобразованиями лучше сопоставления с многоточием, но хуже сопоставления со стандартными преобразованиями.  
  
2.  Сопоставление с многоточием. Любая последовательность, соответствующая многоточию в объявлении, классифицируется как сопоставление с многоточием. Это самое слабое соответствие.  
  
 Пользовательские преобразования применяются при отсутствии встроенного повышения или преобразования. Эти преобразования выбираются на основе типа сопоставляемого аргумента. Рассмотрим следующий код.  
  
```cpp 
// argument_matching1.cpp  
class UDC  
{  
public:  
   operator int()  
   {  
      return 0;  
   }  
   operator long();  
};  
  
void Print( int i )  
{  
};  
  
UDC udc;  
  
int main()  
{  
   Print( udc );  
}  
```  
  
 Доступные заданные пользователем преобразования для класса `UDC` : из типа **int** и тип **long**. Поэтому компилятор проверяет преобразования для типа сопоставляемого объекта: `UDC`. Преобразование в **int** существует, и он выбран.  
  
 В процессе сопоставления аргументов стандартные преобразования можно применять как к аргументу, так и к результату пользовательского преобразования. Поэтому следующий код работает.  
  
```cpp 
void LogToFile( long l );  
...  
UDC udc;  
LogToFile( udc );  
```  
  
 В предыдущем примере, определенное пользователем преобразование **long-оператор**, вызывается для преобразования `udc` ввода **long**. Если нет определенное пользователем преобразование в тип **long** был определен, преобразование продолжилось бы следующим образом: тип `UDC` был бы преобразован в тип **int** с помощью определяемых пользователем преобразование. Затем стандартное преобразование из типа **int** ввода **long** была реализована в соответствии с аргументом в объявлении.  
  
 Если для сопоставления аргумента необходимы какие-либо пользовательские преобразования, стандартные преобразования при оценке наилучшего соответствия не используются. Это утверждение верно даже в том случае, если пользовательское преобразование требуется нескольким функциям-кандидатам; в таком случае функции считаются одинаковыми. Пример:  
  
```cpp 
// argument_matching2.cpp  
// C2668 expected  
class UDC1  
{  
public:  
   UDC1( int );  // User-defined conversion from int.  
};  
  
class UDC2  
{  
public:  
   UDC2( long ); // User-defined conversion from long.  
};  
  
void Func( UDC1 );  
void Func( UDC2 );  
  
int main()  
{  
   Func( 1 );  
}  
```  
  
 Обе версии `Func` требуют определенного пользователем преобразования для преобразования типа **int** аргументу типа класса. Возможные преобразования:  
  
-   Преобразование из типа **int** ввода `UDC1` (пользовательское преобразование).  
  
-   Преобразование из типа **int** ввода **long**; затем преобразование в тип `UDC2` (двухступенчатое преобразование).  
  
 Даже несмотря на то, что для второго из этих преобразований требуются стандартное преобразование и пользовательское преобразование, эти два преобразования все равно считаются одинаковыми.  
  
> [!NOTE]
>  Пользовательские преобразования считаются преобразованиями посредством создания или инициализации (функции преобразования). При рассмотрении наилучшего соответствия оба метода считаются одинаковыми.  
  
## <a name="argument-matching-and-the-this-pointer"></a>Сопоставление аргументов и указатель this  
 Функции-члены класса обрабатываются по-разному, в зависимости от того, они будут объявлены как **статических**. Поскольку нестатические функции имеют неявный аргумент, который предоставляет **это** указатель, считается, что нестатические функции имеют один аргумент больше, чем статические функции; в противном случае они объявляются одинаково.  
  
 Эти нестатические функции-члены требуют неявный **это** указатель соответствовал типу объекта, через который вызывается функция, или, для перегруженных операторов, они требуют, что первый аргумент совпадал с объект, для которого применяется оператор. (Дополнительные сведения о перегруженных операторах см. в разделе [перегруженные операторы](../cpp/operator-overloading.md).)  
  
 В отличие от других аргументов в перегруженных функций, представленные никакие временные объекты и преобразования не применяются при попытке сопоставить **это** аргументом указателя.  
  
 Когда `->` оператора выбора члена используется для доступа к функции-члена класса `class_name`, **это** аргумент-указатель с типом `class_name * const`. Если элементы объявлены как **const** или **volatile**, типы, `const class_name * const` и `volatile class_name * const`, соответственно.  
  
 Оператор выбора члена `.` работает точно так же, за исключением того, что в качестве префикса к имени объекта подставляется неявный оператор взятия адреса `&`. В следующем примере показано, как это делается:  
  
```cpp 
// Expression encountered in code  
obj.name  
  
// How the compiler treats it  
(&obj)->name  
```  
  
 С точки зрения сопоставления аргументов, левый операнд операторов `->*` и `.*` (указатель на член) обрабатывается так же, как и для операторов `.` и `->` (выбор члена).  

## <a name="ref-qualifiers"></a> Ref квалификаторы для функций-членов  
Квалификаторы ref делают возможным перегрузить функцию-член на основании ли объект указывает **это** rvalue или lvalue.  Эту функцию можно использовать чтобы избежать ненужных операций копирования в сценариях, где пользователь не указывает указатель доступ к данным. Предположим, например, класс `C` некоторые данные в его конструктор инициализирует и возвращает копию этих данных в функции-члене `get_data()`. Если тип объекта `C` представляет собой rvalue, уничтожить, то компилятор выберет `get_data() &&` перегрузку, которая перемещает данные, чем скопировать его. 

```cpp
#include <iostream>
#include <vector>

using namespace std;

class C
{

public:
    C() {/*expensive initialization*/}
    vector<unsigned> get_data() & 
    { 
        cout << "lvalue\n";
        return _data;
    }
    vector<unsigned> get_data() && 
    {
        cout << "rvalue\n";
        return std::move(_data);
    }
    
private:
    vector<unsigned> _data;
};

int main()
{
    C c;
    auto v = c.get_data(); // get a copy. prints "lvalue".
    auto v2 = C().get_data(); // get the original. prints "rvalue"
    return 0;
}
```
  
## <a name="restrictions-on-overloading"></a>Ограничения по перегрузке  
 К допустимому набору перегруженных функций применяется несколько ограничений.  
  
-   Любые две функции в наборе перегруженных функций должны иметь разные списки аргументов.  
  
-   Перегрузка функций со списками аргументов одного типа лишь на основании типа возвращаемого значения недопустима.  
  
     **Блок, относящийся только к системам Microsoft**  
  
 Можно перегрузить **оператор new** исключительно на основании возвращаемого типа, в частности, на основании указанного модификатора модели памяти.  
  
**Завершение блока, относящегося только к системам Майкрософт**  
  
-   Функции-члены невозможно перегружать исключительно на основании того, что одна из них является статической, а вторая — нестатической.  
  
-   **TypeDef** объявления не определяют новые типы; они представляют синонимы для существующих типов. Они не влияют на механизм перегрузки. Рассмотрим следующий код.  
  
    ```cpp 
    typedef char * PSTR;  
  
    void Print( char *szToPrint );  
    void Print( PSTR szToPrint );  
    ```  
  
     Две указанные выше функции имеют идентичные списки аргументов. `PSTR` является синонимом для типа `char *`. В области члена этот код возвращает ошибку.  
  
-   Перечисляемые типы являются отдельными типами и могут использоваться для различения перегруженных функций.  
  
-   Типы "массив" и "указатель" считаются идентичными при различении перегруженных функций. Это верно только для одномерных массивов. Поэтому следующие перегруженные функции вступают в конфликт и выдают сообщение об ошибке.  
  
    ```cpp 
    void Print( char *szToPrint );  
    void Print( char szToPrint[] );  
    ```  
  
     В случае многомерных массивов второе и все последующие измерения являются частью типа. Поэтому они используются для различения перегруженных функций.  
  
    ```cpp 
    void Print( char szToPrint[] );  
    void Print( char szToPrint[][7] );  
    void Print( char szToPrint[][9][42] );  
    ```  
  
## <a name="overloading-overriding-and-hiding"></a>Перегрузка, переопределение и скрытие
  
 Любые два объявления функции с одинаковым именем в одной области видимости могут ссылаться на одну функцию или на две разные перегруженные функции. Если списки аргументов в объявлениях содержат аргументы эквивалентных типов (как описано в предыдущем разделе), эти объявления относятся к одной и той же функции. В противном случае они ссылаются на две различные функции, которые выбираются с использованием перегрузки.  
  
 Область видимости класса строго соблюдается; поэтому функция, объявленная в базовом классе, не находится в той же области видимости, что и функция, объявленная в производном классе. Если функция в производном классе объявлена с тем же именем, что и виртуальная функция в базовом классе, функция производного класса *переопределяет* функцию базового класса. Дополнительные сведения см. в разделе [виртуальные функции](../cpp/virtual-functions.md).

Если функция базового класса не объявлено как «virtual», то функция производного класса говорят, что *скрыть* его. Переопределение и скрытие отличаются от перегрузки.  
  
 Область видимости блока строго соблюдается; поэтому функция, объявленная в области видимости файла, не находится в той же области видимости, что и функция, объявленная локально. Если локально объявленная функция имеет то же имя, что и функция, объявленная в области файла, локально объявленная функция скрывает функцию области файла, не вызывая перегрузки. Пример:  
  
```cpp 
// declaration_matching1.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
void func( int i )  
{  
    cout << "Called file-scoped func : " << i << endl;  
}  
  
void func( char *sz )  
{  
   cout << "Called locally declared func : " << sz << endl;  
}  
  
int main()  
{  
   // Declare func local to main.  
   extern void func( char *sz );  
  
   func( 3 );   // C2664 Error. func( int ) is hidden.  
   func( "s" );  
}  
```  
  
 В предыдущем коде показаны два определения функции `func`. Определение, которое принимает аргумент типа `char *` является локальным для `main` из-за **extern** инструкции. Таким образом, определение, которое принимает аргумент типа **int** скрыта и первый вызов `func` произошла ошибка.  
  
 В случае перегруженных функций-членов различным версиям функции могут предоставляться разные права доступа. Они по-прежнему считаются находящимися в области видимости включающего класса и, таким образом, являются перегруженными функциями. Рассмотрим следующий код, в котором функция-член `Deposit` перегружена; одна версия является открытой, вторая — закрытой.  
  
 Целью кода в примере является предоставление класса `Account`, в котором для внесения средств требуется правильный пароль. Для этого используется перегрузка.  
  
 Обратите внимание, что при вызове функции `Deposit` в операторе `Account::Deposit` вызывается закрытая функция-член. Это правильный вызов, поскольку функция `Account::Deposit` является функцией-членом и, следовательно, имеет доступ к закрытым членам класса.  
  
```cpp 
// declaration_matching2.cpp  
class Account  
{  
public:  
   Account()  
   {  
   }  
   double Deposit( double dAmount, char *szPassword );  
  
private:  
   double Deposit( double dAmount )  
   {  
      return 0.0;  
   }  
   int Validate( char *szPassword )  
   {  
      return 0;  
   }  
  
};  
  
int main()  
{  
    // Allocate a new object of type Account.  
    Account *pAcct = new Account;  
  
    // Deposit $57.22. Error: calls a private function.  
    // pAcct->Deposit( 57.22 );  
  
    // Deposit $57.22 and supply a password. OK: calls a  
    //  public function.  
    pAcct->Deposit( 52.77, "pswd" );  
}  
  
double Account::Deposit( double dAmount, char *szPassword )  
{  
   if ( Validate( szPassword ) )  
      return Deposit( dAmount );  
   else  
      return 0.0;  
}  
```

## <a name="see-also"></a>См. также  
 [Функции (C++)](../cpp/functions-cpp.md)