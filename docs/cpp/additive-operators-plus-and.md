---
title: 'Аддитивные операторы: + и -'
ms.date: 11/04/2016
f1_keywords:
- +
- '-'
helpviewer_keywords:
- operators [C++], addition
- subtraction operator [C++], additive operators
- + operator [C++], additive operators
- additive operators [C++]
- arithmetic operators [C++], additive operators
- '- operator [C++], additive operators in C++'
ms.assetid: d4afafe7-e201-4c69-a649-37f17756e784
ms.openlocfilehash: 739132ce1889b7e73b7ae19f5072a1dfec9c066d
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80181672"
---
# <a name="additive-operators--and--"></a>Аддитивные операторы: + и -

## <a name="syntax"></a>Синтаксис

```
expression + expression
expression - expression
```

## <a name="remarks"></a>Remarks

Ниже перечислены аддитивные операторы.

- Сложение ( **+** )

- Вычитание ( **-** )

Эти бинарные операторы имеют ассоциативность слева направо.

Аддитивные операторы принимают операнды арифметических типов или типов указателей. Результатом оператора сложения ( **+** ) является сумма операндов. Результатом оператора вычитания ( **-** ) является разница между операндами. Если один или оба операнда являются указателями, они должны быть указателями на объекты, а не на функции. Когда оба операнда являются указателями, результаты имеют смысл только в том случае, если оба операнда указывают на объекты в одном массиве.

Аддитивные операторы принимают операнды *арифметических*, *целочисленных*и *скалярных* типов. Они описаны в следующей таблице.

### <a name="types-used-with-additive-operators"></a>Типы, используемые с аддитивными операторами

|Тип|Значение|
|----------|-------------|
|*Арифметические*|Целочисленные типы и типы с плавающей запятой собирательно называются "арифметическими" типами.|
|*целочисленный*|Типы char и int всех размеров (long, short), а также перечисления называются "целочисленными типами".|
|*функцией*|Скалярные операнды — это операнды арифметического типа или типа указателя.|

Допускаются следующие сочетания этих операторов:

*арифметические + * *арифметические* действия

*целочисленный* + *скалярной*

*целочисленный* + *скалярный*

*арифметические - * *арифметические* действия

*скалярная - * скалярная *scalar*

Обратите внимание, что сложение и вычитание не являются эквивалентными операциями.

Если оба операнда имеют арифметический тип, то преобразования, охваченные [стандартными преобразованиями](standard-conversions.md) , применяются к операндам, а результат относится к преобразованному типу.

## <a name="example"></a>Пример

```cpp
// expre_Additive_Operators.cpp
// compile with: /EHsc
#include <iostream>
#define SIZE 5
using namespace std;
int main() {
   int i = 5, j = 10;
   int n[SIZE] = { 0, 1, 2, 3, 4 };
   cout  << "5 + 10 = " << i + j << endl
         << "5 - 10 = " << i - j << endl;

   // use pointer arithmetic on array

   cout << "n[3] = " << *( n + 3 ) << endl;
}
```

## <a name="pointer-addition"></a>Добавление указателей

Если один из операндов в операции сложения является указателем на массив объектов, другой должен иметь целочисленный тип. Результатом является указатель, имеющий тот же тип, что и исходный указатель, и указывающий на другой элемент массива. Эта концепция проиллюстрирована в следующем фрагменте кода.

```cpp
short IntArray[10]; // Objects of type short occupy 2 bytes
short *pIntArray = IntArray;

for( int i = 0; i < 10; ++i )
{
    *pIntArray = i;
    cout << *pIntArray << "\n";
    pIntArray = pIntArray + 1;
}
```

Несмотря на то что целочисленное значение 1 добавляется в `pIntArray`, это не означает "добавить 1 к адресу"; скорее, это означает "скорректировать указатель так, чтобы он указывал на следующий объект в массиве", то есть через 2 байта (или `sizeof( int )`).

> [!NOTE]
>  Код формы `pIntArray = pIntArray + 1` редко можно найти в программах на C++; чтобы выполнить пошаговое увеличение, предпочтительно использовать следующие формы: `pIntArray++` или `pIntArray += 1`.

## <a name="pointer-subtraction"></a>Вычитание указателей

Если оба операнда являются указателями, то результатом вычитания будет число элементов массива, находящихся между операндами. Выражение вычитания дает целочисленный результат со знаком `ptrdiff_t` типа (определенный в стандартном включаемом файле \<STDDEF. h >).

Второй операнд может иметь целочисленное значение. Результат вычитания имеет тот же тип, что и исходный указатель. Значение вычитания является указателем на элемент массива (*n* - *i*), где *n* — элемент, на который указывает исходный указатель, а *i* — это целочисленное значение второго операнда.

## <a name="see-also"></a>См. также раздел

[Выражения с бинарными операторами](../cpp/expressions-with-binary-operators.md)<br/>
[Встроенные операторы C++, приоритет и ассоциативность](../cpp/cpp-built-in-operators-precedence-and-associativity.md)<br/>
[Аддитивные операторы в C](../c-language/c-additive-operators.md)
