---
title: Оператор static_cast | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
f1_keywords:
- static_cast_cpp
dev_langs:
- C++
helpviewer_keywords:
- static_cast keyword [C++]
ms.assetid: 1f7c0c1c-b288-476c-89d6-0e2ceda5c293
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: ad9af76787780ebe2a25b3fab46ce1951085b8e8
ms.sourcegitcommit: 1fd1eb11f65f2999dfd93a2d924390ed0a0901ed
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/10/2018
ms.locfileid: "37944766"
---
# <a name="staticcast-operator"></a>Оператор static_cast
Преобразует *выражение* типу *идентификатор типа* только на основе типов, которые присутствуют в выражении.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
static_cast <type-id> ( expression )   
```  
  
## <a name="remarks"></a>Примечания  
 В стандартном языке C++, проверка типа во время выполнения не выполняется, что обеспечивает безопасность преобразования. В C ++/CX выполняются проверки во время компиляции и во время выполнения. Дополнительные сведения см. в разделе [приведение](casting.md).  
  
 **Static_cast** оператор может использоваться для операции, такие как преобразование указателя на базовый класс в указатель на производный класс. Такие преобразования не всегда являются безопасными.  
  
 В общем использовании **static_cast** для преобразования типов числовых данных, например перечисления в целые числа или целые числа, числа с плавающей запятой, и являются определенные типы данных используются в преобразовании. **static_cast** преобразования не как **dynamic_cast** преобразования, так как **static_cast** тип времени выполнения не проверяет, тогда как **dynamic_cast** выполняет. Объект **dynamic_cast** к неоднозначному указателю завершится ошибкой, пока **static_cast** возвращает, как если бы все в порядке; это может быть опасно. Несмотря на то что **dynamic_cast** преобразования безопасны, **dynamic_cast** только works на указатели или ссылки и проверку типов во время выполнения является дополнительной нагрузкой. Дополнительные сведения см. в разделе [оператор dynamic_cast](../cpp/dynamic-cast-operator.md).  
  
 В следующем примере строка `D* pd2 = static_cast<D*>(pb);` небезопасна, поскольку `D` может иметь поля и методы, не входящие в `B`. Однако строка `B* pb2 = static_cast<B*>(pd);` является безопасным преобразованием, поскольку `D` всегда содержит все `B`.  
  
```cpp 
// static_cast_Operator.cpp  
// compile with: /LD  
class B {};  
  
class D : public B {};  
  
void f(B* pb, D* pd) {  
   D* pd2 = static_cast<D*>(pb);   // Not safe, D can have fields  
                                   // and methods that are not in B.  
  
   B* pb2 = static_cast<B*>(pd);   // Safe conversion, D always  
                                   // contains all of B.  
}  
```  
  
 В отличие от к [dynamic_cast](../cpp/dynamic-cast-operator.md), проверка во время выполнения не проводится на **static_cast** преобразование `pb`. Объект, на который указывает `pb`, может не быть объектом типа `D`, и в этом случае использование `*pd2` может привести ужасным последствиям. Например, вызов функции, являющейся членом класса `D`, но не класса `B`, может привести к нарушению прав доступа.  
  
 **Dynamic_cast** и **static_cast** операторы переместить указатель по всей иерархии классов. Тем не менее **static_cast** исключительно с помощью сведений, предоставленных в операторе приведения и поэтому может быть небезопасно. Пример:  
  
```cpp 
// static_cast_Operator_2.cpp  
// compile with: /LD /GR  
class B {  
public:  
   virtual void Test(){}  
};  
class D : public B {};  
  
void f(B* pb) {  
   D* pd1 = dynamic_cast<D*>(pb);  
   D* pd2 = static_cast<D*>(pb);  
}  
```  
  
 Если `pb` действительно указывает на объект типа `D`, `pd1` и `pd2` получат одно и то же значение. Также они получат одно и то же значение, если `pb == 0`.  
  
 Если `pb` указывает на объект типа `B` , а не полный `D` класса, затем **dynamic_cast** будет достаточно возвращается ноль. Тем не менее **static_cast** основывается на утверждении программиста, `pb` указывает на объект типа `D` и просто возвращает указатель на этот предполагаемый `D` объекта.  
  
 Следовательно **static_cast** можно выполнить обратное неявные преобразования, в противном случае результаты не определены. Возлагается на программиста, чтобы убедиться, что результаты **static_cast** преобразования являются безопасными.  
  
 Это поведение также применяется к типам, отличным от типов класса. Например **static_cast** может использоваться для преобразования из int в **char**. Тем не менее полученный в результате **char** может иметь недостаточно бит для хранения всего **int** значение. Опять же, возлагается на программиста, чтобы убедиться, что результаты **static_cast** преобразования являются безопасными.  
  
 **Static_cast** оператор может также использоваться для выполнения любого неявного преобразования, включая стандартные преобразования и заданные пользователем преобразования. Пример:  
  
```cpp 
// static_cast_Operator_3.cpp  
// compile with: /LD /GR  
typedef unsigned char BYTE;  
  
void f() {  
   char ch;  
   int i = 65;  
   float f = 2.5;  
   double dbl;  
  
   ch = static_cast<char>(i);   // int to char  
   dbl = static_cast<double>(f);   // float to double  
   i = static_cast<BYTE>(ch);  
}  
```  
  
 **Static_cast** оператор можно явно преобразовать целочисленное значение в тип перечисления. Если значение типа целого не оказывается в диапазоне значений перечисления, получаемое значение перечисления не определено.  
  
 **Static_cast** оператор преобразует значение пустого указателя в значение пустого указателя конечного типа.  
  
 Любое выражение можно явно преобразовать в тип void с **static_cast** оператор. При необходимости можно включить тип назначения void **const**, **volatile**, или **__unaligned** атрибута.  
  
 **Static_cast** оператор не может удалять **const**, **volatile**, или **__unaligned** атрибуты. См. в разделе [оператор const_cast](../cpp/const-cast-operator.md) сведения об удалении этих атрибутов.  
  
 Из-за опасности выполнения непроверенных приведений в верхней части сжимаемые сборщик мусора, использование **static_cast** должен быть только в важных для производительности коде при наличии уверенности, он будет работать правильно. Если необходимо использовать **static_cast** в режиме выпуска, замените его [safe_cast](../windows/safe-cast-cpp-component-extensions.md) в отладочных сборках, для достижения успеха.  
  
## <a name="see-also"></a>См. также  
 [Операторы приведения](../cpp/casting-operators.md)   
 [Ключевые слова](../cpp/keywords-cpp.md)