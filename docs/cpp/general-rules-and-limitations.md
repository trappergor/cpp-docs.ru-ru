---
title: Общие правила и ограничения | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
ms.assetid: 6c48902d-4259-4761-95d4-e421d69aa050
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 19a704036ffac974bc99d93996d083733f59d0d4
ms.sourcegitcommit: 1fd1eb11f65f2999dfd93a2d924390ed0a0901ed
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/10/2018
ms.locfileid: "37944795"
---
# <a name="general-rules-and-limitations"></a>Общие правила и ограничения
## <a name="microsoft-specific"></a>Блок, относящийся только к системам Microsoft  
  
-   При объявлении функции или объекта без **dllimport** или **dllexport** атрибут, функция или объект не считается частью интерфейса DLL. Поэтому объявление функции или объекта должно находиться в том же самом модуле или в другом модуле той же программы. Чтобы сделать функции или объекта частью интерфейса DLL, необходимо объявить определение функции или объекта в другом модуле **dllexport**. В противном случае возникает ошибка компоновщика.  
  
     Если в объявлении функции или объекта с **dllexport** атрибут, его определение должно отображаться в каком-либо модуле той же программы. В противном случае возникает ошибка компоновщика.  
  
-   Если один модуль в программе содержит оба **dllimport** и **dllexport** объявления для одной и той же функции или объекта, **dllexport** атрибут имеет приоритет над **dllimport** атрибута. Однако компилятор создает предупреждение. Пример:  
  
    ```cpp 
    __declspec( dllimport ) int i;  
    __declspec( dllexport ) int i;   // Warning; inconsistent;  
                                     // dllexport takes precedence.  
    ```  
  
-   В C++ можно инициализировать указатель на глобально объявленный или статический локальных данных или с адресом объекта данных, объявленного с **dllimport** атрибут, который приводит к ошибке на языке C. Кроме того, можно инициализировать статический указатель локальной функции с адресом функции с **dllimport** атрибута. В C такое присваивание задает указатель на адрес преобразователя импорта библиотеки DLL (заглушки кода, передающей контроль функции), а не адрес функции. В C++ оно задает указатель на адрес функции. Пример:  
  
    ```cpp 
    __declspec( dllimport ) void func1( void );  
    __declspec( dllimport ) int i;  
  
    int *pi = &i;                             // Error in C  
    static void ( *pf )( void ) = &func1;     // Address of thunk in C,  
                                              // function in C++  
  
    void func2()  
    {  
       static int *pi = &i;                  // Error in C  
       static void ( *pf )( void ) = &func1; // Address of thunk in C,  
                                             // function in C++  
    }  
    ```  
  
     Тем не менее поскольку программа с **dllexport** атрибутом в объявлении объекта должна содержать определение для этого объекта где-нибудь в программе, можно инициализировать указатель на глобальную или локальную статическую функцию с адрес **dllexport** функции. Аналогичным образом, можно инициализировать указатель на глобальные или локальные статические данные с адресом **dllexport** объекта данных. Например, следующий код не создает ошибки в C или C++:  
  
    ```cpp 
    __declspec( dllexport ) void func1( void );  
    __declspec( dllexport ) int i;  
  
    int *pi = &i;                              // Okay  
    static void ( *pf )( void ) = &func1;      // Okay  
  
    void func2()  
    {  
        static int *pi = &i;                   // Okay  
        static void ( *pf )( void ) = &func1;  // Okay  
    }  
    ```  
  
-   Если применить **dllexport** к регулярному классу, который имеет базовый класс, который не помечен как **dllexport**, компилятор создает ошибку C4275.  
  
     Компилятор создает то же самое предупреждение, если базовый класс является специализацией шаблона классов. Чтобы обойти эту проблему, пометьте базовый класс с **dllexport**. Проблема при специализации шаблона класса является размещение **__declspec(dllexport)**; помечать шаблон классов не разрешено. Вместо этого явно создать экземпляр шаблона классов и пометить это явное создание экземпляра с **dllexport**. Пример:  
  
    ```cpp 
    template class __declspec(dllexport) B<int>;  
    class __declspec(dllexport) D : public B<int> {  
    // ...  
    ```  
  
     Этот обходной путь завершается сбоем, если аргумент шаблона — это производный класс. Пример:  
  
    ```cpp 
    class __declspec(dllexport) D : public B<D> {  
    // ...  
    ```  
  
     Поскольку это общая схема для шаблонов, компилятор изменил семантику **dllexport** при его применении к классу, который имеет один или несколько базовых классов, и если один или несколько базовых классов является специализацией шаблона класса . В этом случае компилятор неявно применяет **dllexport** для специализаций шаблонов классов. Можно выполнить следующие и не получить предупреждение:  
  
    ```cpp 
    class __declspec(dllexport) D : public B<D> {  
    // ...  
    ```  
  
**Завершение блока, относящегося только к системам Майкрософт**  
  
## <a name="see-also"></a>См. также  
 [dllexport, dllimport](../cpp/dllexport-dllimport.md)