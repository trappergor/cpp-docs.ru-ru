---
title: Общие правила и ограничения
ms.date: 11/04/2016
ms.assetid: 6c48902d-4259-4761-95d4-e421d69aa050
ms.openlocfilehash: 8d21f627f461dce90af93ca5c1af8c4a28098539
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87213415"
---
# <a name="general-rules-and-limitations"></a>Общие правила и ограничения

**Блок, относящийся только к системам Microsoft**

- При объявлении функции или объекта без **`dllimport`** **`dllexport`** атрибута или функция или объект не считаются частью интерфейса DLL. Поэтому объявление функции или объекта должно находиться в том же самом модуле или в другом модуле той же программы. Чтобы сделать функцию или объект частью интерфейса DLL, необходимо объявить определение функции или объекта в другом модуле как **`dllexport`** . В противном случае возникает ошибка компоновщика.

   Если объявить функцию или объект с **`dllexport`** атрибутом, его определение должно появиться в некоторых модулях той же программы. В противном случае возникает ошибка компоновщика.

- Если один модуль в программе содержит **`dllimport`** и объявления, и **`dllexport`** для одной и той же функции или объекта, **`dllexport`** атрибут имеет приоритет над **`dllimport`** атрибутом. Однако компилятор создает предупреждение. Пример:

    ```cpp
    __declspec( dllimport ) int i;
    __declspec( dllexport ) int i;   // Warning; inconsistent;
                                     // dllexport takes precedence.
    ```

- В C++ можно инициализировать глобально объявленный или статический указатель локальных данных или адрес объекта данных, объявленного с помощью **`dllimport`** атрибута, что приводит к ошибке в C. Кроме того, можно инициализировать статический указатель локальной функции с адресом функции, объявленной с помощью **`dllimport`** атрибута. В C такое присваивание задает указатель на адрес преобразователя импорта библиотеки DLL (заглушки кода, передающей контроль функции), а не адрес функции. В C++ оно задает указатель на адрес функции. Пример:

    ```cpp
    __declspec( dllimport ) void func1( void );
    __declspec( dllimport ) int i;

    int *pi = &i;                             // Error in C
    static void ( *pf )( void ) = &func1;     // Address of thunk in C,
                                              // function in C++

    void func2()
    {
       static int *pi = &i;                  // Error in C
       static void ( *pf )( void ) = &func1; // Address of thunk in C,
                                             // function in C++
    }
    ```

   Однако поскольку программа, включающая **`dllexport`** атрибут в объявлении объекта, должна предоставлять определение для этого объекта в программе, можно инициализировать глобальный или локальный указатель на статическую функцию с адресом **`dllexport`** функции. Аналогичным образом можно инициализировать глобальный или локальный указатель на статические данные с адресом **`dllexport`** объекта данных. Например, следующий код не создает ошибки в C или C++:

    ```cpp
    __declspec( dllexport ) void func1( void );
    __declspec( dllexport ) int i;

    int *pi = &i;                              // Okay
    static void ( *pf )( void ) = &func1;      // Okay

    void func2()
    {
        static int *pi = &i;                   // Okay
        static void ( *pf )( void ) = &func1;  // Okay
    }
    ```

- Если применить **`dllexport`** к обычному классу с базовым классом, который не помечен как **`dllexport`** , компилятор создаст C4275.

   Компилятор создает то же самое предупреждение, если базовый класс является специализацией шаблона классов. Чтобы обойти это, пометьте базовый класс на **`dllexport`** . Проблема с специализацией шаблона класса — место для размещения **`__declspec(dllexport)`** ; вы не можете помечать шаблон класса. Вместо этого следует явно создать экземпляр шаблона класса и пометить это явное создание экземпляра с помощью **`dllexport`** . Пример:

    ```cpp
    template class __declspec(dllexport) B<int>;
    class __declspec(dllexport) D : public B<int> {
    // ...
    ```

   Этот обходной путь завершается сбоем, если аргумент шаблона — это производный класс. Пример:

    ```cpp
    class __declspec(dllexport) D : public B<D> {
    // ...
    ```

   Поскольку это распространенный шаблон с шаблонами, компилятор изменил семантику **`dllexport`** при применении к классу с одним или несколькими базовыми классами и когда один или несколько базовых классов являются специализацией шаблона класса. В этом случае компилятор неявно применяется **`dllexport`** к специализациям шаблонов классов. Вы можете выполнять следующие действия и не получать предупреждения:

    ```cpp
    class __declspec(dllexport) D : public B<D> {
    // ...
    ```

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[dllexport, dllimport](../cpp/dllexport-dllimport.md)
