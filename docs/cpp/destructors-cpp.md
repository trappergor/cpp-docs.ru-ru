---
title: Деструкторы (C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- objects [C++], destroying
- Visual C++, destructors
- destroying objects, destructors
- ~ operator [C++], specifying destructors
- destructors, about destructors
- destructors, C++
ms.assetid: afa859b0-f3bc-4c4d-b250-c68b335b6004
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: ae1ca6923bc7e67218e35c5a6c86b9f4ac112e59
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="destructors-c"></a>Деструкторы (C++)
Деструктор является функцией-членом, который вызывается автоматически, когда объект выходит за пределы области или удаляется явным образом с помощью вызова `delete`. Деструктор имеет то же имя, как класс, который предшествует знак тильды (`~`). Например, деструктор для класса `String` объявляется следующим образом: `~String()`. Если деструктор не определена, компилятор будет предоставлять значение по умолчанию. для многих классов этого достаточно. Необходимо определить пользовательский деструктор при класса хранит указатели на системные ресурсы, которые необходимо освободить, или указатели, которыми владеют память они указывают.

Рассмотрим следующее объявление класса `String`:  
  
```  
// spec1_destructors.cpp  
#include <string.h>  
  
class String {  
public:  
   String( char *ch );  // Declare constructor  
   ~String();           //  and destructor.  
private:  
   char    *_text;  
   size_t  sizeOfText;  
};  
  
// Define the constructor.  
String::String( char *ch ) {  
   sizeOfText = strlen( ch ) + 1;  
  
   // Dynamically allocate the correct amount of memory.  
   _text = new char[ sizeOfText ];  
  
   // If the allocation succeeds, copy the initialization string.  
   if( _text )  
      strcpy_s( _text, sizeOfText, ch );  
}  
  
// Define the destructor.  
String::~String() {  
   // Deallocate the memory that was previously reserved  
   //  for this string.  
   if (_text)  
      delete[] _text;  
}  
  
int main() {  
   String str("The piper in the glen...");  
}  
```  
  
 В приведенном выше примере в деструкторе `String::~String` используется оператор `delete`, который отменяет выделение пространства, динамически выделенного для хранения текста.  
  
## <a name="declaring-destructors"></a>Объявление деструкторов  
 Деструкторы — это функции с тем же именем, что и класс, но с добавленным в начало знаком тильды (`~`).  
  
 При объявлении деструкторов действуют несколько правил. Деструкторы:  
  
-   Не могут иметь аргументов.  
  
-   Возвращает значение (или `void`).  
  
-   Не могут объявляться как **const**, `volatile`, или **статических**. Тем не менее, их можно вызывать и уничтожения объектов, объявленных как **const**, `volatile`, или **статических**.  
  
-   Могут быть объявлены как **виртуальный**. Используя виртуальные деструкторы, можно уничтожать объекты, не зная их тип — правильный деструктор для объекта вызывается с помощью механизма виртуальных функций. Обратите внимание, что для абстрактных классов деструкторы также могут объявляться как чисто виртуальные функции.  
  
## <a name="using-destructors"></a>Использование деструкторов  
 Деструкторы вызываются, когда происходит одно из следующих событий:  

-   Локальный (автоматический) объект с областью видимости блока выходит за пределы области видимости.  

-   Объект, выделенный с помощью **новый** оператор явно освободить с использованием **удалить**.   
  
-   Время существования временного объекта заканчивается.  
  
-   Программа заканчивается, глобальные или статические объекты продолжают существовать.  
  
-   Деструктор явно вызываться с использованием полного имени функции деструктора.
  
 Деструкторы могут свободно вызывать функции-члена класса и осуществлять доступ к данным членов класса.
  
 Существует два ограничения на использование деструкторов.
 - не удается получить его адрес
-  производные классы не наследуют деструктор базового класса.
  
## <a name="order-of-destruction"></a>Порядок уничтожения  
 Когда объект выходит за пределы области или удаляется, последовательность событий при его полном уничтожении выглядит следующим образом:  
  
1.  Вызывается деструктор класса, и выполняется тело функции деструктора.  
  
2.  Деструкторы для объектов нестатических членов вызываются в порядке, обратном порядку их появления в объявлении класса. Необязательный список инициализации членов используется в создании этих членов не влияет на порядок построения или удаления.   
  
3.  Деструкторы для невиртуальных базовых классов вызываются в порядке, обратном порядку их объявления.  
  
4.  Деструкторы для виртуальных базовых классов вызываются в порядке, обратном порядку их объявления.  
  
```  
// order_of_destruction.cpp  
#include <stdio.h>  
  
struct A1      { virtual ~A1() { printf("A1 dtor\n"); } };  
struct A2 : A1 { virtual ~A2() { printf("A2 dtor\n"); } };  
struct A3 : A2 { virtual ~A3() { printf("A3 dtor\n"); } };  
  
struct B1      { ~B1() { printf("B1 dtor\n"); } };  
struct B2 : B1 { ~B2() { printf("B2 dtor\n"); } };  
struct B3 : B2 { ~B3() { printf("B3 dtor\n"); } };  
  
int main() {  
   A1 * a = new A3;  
   delete a;  
   printf("\n");  
  
   B1 * b = new B3;  
   delete b;  
   printf("\n");  
  
   B3 * b2 = new B3;  
   delete b2;  
}  
  
Output: A3 dtor  
A2 dtor  
A1 dtor  
  
B1 dtor  
  
B3 dtor  
B2 dtor  
B1 dtor  
  
```  
  
### <a name="virtual-base-classes"></a>Виртуальные базовые классы  
 Деструкторы для виртуальных базовых классов вызываются в порядке, обратном их указанию в направленном ациклическом графе (в глубину, слева направо, обход в обратном порядке). На следующем рисунке представлен граф наследования.  
  
 ![Граф наследования, показывающий виртуальные базовые классы](../cpp/media/vc392j1.gif "vc392J1")  
Граф наследования, представляющий виртуальные базовые классы  
  
 Ниже перечислены заголовки классов, представленных на рисунке.  
  
```  
class A  
class B  
class C : virtual public A, virtual public B  
class D : virtual public A, virtual public B  
class E : public C, public D, virtual public B  
```  
  
 Чтобы определить порядок удаления виртуальных базовых классов объекта типа `E`, компилятор выполняет сборку списка, применяя следующий алгоритм.  
  
1.  Просмотрите левую часть графа, начиная с самой глубокой точки графа (в данном случае `E`).  
  
2.  Просматривайте граф справа налево, пока не будут пройдены все узлы. Запомните имя текущего узла.  
  
3.  Пересмотрите предыдущий узел (вниз и вправо), чтобы определить, является ли рассматриваемый узел виртуальным базовым классом.  
  
4.  Если рассматриваемый узел является виртуальным базовым классом, просмотрите список, чтобы проверить, был ли он введен ранее. Если он не является виртуальным базовым классом, игнорируйте его.  
  
5.  Если рассматриваемого узла еще нет в списке, добавьте его вниз списка.  
  
6.  Просмотрите граф вверх и вдоль следующего пути вправо.  
  
7.  Перейдите к шагу 2.  
  
8.  Если путь последний путь вверх исчерпан, запомните имя текущего узла.  
  
9. Перейдите к шагу 3.  
  
10. Выполняйте этот процесс, пока нижний узел снова не станет текущим узлом.  
  
 Таким образом, для класса `E` порядок удаления будет следующим.  
  
1.  Невиртуальный базовый класс `E`.  
  
2.  Невиртуальный базовый класс `D`.  
  
3.  Невиртуальный базовый класс `C`.  
  
4.  Виртуальный базовый класс `B`.  
  
5.  Виртуальный базовый класс `A`.  
  
 В ходе этого процесса создается упорядоченный список уникальных записей. Имя класса никогда не отображается дважды. После создания список просматривается в обратном порядке, и вызывается деструктор для каждого класса в списке от последнего к первому.  
  
 Порядок построения или удаления очень важен, когда конструкторы и деструкторы в одном классе полагаются на другой компонент, который создается первым или сохраняется дольше, например если деструктор `A` (на рисунке выше) полагается на то, что `B` будет по-прежнему присутствовать после выполнения кода, или наоборот.  
  
 Такие взаимозависимости между классами в графе наследования опасны, поскольку классы, наследуемые впоследствии, могут изменить крайний левый путь, тем самым изменив порядок построения и удаления.  
  
### <a name="nonvirtual-base-classes"></a>Невиртуальные базовые классы  
 Деструкторы для невиртуальных базовых классов вызываются в порядке, обратном объявлению имен базовых классов. Рассмотрим следующее объявление класса.  
  
```  
class MultInherit : public Base1, public Base2  
...  
```  
  
 В предыдущем примере деструктор `Base2` вызывается перед деструктором `Base1`.  
  
## <a name="explicit-destructor-calls"></a>Явные вызовы деструктора  
 Редко возникает необходимость в явном вызове деструктора. Однако может быть полезно выполнить удаление объектов, размещенных по абсолютным адресам. Эти объекты часто предоставляются с использованием определяемых пользователем **новый** оператор, который принимает аргумент размещения. **Удаление** оператор не может освободить эту память, так как она не предоставляется из свободного хранилища (Дополнительные сведения см. в разделе [новый и удаление операторов](../cpp/new-and-delete-operators.md)). Вызов деструктора, однако, может выполнить соответствующую очистку. Для явного вызова деструктора для объекта (`s`) класса `String` воспользуйтесь одним из следующих операторов.  
  
```  
s.String::~String();     // Nonvirtual call  
ps->String::~String();   // Nonvirtual call  
  
s.~String();       // Virtual call  
ps->~String();     // Virtual call  
```  
  
 Нотация для явных вызовов деструкторов, показанная в предыдущем примере, может использоваться независимо от того, определяет ли тип деструктор. Это позволяет выполнять такие явные вызовы, не зная, определен ли деструктор для типа. Явный вызов деструктора, если ни один из них не определен, не имеет никакого эффекта.  
