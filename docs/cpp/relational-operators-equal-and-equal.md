---
title: 'Операторы отношения: &lt;, &gt;, &lt;=, и &gt;= | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
f1_keywords:
- <
- '>'
dev_langs:
- C++
helpviewer_keywords:
- '> operator'
- less than operator
- relational operators [C++], syntax
- '>= operator'
- greater than or equal to operators [C++]
- greater than operators [C++]
- < operator
- less than or equal to operator
- <= operator
ms.assetid: d346b53d-f14d-4962-984f-89d39a17ca0f
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 7d9c51036b183e2368def19dcd70f804acc2826a
ms.sourcegitcommit: 913c3bf23937b64b90ac05181fdff3df947d9f1c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2018
ms.locfileid: "46081615"
---
# <a name="relational-operators-lt-gt-lt-and-gt"></a>Операторы отношения: &lt;, &gt;, &lt;=, и &gt;=

## <a name="syntax"></a>Синтаксис

```
expression < expression
expression > expression
expression <= expression
expression >= expression
```

## <a name="remarks"></a>Примечания

Бинарные операторы отношения определяют следующие отношения:

- Меньше (**\<**)

- Больше, чем (**>**)

- Меньше или равно (**\<=**)

- Больше или равно (**>=**)

Операторы отношения обладают ассоциативностью слева направо. Оба операнда операторов отношения должны быть арифметического типа или типа указателя. Они возвращают значения типа **bool**. Возвращаемое значение — **false** (0), если отношение в выражении — false; в противном случае — значение, возвращаемое значение **true** (1).

## <a name="example"></a>Пример

```cpp
// expre_Relational_Operators.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;

int main() {
   cout  << "The true expression 3 > 2 yields: "
         << (3 > 2) << endl
         << "The false expression 20 < 10 yields: "
         << (20 < 10) << endl;
}
```

Выражения в предыдущем примере должны заключаться в круглые скобки, поскольку оператор вставки потока (**<<**) имеет более высокий приоритет, чем операторы отношения. Поэтому первое выражение без скобок вычислялось бы следующим образом:

```cpp
(cout << "The true expression 3 > 2 yields: " << 3) < (2 << "\n");
```

Обычные арифметические преобразования, описанные в [стандартные преобразования](standard-conversions.md) применяются к операндам арифметических типов.

## <a name="comparing-pointers"></a>Сравнение указателей

При сравнении двух указателей на объекты одного типа результат определяется расположением объектов, указываемых в адресном пространстве программы. Указатели также можно можно сравнить с константным выражением, результатом является значение 0 или с указателем типа `void *`. Если указатель сравнивается с указателем типа `void *`, другой указатель неявно преобразуется в тип `void *`. Затем выполняется сравнение.

Два указателя разных типов можно сравнивать, только если выполняются следующие условия.

- Один тип является типом класса, производным от другого типа.

- По крайней мере один указатель явно преобразован (приведен) в тип `void *`. (Другой указатель неявно преобразуется в тип `void *` для преобразования.)

Гарантируется, что два указателя одного типа, указывающие на один и тот же объект, равны. Если сравнивается два указателя на нестатические члены объекта, применяются следующие правила.

- Если тип класса не **объединение**, и если два члена не разделены *спецификатор доступа*, такие как **открытый**, **защищенные**, или **частных**, указатель на член, объявленный последнего сравнит больше указателя на член, объявленный ранее.

- Если два члена разделены *спецификатор доступа*, результаты не определены.

- Если тип класса является **объединение**, указатели на разные члены данных тем, что **объединение** равны при сравнении.

Если два указателя указывают на элементы одного массива или на элемент, находящийся за пределами массива, большим является указатель на объект с более высоким нижним индексом. Сравнение указателей гарантированно является допустимым, только если указатели ссылаются на объекты в одном массиве или на расположение объекта после конца массива.

## <a name="see-also"></a>См. также

[Выражения с бинарными операторами](../cpp/expressions-with-binary-operators.md)<br/>
[Встроенные операторы C++, приоритет и ассоциативность](../cpp/cpp-built-in-operators-precedence-and-associativity.md)<br/>
[Операторы отношения и равенства C](../c-language/c-relational-and-equality-operators.md)