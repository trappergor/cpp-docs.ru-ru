---
title: Добро пожаловать назад в C++ (современный C++) | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 1cb1b849-ed9c-4721-a972-fd8f3dab42e2
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 63e73657c7e018d2a4eb71170561e310aeba9d5b
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32424871"
---
# <a name="welcome-back-to-c-modern-c"></a>Возвращение к C++ (современный C++)
C++ является одним из наиболее широко используемых языков программирования в мире. Грамотно сконструированные программы на языках C++ быстры и эффективны. Язык является более гибким, чем другие языки, поскольку его можно использовать для создания широкого спектра приложений — от интересных и ярких игр до высокопроизводительного научного программного обеспечения и драйверов устройств, внедренных приложений и клиентских приложений Windows. Более 20 лет C++ используется для решения подобных и многих других задач. Возможно, вы не знаете, что все больше программистов С++ отказались от программирования вчерашнего дня в C-стиле и перешли к современной модели программирования С++.  
  
 Одно из начальных требований для C++ — обратная совместимость с языком C. С этого момента язык C++ эволюционировал через несколько итераций — C с классами, исходная спецификация языка C++ и множество последовательных усовершенствований. Из-за этого наследия C++ часто называют мультипарадигматическим языком программирования. В C++ доступны чисто процедурное программирование в C-стиле, которое содержит необработанные указатели, массивы, строки с конечным символом null, пользовательские структуры данных и другие компоненты, которые могут обеспечить высокую производительность или стать причиной ошибок и чрезмерной сложности кода.  Поскольку программирование в стиле языка C чревато подобными опасностями, одной из основных целей создания C++ было сделать программы как типобезопасными, так и более простыми в написании, расширении и сопровождении. Уже на ранних этапах развития в языке C++ были полностью реализованы такие парадигмы программирования, как объектно-ориентированное программирование. С годами к этому языку были добавлены функции и стандартные библиотеки структур данных и алгоритмов, прошедшие тщательное тестирование. Именно благодаря этим дополнениям появился и существует современный стиль C++.  
  
 Современный язык C++ обеспечивает следующие возможности:  
  
-   Область стека вместо кучи или статической глобальной области.  
  
-   Автоматическое определение типа вместо явных имен типов.  
  
-   Интеллектуальные указатели вместо необработанных указателей.  
  
-   `std::string` и `std::wstring` типы (в разделе [ \<строка >](../standard-library/string.md)) вместо необработанных `char[]` массивов.  
  
-   [Стандартная библиотека C++](../standard-library/cpp-standard-library-header-files.md) такие контейнеры как `vector`, `list`, и `map` а не необработанные массивы пользовательских контейнеров. В разделе [ \<вектор >](../standard-library/vector.md), [ \<списка >](../standard-library/list.md), и [ \<карты >](../standard-library/map.md).  
  
-   Стандартная библиотека C++ [алгоритмы](../standard-library/algorithm.md) вместо закодированных вручную.  
  
-   Исключения для сообщения о состояниях ошибки и их обработки.  
  
-   Взаимодействие между потоками, с использованием стандартной библиотеки C++ без блокировки `std::atomic<>` (см. [ \<atomic >](../standard-library/atomic.md)) вместо другие механизмы взаимодействия между потоками.  
  
-   Встроенная [лямбда-функции](../cpp/lambda-expressions-in-cpp.md) вместо небольших функций, реализованных отдельно.  
  
-   На основе диапазонов циклы для создания более надежных циклов, работающие с массивами, контейнеры стандартной библиотеки C++ и среды выполнения Windows коллекции в виде `for ( for-range-declaration : expression )`. Это часть базовой языковой поддержки. Дополнительные сведения см. в разделе [инструкции (C++) на основе диапазонов](../cpp/range-based-for-statement-cpp.md).  
  
 Сам язык C++ также развивался. Сравните следующие фрагменты кода. Этот фрагмент показывает, как обстояли дела в C++ раньше:  
  
```cpp  

#include <vector>

void f()
{
    // Assume circle and shape are user-defined types  
    circle* p = new circle( 42 );   
    vector<shape*> v = load_shapes();  

    for( vector<circle*>::iterator i = v.begin(); i != v.end(); ++i ) {  
        if( *i && **i == *p )  
            cout << **i << " is a match\n";  
    }  

    // CAUTION: If v's pointers own the objects, then you
    // must delete them all before v goes out of scope.
    // If v's pointers do not own the objects, and you delete
    // them here, any code that tries to dereference copies
    // of the pointers will cause null pointer exceptions.
    for( vector<circle*>::iterator i = v.begin();  
            i != v.end(); ++i ) {  
        delete *i; // not exception safe  
    }  

    // Don't forget to delete this, too.  
    delete p;  
} // end f()
```

 А этот фрагмент показывает, как та же задача решается в C++ сейчас:  
  
```cpp

#include <memory>  
#include <vector>  

void f()
{
    // ...  
    auto p = make_shared<circle>( 42 );  
    vector<shared_ptr<shape>> v = load_shapes();  

    for( auto& s : v ) 
    {  
        if( s && *s == *p )
        {
            cout << *s << " is a match\n";
        }
    }
}

```

 В современном C++ не следует использовать операторы new и delete или явную обработку исключений, поскольку вместо этого можно использовать интеллектуальные указатели. При использовании `auto` выведение и [лямбда-функцию](../cpp/lambda-expressions-in-cpp.md), можно написать код быстрее, сделать и лучше понять ее. И на основе диапазона `for` цикл очистки, проще в использовании и менее подвержен непреднамеренным ошибкам, чем в стиле `for` цикла. Можно использовать для написания приложения стандартный текст и минимум строк кода. Кроме того, этот код можно сделать безопасным в отношении исключений и в отношении памяти, исключая необходимости обрабатывать выделение и освобождение или коды ошибок.  
  
 Современный C++ включает два типа полиморфизма: во время компиляции, с помощью шаблонов, и в среде выполнения, путем наследования и виртуализации. В целях повышения эффективности можно объединить два типа полиморфизма. Шаблон Стандартная библиотека C++ `shared_ptr` использует внутренние виртуальные методы для выполнения его удалений без усилий. Однако не злоупотребляйте виртуализацией для полиморфизма, если лучше использовать шаблон. Шаблоны могут быть очень мощными.  
  
 Если вы начинаете работать с С++ после другого языка, особенно после управляемого языка, в котором большинство типов — ссылочные типы, и лишь немногие — типы значений, знайте, что классы С++ — это типы значений по умолчанию. Однако можно указывать их как ссылочные типы для получения полиморфного поведения, которое соответствует концепции объектно-ориентированного программирования. Удобно представлять это себе так: типы значений относятся, скорее, к управлению памятью и макетом, ссылочные типы относятся, скорее, к базовым классам и виртуальным функциям для поддержки полиморфизма. По умолчанию типы значений являются копируемыми — каждый из них имеет конструктор копии и оператор присваивания копированием. При определении ссылочного типа сделайте класс недоступным для копирования, отключив конструктор копий или оператор назначения копирования и воспользовавшись виртуальным деструктором, поддерживающим полиморфизм. Типы значений также связаны с содержимым, то есть, если они копируются, необходимо предоставить два независимых значения, которые можно изменить по отдельности. Однако ссылочные типы, скорее, связаны с идентификацией — какой это объект — и иногда из-за этого называются полиморфными типами.  
  
 C++ переживает возрождение, потому что мощность снова становится приоритетом. Языки, например Java и C#, хорошо подходят, если важна продуктивность программиста, однако как только речь заходит о мощности и производительности, становятся очевидными их ограничения. Для повышения эффективности и мощности, особенно для устройств с ограниченным оборудованием, ничто не подходит лучше, чем современный С++.  
  
 Современен не только язык, но и средства разработки. [!INCLUDE[vsprvs](../assembler/masm/includes/vsprvs_md.md)] делает все части цикла разработки надежными и эффективными. Он включает средства управления жизненным циклом приложения (ALM), усовершенствования интегрированной среды разработки, такие как IntelliSense, совместимые со средствами механизмы, такие как XAML, а также сборки, отладки и многие другие средства.  
  
 Статьи в этом разделе документации содержат общие правила и рекомендации по наиболее важным возможностям и методам для записи современных программ на языке C++.  
  
-   [Тип системы C++](../cpp/cpp-type-system-modern-cpp.md)  
  
-   [Единообразная инициализация и делегирование конструкторов](../cpp/uniform-initialization-and-delegating-constructors.md)  
  
-   [Время жизни объекта и управление ресурсами](../cpp/object-lifetime-and-resource-management-modern-cpp.md)  
  
-   [Собственные ресурсы объекта (RAII)](../cpp/objects-own-resources-raii.md)  
  
-   [Интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md)  
  
-   [Pimpl для инкапсуляции времени компиляции](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md)  
  
-   [Контейнеры](../cpp/containers-modern-cpp.md)  
  
-   [Алгоритмы](../cpp/algorithms-modern-cpp.md)  
  
-   [Строки и ввода-вывода, форматирование (современный C++)](../cpp/string-and-i-o-formatting-modern-cpp.md)  
  
-   [Обработка ошибок и исключений](../cpp/errors-and-exception-handling-modern-cpp.md)  
  
-   [Переносимость на границах API](../cpp/portability-at-abi-boundaries-modern-cpp.md)  
  
 Дополнительные сведения см. в статье StackOverflow [какие идиомы C++ рекомендуется использовать в C ++ 11](http://go.microsoft.com/fwlink/p/?linkid=402836)  
  
## <a name="see-also"></a>См. также  
 [Справочник по языку C++](../cpp/cpp-language-reference.md)   
 [Лямбда-выражения](../cpp/lambda-expressions-in-cpp.md)   
 [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)  
 [Соответствие стандартам языка Visual C++](../visual-cpp-language-conformance.md)  
