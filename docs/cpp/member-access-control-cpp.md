---
title: "Управление доступом к членам (C++) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "language-reference"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "управление доступом [C++]"
  - "доступ к членам [C++]"
  - "управление доступом к членам [C++]"
ms.assetid: 2d596bca-56ad-4277-94e1-ce3db45fa14a
caps.latest.revision: 9
caps.handback.revision: 9
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Управление доступом к членам (C++)
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

Управление доступом позволяет отделить [открытый](../cpp/public-cpp.md) интерфейс класса от [закрытых](../Topic/private%20\(C++\).md) деталей реализации и [защищенных](../Topic/protected%20\(C++\).md) членов, предназначенных для использования только производными классами.  Спецификатор доступа действует для всех членов, объявленных после него, пока не будет объявлен следующий спецификатор доступа.  
  
```  
class Point  
{  
public:                   
    Point( int, int ) // Declare public constructor.;  
    Point();// Declare public default constructor.  
    int &x( int ); // Declare public accessor.  
    int &y( int ); // Declare public accessor.  
  
private:                 // Declare private state variables.  
    int _x;  
    int _y;  
  
protected:      // Declare protected function for derived classes only.  
    Point ToWindowCoords();  
};  
  
```  
  
 Уровень доступа по умолчанию для класса — `private`, для структуры и объединения — `public`.  Спецификаторы доступа класса могут использоваться любое количество раз и в любом порядке.  Выделение хранилища для объектов типов классов зависит от реализации, но членам гарантировано присваиваются старшие адреса памяти, расположенные подряд между описателями доступа.  
  
### Управление доступом к членам  
  
|Тип доступа|Значение|  
|-----------------|--------------|  
|[private](../Topic/private%20\(C++\).md)|Члены класса, объявленные как `private`, могут использоваться только функциями\-членами и дружественными функциями \(классы и функции\) класса.|  
|[protected](../Topic/protected%20\(C++\).md)|Члены класса, объявленные как `protected`, могут использоваться функциями\-членами и дружественными функциями \(классы и функции\) класса.  Кроме того, они могут использоваться производными классами данного класса.|  
|[public](../cpp/public-cpp.md)|Члены класса, объявленные как **public**, могут использоваться любой функцией.|  
  
 Управление доступом помогает предотвратить использование объектов в неправомерных целях.  Такая защита теряется при выполнении явных преобразований типов \(приведении типов\).  
  
> [!NOTE]
>  Управление доступом одинаково применимо ко всем именам: функциям\-членам, данным члена, вложенным классам и перечислителям.  
  
## Управление доступом в производном классе  
 Доступность в производном классе членов базового класса и унаследованных членов определяется двумя следующими факторами.  
  
-   Объявляется ли базовый класс производным классом с помощью спецификатора **открытого** доступа в *заголовке\-класса* \(описание *заголовка\-класса* см. в подразделе "Грамматика" раздела [Определение типов классов](http://msdn.microsoft.com/ru-ru/e8c65425-0f3a-4dca-afc2-418c3b1e57da)\).  
  
-   Какой доступ к членам предоставляется в базовом классе.  
  
 В следующей таблице показана взаимосвязь между этими факторами и определен доступ к членам в базовом классе.  
  
### Доступ к членам в базовом классе  
  
|private|protected|Открытый|  
|-------------|---------------|--------------|  
|Всегда отсутствует независимо от доступа при наследовании|Закрытый в производном классе при использовании закрытого наследования|Закрытый в производном классе при использовании закрытого наследования|  
||Защищенный в производном классе при использовании защищенного наследования|Защищенный в производном классе при использовании защищенного наследования|  
||Защищенный в производном классе при использовании открытого наследования|Открытый в производном классе при использовании открытого наследования|  
  
 Это показано в приведенном ниже примере.  
  
```  
// access_specifiers_for_base_classes.cpp  
class BaseClass  
{  
public:  
    int PublicFunc();    // Declare a public member.  
protected:  
    int ProtectedFunc(); // Declare a protected member.  
private:  
    int PrivateFunc();   // Declare a private member.  
};  
  
// Declare two classes derived from BaseClass.  
class DerivedClass1 : public BaseClass  
{  
};  
  
class DerivedClass2 : private BaseClass  
{  
};  
  
int main()  
{  
}  
```  
  
 В классе `DerivedClass1` функция\-член `PublicFunc` является открытым членом, а функция `ProtectedFunc` — защищенным членом, поскольку `BaseClass` — открытый базовый класс.  Функция `PrivateFunc` закрыта для класса `BaseClass` и не доступна всем производным классам.  
  
 В классе `DerivedClass2` функции `PublicFunc` и `ProtectedFunc` считаются закрытыми членами, поскольку `BaseClass` — закрытый базовый класс.  Функция `PrivateFunc` снова закрыта для класса `BaseClass` и не доступна всем производным классам.  
  
 Производный класс можно объявить без спецификатора доступа базового класса.  Если в этом случае в объявлении производного класса используется ключевое слово **class**, наследование считается закрытым.  Если в объявлении производного класса используется ключевое слово `struct`, наследование считается открытым.  Например, приведенный ниже код  
  
```  
class Derived : Base  
...  
```  
  
 эквивалентно выражению:  
  
```  
class Derived : private Base  
...  
```  
  
 Аналогично код  
  
```  
struct Derived : Base  
...  
```  
  
 эквивалентно выражению:  
  
```  
struct Derived : public Base  
...  
```  
  
 Обратите внимание, что члены, объявленные как имеющие закрытый доступ, не доступны функциям и производным классам, если эти функции и классы не объявлены в базовом классе с помощью объявления `friend`.  
  
 Тип **union** не может иметь базовый класс.  
  
> [!NOTE]
>  При задании закрытого базового класса целесообразно явно использовать ключевое слово `private`, чтобы пользователи производного класса понимали доступ к членам.  
  
## Управление доступом и статические члены  
 При определении базового класса в качестве `private` это влияет только на нестатические члены.  Открытые статические члены по\-прежнему доступны в производных классах.  Однако доступ к членам базового класса с помощью указателей, ссылок и объектов может потребовать преобразования, а во время выполнения управление доступом применяется снова.  Рассмотрим следующий пример.  
  
```  
// access_control.cpp  
class Base  
{  
public:  
    int Print();             // Nonstatic member.  
    static int CountOf();    // Static member.  
};  
  
// Derived1 declares Base as a private base class.  
class Derived1 : private Base  
{  
};  
// Derived2 declares Derived1 as a public base class.  
class Derived2 : public Derived1  
{  
    int ShowCount();    // Nonstatic member.  
};  
// Define ShowCount function for Derived2.  
int Derived2::ShowCount()  
{  
   // Call static member function CountOf explicitly.  
    int cCount = Base::CountOf();     // OK.  
  
   // Call static member function CountOf using pointer.  
    cCount = this->CountOf();  // C2247. Conversion of  
                               //  Derived2 * to Base * not  
                               //  permitted.  
    return cCount;  
}  
```  
  
 В предыдущем примере кода управление доступом запрещает преобразование указателя на `Derived2` к указателю на `Base`.  **Этот** указатель неявно имеет тип `Derived2 *`.  Чтобы выделить функцию `CountOf`, **его** необходимо преобразовать в тип `Base *`.  Такое преобразование не поддерживается, поскольку `Base` — это закрытый косвенный базовый класс в `Derived2`.  Преобразование к типу закрытого базового класса применимо только для указателей на непосредственные производные классы.  Поэтому указатели типа `Derived1 *` можно преобразовать к типу `Base *`.  
  
 Обратите внимание, что при явном вызове функции `CountOf` без использования указателя, ссылки или объекта для выделения этой функции, преобразование не выполняется.  Поэтому вызов разрешен.  
  
 Члены и дружественные функции производного класса, `T`, могут преобразовать указатель на `T` в указатель на частный прямой базовый класс `T`.  
  
## Доступ к виртуальным функциям  
 Управление доступом, применяемое для [виртуальных](../cpp/virtual-cpp.md) функций, определяется типом, используемым для вызова функции.  Переопределение объявлений функции не влияет на управление доступом для данного типа.  Пример:  
  
```  
// access_to_virtual_functions.cpp  
class VFuncBase  
{  
public:  
    virtual int GetState() { return _state; }  
protected:  
    int _state;  
};  
  
class VFuncDerived : public VFuncBase  
{  
private:  
    int GetState() { return _state; }  
};  
  
int main()  
{  
   VFuncDerived vfd;             // Object of derived type.  
   VFuncBase *pvfb = &vfd;       // Pointer to base type.  
   VFuncDerived *pvfd = &vfd;    // Pointer to derived type.  
   int State;  
  
   State = pvfb->GetState();     // GetState is public.  
   State = pvfd->GetState();     // C2248 error expected; GetState is private;  
}  
```  
  
 В приведенном выше примере вызов виртуальной функции `GetState` с помощью указателя на тип `VFuncBase` приводит к вызову функции `VFuncDerived::GetState`, и функция `GetState` обрабатывается как открытая.  Однако вызов `GetState` с помощью указателя на тип `VFuncDerived` нарушает правила управления доступом, поскольку функция `GetState` в классе `VFuncDerived` объявляется закрытой.  
  
> [!CAUTION]
>  Виртуальную функцию `GetState` можно вызвать с помощью указателя на базовый класс `VFuncBase`.  Это не означает, что вызываемая функция является версией базового класса данной функции.  
  
## Управление доступом с множественным наследованием  
 В решетках множественного наследования, в которых используются виртуальные базовые классы, к конкретным именам можно обращаться несколькими путями.  Поскольку в разных путях могут применяться разные средства управления доступом, компилятор выбирает тот путь, который позволяет получить наиболее широкий доступ.  См. следующий рисунок.  
  
 ![Доступ вдоль линий графа наследования](../cpp/media/vc38v91.png "vc38V91")  
Доступ по путям в графе наследования  
  
 На этом рисунке обращение к имени, которое было объявлено в классе `VBase`, всегда будет выполняться через класс `RightPath`.  Путь справа дает более широкий доступ, поскольку в `RightPath` класс `VBase` объявлен как общедоступный базовый, а в `LeftPath` класс `VBase` объявлен как закрытый.  
  
## См. также  
 [Справочник по языку C\+\+](../cpp/cpp-language-reference.md)