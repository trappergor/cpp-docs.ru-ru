---
title: поток
ms.date: 05/07/2019
f1_keywords:
- thread_cpp
helpviewer_keywords:
- thread local storage (TLS)
- thread __declspec keyword
- TLS (thread local storage), compiler implementation
- __declspec keyword [C++], thread
ms.assetid: 667f2a77-6d1f-4b41-bee8-05e67324fab8
ms.openlocfilehash: 13e6d45642c08a97c06d7099b83e632501267310
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87225817"
---
# <a name="thread"></a>поток

**Блок, относящийся только к системам Microsoft**

**`thread`** Расширенный модификатор класса хранения используется для объявления локальной переменной потока. Для переносимого эквивалента в C++ 11 и более поздних версиях используйте описатель класса хранения [thread_local](../cpp/storage-classes-cpp.md#thread_local) для переносимого кода. В Windows **`thread_local`** реализуется с помощью **`__declspec(thread)`** .

## <a name="syntax"></a>Синтаксис

**`__declspec(thread)`***декларатор*

## <a name="remarks"></a>Remarks

Локальное хранилище потока (TLS) — это механизм, с помощью которого в каждом потоке многопоточного процесса выделяется хранилище для хранения данных определенного потока. В стандартных многопоточных программах данные совместно используются всеми потоками заданного процесса, в то время как локальное хранилище потоков является механизмом предоставления данных для конкретного потока. Полное описание потоков см. в разделе [многопоточность](../parallel/multithreading-support-for-older-code-visual-cpp.md).

Объявления локальных переменных потока должны использовать [синтаксис расширенных атрибутов](../cpp/declspec.md) и **`__declspec`** ключевое слово с **`thread`** ключевым словом. В следующем примере кода показано, как объявлять целочисленную локальную переменную потока и инициализировать её некоторым значением:

```cpp
__declspec( thread ) int tls_i = 1;
```

При использовании локальных переменных потока в динамически загружаемых библиотеках необходимо иметь в виду факторы, которые могут привести к неправильной инициализации локальной переменной потока:

1. Если переменная инициализируется вызовом функции (включая конструкторы), эта функция будет вызываться только для потока, который вызвал загрузку в процесс двоичного файла или библиотеки DLL, а также для потоков, запущенных после загрузки двоичного файла или библиотеки DLL. Функции инициализации не вызываются для других потоков, которые уже выполнялись при загрузке библиотеки DLL. Динамическая инициализация происходит при вызове DllMain для DLL_THREAD_ATTACH, но библиотека DLL никогда не получает это сообщение, если библиотека DLL не находится в процессе запуска потока.

1. Локальные переменные потока, инициализированные статически с постоянными значениями, обычно инициализируются должным образом на всех потоках. Однако по состоянию на декабрь 2017 существует известная ошибка соответствия в компиляторе Microsoft C++, в результате чего **`constexpr`** переменные получают динамическую, а не статическую инициализацию.

   Примечание. обе эти проблемы должны быть исправлены в будущих обновлениях компилятора.

Кроме того, при объявлении локальных объектов и переменных потока необходимо следовать приведенным ниже рекомендациям.

- Атрибут можно применять **`thread`** только к объявлениям и определениям классов и данных; **`thread`** не может использоваться в объявлениях или определениях функций.

- Атрибут можно указать **`thread`** только для элементов данных со статической длительностью хранения. Сюда входят глобальные объекты данных ( **`static`** и **`extern`** ), локальные статические объекты и статические члены данных классов. Нельзя объявлять автоматические объекты данных с **`thread`** атрибутом.

- Необходимо использовать **`thread`** атрибут для объявления и определение локального объекта потока, будь то объявление и определение происходят в одном и том же файле или в отдельных файлах.

- Нельзя использовать атрибут в **`thread`** качестве модификатора типа.

- Так как объявление объектов, использующих **`thread`** атрибут, разрешено, эти два примера семантически эквивалентны:

    ```cpp
    // declspec_thread_2.cpp
    // compile with: /LD
    __declspec( thread ) class B {
    public:
       int data;
    } BObject;   // BObject declared thread local.

    class B2 {
    public:
       int data;
    };
    __declspec( thread ) B2 BObject2;   // BObject2 declared thread local.
    ```

- Стандартный C разрешает инициализацию объекта или переменной с помощью выражения, включающего ссылку на себя, но только для нестатических объектов. Хотя C++ обычно разрешает такую динамическую инициализацию объекта с помощью выражения, включающего ссылку на себя, этот тип инициализации не разрешен с локальными объектами потока. Например:

   ```cpp
   // declspec_thread_3.cpp
   // compile with: /LD
   #define Thread __declspec( thread )
   int j = j;   // Okay in C++; C error
   Thread int tls_i = sizeof( tls_i );   // Okay in C and C++
   ```

   **`sizeof`** Выражение, включающее инициализируемый объект, не является ссылкой на себя и допускается в C и C++.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[__declspec](../cpp/declspec.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Локальное хранилище потока (TLS)](../parallel/thread-local-storage-tls.md)
