---
title: '`main` аргументы функции и командной строки (C++)'
description: '`main`Функция является точкой входа для программы C++.'
ms.date: 11/19/2020
no-loc:
- main
- wmain
- inline
- static
- _tmain
- void
- exit
- argc
- argv
- envp
- CreateProcess
- GetModuleFileName
- char
- wchar_t
- extern
ms.openlocfilehash: 8a5ed43bdacf5d9d6dd2cbc5d1c56783c82b8e9a
ms.sourcegitcommit: b02c61667ff7f38e7add266d0aabd8463f2dbfa1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2020
ms.locfileid: "95483221"
---
# <a name="no-locmain-function-and-command-line-arguments"></a>`main` аргументы функции и командной строки

Все программы на C++ должны иметь `main` функцию. При попытке компиляции программы C++ без `main` функции компилятор вызывает ошибку. (Библиотеки и библиотеки динамической компоновки static не имеют `main` функции.) `main` Функция заключается в том, где исходный код начинает выполнение, но до того, как программа введет `main` функцию, всем static членам класса без явных инициализаторов присваивается нулевое значение. В Microsoft C++ глобальные static объекты также инициализируются перед записью в `main` . К `main` функции, которая не применяется к другим функциям C++, применяются некоторые ограничения. `main`Функция:

- Не может быть перегружен (см. [перегрузку функции](./function-overloading.md)).
- Не может быть объявлен как **`inline`** .
- Не может быть объявлен как **`static`** .
- Адрес не может быть создан.
- Невозможно вызвать из программы.

## <a name="the-no-locmain-function-signature"></a>`main`Сигнатура функции

`main`Функция не имеет объявления, так как она встроена в язык. Если это так, синтаксис объявления для `main` будет выглядеть следующим образом:

```cpp
int main();
int main(int argc, char *argv[]);
```

Если возвращаемое значение не указано в `main` , компилятор предоставляет возвращаемое значение, равное нулю.

## <a name="standard-command-line-arguments"></a>Стандартные аргументы командной строки

Аргументы для `main` обеспечения удобного анализа аргументов в командной строке. Типы для параметров `argc` и `argv` определяются языком. Имена `argc` и `argv` являются традиционными, но их можно называть по своему усмотрению.

Используются следующие определения аргументов.

*`argc`*\
Целое число, содержащее число аргументов, следующих за *argv* . *argc* Параметр всегда больше или равен 1.

*`argv`*\
Массив завершающихся null строк, представляющих введенные пользователем программы аргументы командной строки. По соглашению `argv[0]` — это команда, с помощью которой вызывается программа. `argv[1]` Первый аргумент командной строки. Последним аргументом из командной строки является `argv[argc - 1]` , и `argv[argc]` всегда имеет значение null.

Сведения о подавлении обработки в командной строке см. в разделе [Настройка обработки командной строки C++](#customize).

> [!NOTE]
> По соглашению `argv[0]` — это имя файла программы. Однако в Windows можно создать процесс с помощью [`CreateProcess`](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) . Если вы используете и первый, и второй аргументы ( *`lpApplicationName`* и *`lpCommandLine`* ), `argv[0]` не может быть именем исполняемого файла. С помощью можно [`GetModuleFileName`](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) получить имя исполняемого файла и его полный путь.

## <a name="microsoft-specific-extensions"></a>Расширения, относящиеся к Microsoft

В следующих разделах описывается поведение, характерное для Майкрософт.

## <a name="the-no-locwmain-function-and-no-loc_tmain-macro"></a>`wmain`Функция и `_tmain` макрос

Если вы разрабатываете исходный код для использования Юникода Wide char актерс, можно использовать `wmain` точку входа, относящуюся к Microsoft, которая является char актер версией `main` . Ниже приведен эффективный синтаксис объявления для `wmain` :

```cpp
int wmain();
int wmain(int argc, wchar_t *argv[]);
```

Кроме того, можно использовать Microsoft-Специальный `_tmain` макрос, определенный в *`tchar.h`* . `_tmain` разрешается в, `main` Если `_UNICODE` не определен. В противном случае функция `_tmain` разрешается в функцию `wmain`. `_tmain`Макрос и другие макросы, начинающиеся с, `_t` полезны для кода, который должен создавать отдельные версии для узких и широких char наборов актер. Дополнительные сведения см. [в разделе Использование универсальных текстовых сопоставлений](../c-runtime-library/using-generic-text-mappings.md).

## <a name="returning-no-locvoid-from-no-locmain"></a>Возврат `void` из main

Как расширение Майкрософт, `main` `wmain` функции и могут быть объявлены как возвращаемые **`void`** (без возвращаемого значения). Это расширение также доступно в некоторых других компиляторах, но его использование не рекомендуется. Он доступен для симметрии, если `main` не возвращает значение.

Если объявляется `main` или `wmain` возвращается **`void`** , то нельзя вернуть exit код в родительский процесс или операционную систему с помощью [`return`](./program-termination.md) инструкции. Чтобы вернуть exit код, если `main` или `wmain` объявлен как **`void`** , необходимо использовать [`exit`](./program-termination.md) функцию.

## <a name="the-no-locenvp-command-line-argument"></a>`envp`Аргумент командной строки

`main` `wmain` Сигнатуры или позволяют дополнительному расширению для доступа к переменным среды, относящимся к Microsoft. Это расширение также распространено в других компиляторах для систем Windows и UNIX. Имя *`envp`* является традиционным, но вы можете присвоить параметру среды любое имя. Ниже приведены эффективные объявления для списков аргументов, включающих параметр среды:

```cpp
int main(int argc, char* argv[], char* envp[]);
int wmain(int argc, wchar_t* argv[], wchar_t* envp[]);
```

*`envp`*\
Необязательный *`envp`* параметр представляет собой массив строк, представляющих переменные, заданные в среде пользователя. Этот массив завершается записью NULL. Он может быть объявлен как массив указателей на **`char`** ( `char *envp[]` ) или как указатель на указатели на **`char`** ( `char **envp` ). Если программа использует `wmain` вместо `main` , используйте **`wchar_t`** тип данных вместо **`char`** .

Блок среды, переданный в `main` и `wmain` , является замороженной копией текущей среды. Если впоследствии среда будет изменена путем вызова `putenv` или `_wputenv` , то текущая среда (как возвращаемая `getenv` переменной или, `_wgetenv` а также `_environ` переменная или) изменится  `_wenviron` , но блок, на который указывает, *`envp`* не изменится. Дополнительные сведения о подавлении обработки среды см. в разделе [Настройка обработки командной строки C++](#customize). *`envp`* Аргумент совместим с стандартом C89, но не с стандартами C++.

### <a name="example-arguments-to-no-locmain"></a>Примеры аргументов для `main`

В следующем примере показано, как использовать *`argc`* аргументы, *`argv`* и *`envp`* в следующих `main` случаях:

```cpp
// argument_definitions.cpp
// compile with: /EHsc
#include <iostream>
#include <string.h>

using namespace std;
int main( int argc, char *argv[], char *envp[] ) {
    int iNumberLines = 0;    // Default is no line numbers.

    // If /n is passed to the .exe, display numbered listing
    // of environment variables.

    if ( (argc == 2) && _stricmp( argv[1], "/n" ) == 0 )
         iNumberLines = 1;

    // Walk through list of strings until a NULL is encountered.
    for( int i = 0; envp[i] != NULL; ++i ) {
        if( iNumberLines )
            cout << i << ": " << envp[i] << "\n";
    }
}
```

## <a name="parsing-c-command-line-arguments"></a>Анализ аргументов командной строки C++

Правила синтаксического анализа командной строки, используемые кодом Microsoft C/C++, специфичны для Microsoft. Код запуска среды выполнения использует эти правила при интерпретации аргументов, заданных в командной строке операционной системы:

- Аргументы разделяются пробелами (пробел или табуляция).

- Первый аргумент (`argv[0]`) обрабатывается особым образом. Он представляет имя программы. Это должен быть допустимый путь, поэтому разрешены части, заключенные в двойные кавычки ( **`"`** ). Эти знаки двойных кавычек не включаются в выходные данные `argv[0]`. Части, заключенные в двойные кавычки, не позволяют интерпретировать пробел или знак табуляции char актер в качестве конца аргумента. Последующие правила в этом списке не применяются.

- Строка, заключенная в двойные кавычки, интерпретируется как один аргумент, который может содержать пробелы в char актерс. Строку в кавычках можно встроить в аргумент. Курсор ( **`^`** ) не распознается как escape- char актер или разделитель. Внутри заключенной в кавычки строки пара двойных кавычек интерпретируется как одна экранированная двойная кавычка. Если командная строка заканчивается до тех пор, пока не будет найдена закрывающая двойная кавычка, то все char прочитанные актерс будут выводиться в качестве последнего аргумента.

- Символ двойной кавычки после обратной косой черты ( **`\"`** ) интерпретируется как литеральный символ двойной кавычки ( **`"`** ).

- Символы обратной косой черты считаются литералами, если сразу за ними не стоит двойная кавычка.

- Если двойная кавычка стоит после четного числа символов обратной косой черты, в массив `argv` помещается по одному символу обратной косой черты ( **`\`** ) для каждой пары символов обратной косой черты ( **`\\`** ), а сама двойная кавычка ( **`"`** ) интерпретируется как разделитель строк.

- Если двойная кавычка стоит после нечетного числа символов обратной косой черты, в массив `argv` помещается по одному символу обратной косой черты ( **`\`** ) для каждой пары символов обратной косой черты ( **`\\`** ). Двойная кавычка интерпретируется как escape-последовательность путем main обратной косой черты, что приводит к тому, что литеральная двойная кавычка ( **`"`** ) будет помещена в `argv` .

### <a name="example-of-command-line-argument-parsing"></a>Пример синтаксического анализа аргументов командной строки

В следующем примере программы показана передача аргументов командной строки:

```cpp
// command_line_arguments.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
int main( int argc,      // Number of strings in array argv
          char *argv[],   // Array of command-line argument strings
          char *envp[] )  // Array of environment variable strings
{
    int count;

    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < argc; count++ )
         cout << "  argv[" << count << "]   "
                << argv[count] << "\n";
}
```

### <a name="results-of-parsing-command-lines"></a>Результаты синтаксического анализа командных строк

В следующей таблице показаны примеры входных данных и ожидаемые выходные данные, иллюстрирующие применение правил из приведенного выше списка.

| Входные данные командной строки | argv[1] | argv[2] | argv3-5 |
|--|--|--|--|
| `"abc" d e` | `abc` | `d` | `e` |
| `a\\b d"e f"g h` | `a\\b` | `de fg` | `h` |
| `a\\\"b c d` | `a\"b` | `c` | `d` |
| `a\\\\"b c" d e` | `a\\b c` | `d` | `e` |
| `a"b"" c d` | `ab" c d` |  |  |

## <a name="wildcard-expansion"></a>Развертывание подстановочных знаков

Кроме того, компилятор Майкрософт позволяет использовать *подстановочный* знак char актерс, вопросительный знак ( **`?`** ) и звездочку ( **`*`** ), чтобы указать аргументы filename и Path в командной строке.

Аргументы командной строки обрабатываются внутренней подпрограммой в коде запуска среды выполнения, который по умолчанию не расширяет подстановочные знаки в отдельные строки в `argv` массиве строк. Можно включить расширение подстановочных знаков, включив *`setargv.obj`* файл ( *`wsetargv.obj`* файл для `wmain` ) в **`/link`** параметрах компилятора или в **`LINK`** командной строке.

Дополнительные сведения о параметрах компоновщика при запуске среды выполнения см. в разделе [Параметры ссылки](../c-runtime-library/link-options.md).

## <a name="customize-c-command-line-processing"></a><a name="customize"/> Настройка обработки командной строки C++

Если программа не принимает аргументы командной строки, можно отключить подпрограмму обработки командной строки, чтобы сэкономить небольшой объем пространства. Чтобы подавить его использование, включите *`noarg.obj`* файл (для `main` и `wmain` ) в **`/link`** параметрах компилятора или в **`LINK`** командной строке.

Аналогично, если вы никогда не обращаетесь к таблице окружения с помощью *`envp`* аргумента, можно подавить внутреннюю подпрограммы обработки среды. Чтобы подавить его использование, включите *`noenv.obj`* файл (для `main` и `wmain` ) в **`/link`** параметрах компилятора или в **`LINK`** командной строке.

Программа может вызывать `spawn` или `exec` семейство подпрограмм в библиотеке времени выполнения C. Если это так, не следует подавлять подпрограммы обработки среды, так как она используется для передачи среды из родительского процесса в дочерний процесс.

## <a name="see-also"></a>См. также

[Основные понятия](../cpp/basic-concepts-cpp.md)
