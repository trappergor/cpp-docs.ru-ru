---
title: Область (C++)
ms.date: 11/19/2018
helpviewer_keywords:
- classes [C++], scope
- scope [C++]
- function prototypes [C++], scope
- class scope
- prototype scope
- functions [C++], scope
- scope, C++ names
ms.assetid: 81fecbb0-338b-4325-8332-49f33e716352
ms.openlocfilehash: a5b5601c89991fbe1a148ebaf781fe2ad6a9dfc4
ms.sourcegitcommit: c4cf8976939dd0e13e25b82930221323ba6f15d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/12/2020
ms.locfileid: "83204138"
---
# <a name="scope-c"></a>Область (C++)

При объявлении программного элемента, такого как класс, функция или переменная, его имя может быть "видимым" и использоваться в определенных частях программы. Контекст, в котором отображается имя, называется его *областью действия*. Например, если объявить переменную `x` внутри функции, `x` она будет видна только в теле этой функции. Он имеет *локальную область*. У вас могут быть другие переменные с одним и тем же именем в программе; пока они находятся в разных областях, они не нарушают правило одного определения и не вызывают ошибку.

Для автоматических нестатических переменных область также определяет, когда они создаются и уничтожаются в памяти программ.

Существует шесть видов областей:

- **Глобальная область** Глобальное имя — это объявление, объявленное вне любого класса, функции или пространства имен. Однако в C++ даже эти имена существуют с неявным глобальным пространством имен. Область глобальных имен расширяется с точки объявления до конца файла, в котором они объявляются. Для глобальных имен видимость также регулируется правилами [компоновки](program-and-linkage-cpp.md) , которые определяют, является ли имя видимым в других файлах программы.

- **Область пространства имен** Имя, объявленное в [пространстве имен](namespaces-cpp.md)вне любого класса или определения перечисления или блока функции, видимо от его точки объявления до конца пространства имен. Пространство имен может быть определено в нескольких блоках для разных файлов.

- **Локальная область** Имя, объявленное внутри функции или лямбда-выражения, включая имена параметров, имеет локальную область. Они часто называются "локальными". Они видны только от их точки объявления до конца функции или тела лямбда-выражения. Локальная область — это разновидность области блока, которая обсуждается далее в этой статье.

- **Область класса** Имена членов класса имеют область класса, которая расширяется по всему определению класса независимо от точки объявления. Доступность членов класса дополнительно управляется ключевыми словами **Public**, **Private**и **protected** . Доступ к открытым или защищенным членам возможен только с помощью операторов выбора членов (**.** или **->** ) или операторы указателя на член (**.** <strong>\*</strong> или **->** <strong>\*</strong> ).

- **Область инструкции** Имена, объявленные в операторе **for**, **If**, **while**или **switch** , видимы до конца блока инструкции.

- **Область действия функции** [Метка](labeled-statements.md) имеет область видимости функции, что означает, что она видна в теле функции, даже до ее точки объявления. Область функции позволяет писать инструкции `goto cleanup` , например перед `cleanup` объявлением метки.

## <a name="hiding-names"></a>Скрытие имен

Можно скрыть имя, объявив его в закрытом блоке. На следующем рисунке `i` повторно объявляется во внутреннем блоке, таким образом скрывая переменную, связанную с `i` во внешней области видимости блока.

![Блокировать скрытие имени области&#45;](../cpp/media/vc38sf1.png "Блокировать скрытие имени области&#45;") <br/>
Блокировка области и скрытия имен

Выходные данные программы, представленной на рисунке, выглядят следующим образом.

```cpp
i = 0
i = 7
j = 9
i = 0
```

> [!NOTE]
> Считается, что аргумент `szWhat`, находится в области видимости функции. Поэтому он обрабатывается так, как если бы он был объявлен в крайнем блоке функции.

## <a name="hiding-class-names"></a>Скрытие имен классов

Имена классов можно скрыть, объявив функцию, объект, переменную или перечислитель в той же области. Однако имя класса по-прежнему можно получить при префиксе **класса**keywords.

```cpp
// hiding_class_names.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;

// Declare class Account at global scope.
class Account
{
public:
    Account( double InitialBalance )
        { balance = InitialBalance; }
    double GetBalance()
        { return balance; }
private:
    double balance;
};

double Account = 15.37;            // Hides class name Account

int main()
{
    class Account Checking( Account ); // Qualifies Account as
                                       //  class name

    cout << "Opening account with a balance of: "
         << Checking.GetBalance() << "\n";
}
//Output: Opening account with a balance of: 15.37
```

> [!NOTE]
> В любом месте `Account` , для которого вызывается имя класса (), класс ключевых слов необходимо использовать, чтобы отличать его от учетной записи с глобальной областью действия. Это правило не применяется, если имя класса находится слева от оператора разрешения области действия (::). Имена слева от оператора разрешения области действия всегда считаются именами класса.

В следующем примере показано, как объявить указатель на объект типа `Account` с помощью ключевого слова **Class** :

```cpp
class Account *Checking = new class Account( Account );
```

В `Account` инициализаторе (в круглых скобках) в предшествующей инструкции имеет глобальную область видимости, она имеет тип **Double**.

> [!NOTE]
> Повторное использование имен идентификаторов считается плохим стилем программирования, как показано в следующем примере.

Сведения об объявлении и инициализации объектов класса см. в разделе [классы, структуры и объединения](../cpp/classes-and-structs-cpp.md). Дополнительные сведения об использовании операторов **New** и **Delete** Free-Store см. в разделе [операторы new и DELETE](new-and-delete-operators.md).

## <a name="hiding-names-with-global-scope"></a>Скрытие имен с глобальной областью видимости

Можно скрыть имена с глобальной областью, явно объявляя одно и то же имя в области видимости блока. Однако доступ к именам глобальных областей можно получить с помощью оператора разрешения области ( `::` ).

```cpp
#include <iostream>

int i = 7;   // i has global scope, outside all blocks
using namespace std;

int main( int argc, char *argv[] ) {
   int i = 5;   // i has block scope, hides i at global scope
   cout << "Block-scoped i has the value: " << i << "\n";
   cout << "Global-scoped i has the value: " << ::i << "\n";
}
```

```Output
Block-scoped i has the value: 5
Global-scoped i has the value: 7
```

## <a name="see-also"></a>См. также раздел

[Основные понятия](../cpp/basic-concepts-cpp.md)
