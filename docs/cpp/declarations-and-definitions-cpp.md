---
title: Объявления и определения (C++)
ms.date: 12/12/2019
ms.assetid: 678f1424-e12f-45e0-a957-8169e5fef6cb
ms.openlocfilehash: 688c1960e37fe74edecabebc4cb8090af9d0dd58
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87228964"
---
# <a name="declarations-and-definitions-c"></a>Объявления и определения (C++)

Программа на C++ состоит из различных сущностей, таких как переменные, функции, типы и пространства имен. Каждая из этих сущностей должна быть *объявлена* , прежде чем их можно будет использовать. В объявлении указывается уникальное имя сущности, а также сведения о ее типе и других характеристиках. В C++ точка, в которой объявлено имя, является точкой, в которой он становится видимым для компилятора. Нельзя ссылаться на функцию или класс, объявленные в более поздней точке в единице компиляции. Переменные должны быть объявлены как можно ближе до точки, в которой они используются.

В следующем примере показаны некоторые объявления:

```cpp
#include <string>

void f(); // forward declaration

int main()
{
    const double pi = 3.14; //OK
    int i = f(2); //OK. f is forward-declared
    std::string str; // OK std::string is declared in <string> header
    C obj; // error! C not yet declared.
    j = 0; // error! No type specified.
    auto k = 0; // OK. type inferred as int by compiler.
}

int f(int i)
{
    return i + 42;
}

namespace N {
   class C{/*...*/};
}
```

В строке 5 `main` объявлена функция. В строке 7 **`const`** `pi` объявлена и *инициализирована*переменная с именем. В строке 8 целое число `i` объявляется и инициализируется значением, созданным функцией `f` . Имя `f` является видимым для компилятора из-за *прямого объявления* в строке 3.

В строке 9 `obj` объявлена переменная типа с именем `C` . Однако это объявление вызывает ошибку, так как не `C` объявлено до последующих появления в программе и не объявлена как прямая. Чтобы устранить эту ошибку, можно либо переместить все *Определение* `C` ранее, `main` либо добавить в нее прямую декларацию. Это поведение отличается от других языков, таких как C#, в которых функции и классы можно использовать до их точки объявления в исходном файле.

В строке 10 `str` объявлена переменная типа с именем `std::string` . Имя `std::string` является видимым, так как оно представлено в `string` [файле заголовка](header-files-cpp.md) , который объединяется с исходным файлом в строке 1. `std`пространство имен, в котором `string` объявлен класс.

В строке 11 возникает ошибка, так как имя `j` не было объявлено. Объявление должно предоставлять тип, в отличие от других языков, таких как javaScript. В строке 12 **`auto`** используется ключевое слово, которое указывает компилятору вывести тип `k` на основе значения, с которым он инициализируется. Компилятор в этом случае выбирает **`int`** тип.  

## <a name="declaration-scope"></a>Область видимости объявления

Имя, введенное в объявлении, допустимо в пределах *области* , в которой происходит объявление. В предыдущем примере переменные, объявленные внутри `main` функции, являются *локальными переменными*. Можно объявить другую переменную `i` , именованную за пределами Main, в *глобальной области видимости*, и она будет полностью отдельной сущностью. Однако такое дублирование имен может привести к путанице и ошибкам программиста, и их следует избегать. В строке 21 класс `C` объявляется в области видимости пространства имен `N` . Использование пространств имен помогает избежать *конфликтов имен*. Большинство имен стандартных библиотек C++ объявляются в `std` пространстве имен. Дополнительные сведения о взаимодействии правил определения области с объявлениями см. в разделе [Scope](../cpp/scope-visual-cpp.md).

## <a name="definitions"></a>Определения

Некоторые сущности, включая функции, классы, перечисления и константные переменные, должны быть определены в дополнение к объявлению. *Определение* предоставляет компилятору все сведения, необходимые для создания машинного кода, когда сущность используется позже в программе. В предыдущем примере строка 3 содержит объявление для функции, `f` но *Определение* функции предоставляется в строках с 15 по 18. В строке 21 класс `C` объявлен и определен (хотя в соответствии с определением класс не выполняет никаких действий). Константная переменная должна быть определена, иными словами, которой было присвоено значение, в той же инструкции, в которой она объявлена. Объявление встроенного типа, например **`int`** , автоматически определяется определением, так как компилятор знает, сколько пространства нужно выделить.

В следующем примере показаны объявления, которые также являются определениями:

```cpp
// Declare and define int variables i and j.
int i;
int j = 10;

// Declare enumeration suits.
enum suits { Spades = 1, Clubs, Hearts, Diamonds };

// Declare class CheckBox.
class CheckBox : public Control
{
public:
    Boolean IsChecked();
    virtual int     ChangeState() = 0;
};
```

Ниже приведены некоторые объявления, которые не являются определениями.

```cpp
extern int i;
char *strchr( const char *Str, const char Target );
```

## <a name="typedefs-and-using-statements"></a>Определения типов и операторы using

В более старых версиях C++ [`typedef`](aliases-and-typedefs-cpp.md) ключевое слово используется для объявления нового имени, которое является *псевдонимом* для другого имени. Например, тип `std::string` является другим именем для `std::basic_string<char>` . Должно быть очевидно, почему программисты используют имя typedef, а не фактическое имя. В современных C++ [`using`](aliases-and-typedefs-cpp.md) ключевое слово предпочтительнее **`typedef`** , но идея одинакова: новое имя объявлено для сущности, которая уже объявлена и определена.

## <a name="static-class-members"></a>Члены статических классов

Поскольку члены статических данных класса являются дискретными переменными, общими для всех объектов класса, они должны быть определены и инициализированы вне определения класса. (Дополнительные сведения см. в разделе [классы](../cpp/classes-and-structs-cpp.md).)

## <a name="extern-declarations"></a>объявления extern

Программа на C++ может содержать более одной [единицы компиляции](header-files-cpp.md). Чтобы объявить сущность, определенную в отдельной единице компиляции, используйте [`extern`](extern-cpp.md) ключевое слово. Сведения в объявлении достаточны для компилятора, но если определение сущности не найдено на шаге компоновки, компоновщик вызовет ошибку.

## <a name="in-this-section"></a>В этом разделе

[Классы хранения в C](storage-classes-cpp.md)<br/>
[`const`](const-cpp.md)<br/>
[`constexpr`](constexpr-cpp.md)<br/>
[`extern`](extern-cpp.md)<br/>
[Инициализаторы](initializers.md)<br/>
[Псевдонимы и определения типов](aliases-and-typedefs-cpp.md)<br/>
[`using`повторно](using-declaration.md)<br/>
[`volatile`](volatile-cpp.md)<br/>
[`decltype`](decltype-cpp.md)<br/>
[Атрибуты в C++](attributes.md)<br/>

## <a name="see-also"></a>См. также статью

[Основные понятия](../cpp/basic-concepts-cpp.md)<br/>
