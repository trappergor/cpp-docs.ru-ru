---
title: "Оператор индекса: | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords: '[]'
dev_langs: C++
helpviewer_keywords:
- operators [C++], subscript
- postfix operators [C++]
- '[] operator'
- subscript operator [C++], syntax
ms.assetid: 69c31494-52da-4dd0-8bbe-6ccbfd50f197
caps.latest.revision: "9"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 1fbcb3657af276cdfc9aa05d461c090b76f6de0b
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="subscript-operator"></a>Подстрочный оператор:
## <a name="syntax"></a>Синтаксис  
  
```  
  
postfix-expression [ expression ]  
```  
  
## <a name="remarks"></a>Примечания  
 Постфиксное выражение (которое может также быть основным выражением) следуют подстрочный оператор **[]**, задает индексирование массива.  
  
 Сведения об управляемых массивах см. в разделе [массивы](../windows/arrays-cpp-component-extensions.md).  
  
 Как правило, значение, представленное *Постфиксное выражение* представляет значение указателя, например идентификатор массива, и *выражение* является целочисленным значением (включая перечисляемые типы). Однако все, что необходимо синтаксически, — это чтобы одно из выражений имело тип указателя, а другие — целочисленный тип. Таким образом, целочисленное значение может находиться в *Постфиксное выражение* позиции, а значение указателя может находиться в квадратных скобках в *выражение* или позиции индекса. Рассмотрим следующий фрагмент кода:  
  
```  
int nArray[5] = { 0, 1, 2, 3, 4 };  
cout << nArray[2] << endl;            // prints "2"  
cout << 2[nArray] << endl;            // prints "2"  
```  
  
 В предыдущем примере выражение `nArray[2]` совпадает с `2[nArray]`. Причина том, что результат выражения индекса *e1***[** *e2* **]** определяется:  
  
 **\*((** *e2* **)**  *+*  **(***e1***))**  
  
 Адрес, предоставленный этим выражением не *e2* байт из адреса *e1*. Вместо этого адрес масштабируется так, чтобы выдавать следующий объект в массиве *e2*. Пример:  
  
```  
double aDbl[2];  
```  
  
 Адреса `aDb[0]` и `aDb[1]` различаются 8 байтами — размером объекта типа **двойные**. Это масштабирование в соответствии с типом объекта выполняется автоматически в языке C++ и определяется в [Аддитивные операторы](../cpp/additive-operators-plus-and.md) которых рассматриваются сложение и вычитание операндов типа указателя.  
  
 Индексное выражение также может иметь несколько индексов, как показано ниже:  
  
 *expression1* **[***expression2***] [***выражение3***]**...  
  
 Индексные выражения связываются в направлении слева направо. Сначала вычисляется левое индексное выражение, *expression1***[***expression2***]**. Адрес, получающийся в результате сложения *expression1* и *expression2*, формирует выражение указателя. Затем к этому выражению указателя добавляется выражение *expression3*, чтобы образовать новое выражение указателя. Эти операции повторяются до тех пор, пока не будет добавлено последнее индексное выражение. Оператор косвенного обращения (**\***) применяется после вычисления последнего индексного выражения выполняется, если конечное значение указателя указывает на тип массива.  
  
 Выражения с несколькими индексами ссылаются на элементы многомерных массивов. Многомерный массив — это массив, элементы которого сами являются массивами. Например, первый элемент трехмерного массива является двумерным массивом. В следующем примере объявляется и инициализируется простой двухмерный массив символов.  
  
```  
// expre_Subscript_Operator.cpp  
// compile with: /EHsc  
#include <iostream>  
  
using namespace std;  
#define MAX_ROWS 2  
#define MAX_COLS 2  
  
int main() {  
   char c[ MAX_ROWS ][ MAX_COLS ] = { { 'a', 'b' }, { 'c', 'd' } };  
   for ( int i = 0; i < MAX_ROWS; i++ )  
      for ( int j = 0; j < MAX_COLS; j++ )  
         cout << c[ i ][ j ] << endl;  
}  
```  
  
## <a name="positive-and-negative-subscripts"></a>Положительные и отрицательные индексы  
 Первым элементом массива является элемент с номером 0. Диапазон для массива C++ — от *массива*[0] для *массива*[*размер* - 1]. Однако C++ поддерживает положительные и отрицательные индексы. Отрицательные индексы не должны выходить за границы массива; в противном случае результаты непредсказуемы. В следующем примере кода показаны положительные и отрицательные индексы массива:  
  
```  
#include <iostream>  
using namespace std;  
  
int main() {  
    int intArray[1024];  
    for (int i = 0, j = 0; i < 1024; i++)  
    {  
        intArray[i] = j++;  
    }  
  
    cout << intArray[512] << endl;// 512  
  
    int *midArray = &intArray[512];  // pointer to the middle of the array  
  
    cout << midArray[-256] << endl;   // 256  
  
    cout << intArray[-256] << endl; // unpredictable  
}  
```  
  
 Отрицательный индекс в последней строке может вызывать ошибку времени выполнения, поскольку он указывает на адрес в памяти на 256 байт ниже, чем начало массива. В результате инициализации указатель `midArray` указывает на середину массива `intArray`, поэтому в нем можно использовать как положительные, так и отрицательные индексы массива. Ошибки индексов массивов не создают ошибки времени компиляции, но дают непредсказуемые результаты.  
  
 Оператор индекса коммутативен. Поэтому выражения *массива*[*индекс*] и *массива*[*массива*] гарантированно эквивалент, пока индекс оператор не перегружен (см. [перегруженные операторы](../cpp/operator-overloading.md)). Программисты чаще всего используют первую форму, но вторая форма также правильна.  
  
## <a name="see-also"></a>См. также  
 [Постфиксные выражения](../cpp/postfix-expressions.md)   
 [Встроенный C++ операторы, приоритет и ассоциативность операторов](../cpp/cpp-built-in-operators-precedence-and-associativity.md)   
 [Массивы](../cpp/arrays-cpp.md)   
 [Одномерные массивы](../c-language/one-dimensional-arrays.md)   
 [Многомерные массивы](../c-language/multidimensional-arrays-c.md)