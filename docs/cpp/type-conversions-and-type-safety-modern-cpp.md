---
title: Преобразования типов и безопасность типов
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: 629b361a-2ce1-4700-8b5d-ab4f57b245d5
ms.openlocfilehash: dbca9057622ab1a92b74e2958b8dfbe8d810fede
ms.sourcegitcommit: 654aecaeb5d3e3fe6bc926bafd6d5ace0d20a80e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74246109"
---
# <a name="type-conversions-and-type-safety"></a>Преобразования типов и безопасность типов

В этом документе описаны распространенные проблемы преобразования типов и описывается, как избежать их использования C++ в коде.

При написании C++ программы важно убедиться, что она является строго типизированной. Это означает, что каждая переменная, аргумент функции и возвращаемое значение функции сохраняют допустимый тип данных и операции, которые подразумевают значения различных типов и не вызывают потери данных, неправильной интерпретации битовых шаблонов или повреждение памяти. Неявное или неявное преобразование значений одного типа в другой является типобезопасным по определению. Однако иногда требуются преобразования типов, даже ненадежные преобразования. Например, может потребоваться сохранить результат операции с плавающей запятой в переменной типа **int**или передать значение в неподписанное **целое** число в функцию, которая принимает **целое**число со знаком. В обоих примерах показаны ненадежные преобразования, так как они могут привести к потере данных или повторной интерпретации значения.

Когда компилятор обнаруживает ненадежное преобразование, он выдает ошибку или предупреждение. Произошла ошибка при остановке компиляции. Предупреждение позволяет продолжить компиляцию, но указывает на возможную ошибку в коде. Однако даже если программа компилируется без предупреждений, она по-прежнему может содержать код, который вызывает неявные преобразования типов, приводящие к неправильным результатам. Ошибки типов также могут вводиться явными преобразованиями или приведениями в коде.

## <a name="implicit-type-conversions"></a>Неявные преобразования типов

Если выражение содержит операнды различных встроенных типов и явные приведения отсутствуют, компилятор использует встроенные *стандартные преобразования* для преобразования одного из операндов, чтобы типы совпадали. Компилятор пытается выполнить преобразования в четко определенной последовательности, пока она не завершится успешно. Если выбранное преобразование является повышением, компилятор не выдает предупреждение. Если преобразование является узким, компилятор выдает предупреждение о возможной утрате данных. Происходит ли фактическая потери данных, зависит от фактических значений, но рекомендуется считать это предупреждение как ошибку. Если включен определяемый пользователем тип, компилятор пытается использовать преобразования, указанные в определении класса. Если не удается найти допустимое преобразование, компилятор выдает ошибку и не компилирует программу. Дополнительные сведения о правилах, регулирующих стандартные преобразования, см. в разделе [стандартные преобразования](../cpp/standard-conversions.md). Дополнительные сведения о пользовательских преобразованиях см. в разделе пользовательские [преобразования (C++/CLI)](../dotnet/user-defined-conversions-cpp-cli.md).

### <a name="widening-conversions-promotion"></a>Расширяющие преобразования (продвижение)

В расширяющем преобразовании значение меньшей переменной присваивается более крупной переменной без потери данных. Поскольку расширяющие преобразования всегда являются надежными, компилятор выполняет их автоматически и не выдает предупреждения. Следующие преобразования являются расширяющими преобразованиями.

|От|Чтобы|
|----------|--------|
|Любой целочисленный тип со знаком или без знака, за исключением **длинного** или **__int64**|**double**|
|**bool** или **char**|Любой другой встроенный тип|
|**короткий** или **wchar_t**|**int**, **Long**, **Long**|
|**int**, **Long**|**long long**|
|**float**|**double**|

### <a name="narrowing-conversions-coercion"></a>Сужающие преобразования (приведение)

Компилятор выполняет сужающие преобразования неявным образом, но предупреждает о возможной потере данных. Выведите эти предупреждения очень серьезно. Если вы уверены, что не произойдет потери данных, так как значения в переменной большего размера всегда помещаются в меньшую переменную, добавьте явное приведение, чтобы компилятор больше не выдавал предупреждение. Если вы не уверены, что преобразование является надежным, добавьте в код какую-либо проверку среды выполнения для обработки возможной потери данных, чтобы программа не выводила неверных результатов.

Преобразование из типа с плавающей запятой в целочисленный тип является узким преобразованием, так как дробная часть значения с плавающей запятой отбрасывается и теряется.

В следующем примере кода показаны некоторые неявные сужающие преобразования и предупреждения, которые возникают компилятором.

```cpp
int i = INT_MAX + 1; //warning C4307:'+':integral constant overflow
wchar_t wch = 'A'; //OK
char c = wch; // warning C4244:'initializing':conversion from 'wchar_t'
              // to 'char', possible loss of data
unsigned char c2 = 0xfffe; //warning C4305:'initializing':truncation from
                           // 'int' to 'unsigned char'
int j = 1.9f; // warning C4244:'initializing':conversion from 'float' to
              // 'int', possible loss of data
int k = 7.7; // warning C4244:'initializing':conversion from 'double' to
             // 'int', possible loss of data
```

### <a name="signed---unsigned-conversions"></a>Преобразования со знаком — без знака

Целочисленный тип со знаком и его неподписанный аналог всегда имеют одинаковый размер, но они отличаются тем, как битовый шаблон интерпретируется для преобразования значения. В следующем примере кода показано, что происходит, когда один и тот же битовый шаблон интерпретируется как значение со знаком и как значение без знака. Битовый шаблон, хранящийся как в `num`, так и в `num2`, никогда не изменяется от того, что показано на предыдущем рисунке.

```cpp
using namespace std;
unsigned short num = numeric_limits<unsigned short>::max(); // #include <limits>
short num2 = num;
cout << "unsigned val = " << num << " signed val = " << num2 << endl;
// Prints: unsigned val = 65535 signed val = -1

// Go the other way.
num2 = -1;
num = num2;
cout << "unsigned val = " << num << " signed val = " << num2 << endl;
// Prints: unsigned val = 65535 signed val = -1
```

Обратите внимание, что значения переинтерпретируемают в обоих направлениях. Если программа создает нечетные результаты, при которых знак значения кажется инвертированным от того, что вы ожидаете, найдите неявные преобразования между целыми типами со знаком и без знака. В следующем примере результат выражения (0-1) неявно преобразуется из **типа int** в **Неподписанное целое** число, если оно хранится в `num`. Это приводит к переинтерпретации битового шаблона.

```cpp
unsigned int u3 = 0 - 1;
cout << u3 << endl; // prints 4294967295
```

Компилятор не предупреждает о неявных преобразованиях между целыми типами со знаком и без знака. Поэтому рекомендуется полностью избегать беззнаковых преобразований. Если вы не можете избежать их, добавьте в код проверку среды выполнения, чтобы определить, является ли преобразуемое значение большим или равным нулю и меньше или равно максимальному значению типа со знаком. Значения в этом диапазоне будут передаваться из входных файлов в неподписанный или из неподписанных в подписывание без переинтерпретации.

### <a name="pointer-conversions"></a>Преобразования указателей

Во многих выражениях массив в стиле C неявно преобразуется в указатель на первый элемент в массиве, а преобразования констант могут выполняться автоматически. Хотя это и удобно, это, вероятно, подвержено ошибкам. Например, следующий плохо спроектированный пример кода кажется бессмысленное, но он компилирует и выдает результат "p". Во-первых, строковый константный литерал "Help" преобразуется в `char*`, указывающую на первый элемент массива. Затем этот указатель увеличивается на три элемента, чтобы теперь он указывал на последний элемент "p".

```cpp
char* s = "Help" + 3;
```

## <a name="explicit-conversions-casts"></a>Явные преобразования (приведения)

С помощью операции приведения можно указать компилятору преобразовать значение одного типа в другой тип. В некоторых случаях компилятор вызовет ошибку, если эти два типа полностью не связаны, но в других случаях не вызывает ошибку, даже если операция не является строго типизированной. Используйте приведение с осторожностью, так как любое преобразование из одного типа в другой является потенциальным источником ошибок программы. Однако иногда требуется выполнить приведения, а не все приведения являются опасными. Одно эффективное использование приведения заключается в том, что в коде выполняется понижающие преобразования и известно, что преобразование не приводит к тому, что программа выдает неверные результаты. Фактически, это говорит компилятору о том, что вы делаете, а также о том, что вы выполняете предупреждения. Другой способ заключается в приведении из класса указателя на класс, производный от указатель на базовый. Другой способ — это выполнить приведение **const**-rvalue характеристики переменной, чтобы передать ее в функцию, для которой требуется аргумент, не являющийся**константой** . Большинство этих операций приведения к некоторым рискам требует определенного риска.

В программировании в стиле C для всех типов приведений используется один и тот же оператор приведения в стиле C.

```cpp
(int) x; // old-style cast, old-style syntax
int(x); // old-style cast, functional syntax
```

Оператор приведения в стиле C идентичен оператору call () и, следовательно, инконспикуаус в коде и легко пропускаться. Оба являются некорректными, так как они трудно распознать или найти, и они достаточно разнороды для вызова любой комбинации **статических**, **const**и **reinterpret_cast**. Понять, что такое приведение старого стиля, действительно может быть трудно и подвержено ошибкам. По всем этим причинам, если требуется приведение, рекомендуется использовать один из приведенных ниже C++ операторов приведения, которые в некоторых случаях являются строго типизированными, и что явно упрощает намерение программирования:

- **static_cast**, для приведений, которые проверяются только во время компиляции. **static_cast** возвращает ошибку, если компилятор обнаруживает, что вы пытаетесь выполнить приведение типов, которые полностью несовместимы. Его также можно использовать для приведения между указателями на базовые и производные указатели, но компилятор не всегда может определить, будут ли такие преобразования небезопасны во время выполнения.

    ```cpp
    double d = 1.58947;
    int i = d;  // warning C4244 possible loss of data
    int j = static_cast<int>(d);       // No warning.
    string s = static_cast<string>(d); // Error C2440:cannot convert from
                                       // double to std:string

    // No error but not necessarily safe.
    Base* b = new Base();
    Derived* d2 = static_cast<Derived*>(b);
    ```

   Дополнительные сведения см. в разделе [static_cast](../cpp/static-cast-operator.md).

- **dynamic_cast**, для безопасного выполнения приведения указателя на базовый тип в виде указателя на производное состояние. **Dynamic_cast** более безопасна, чем **static_cast** для образования производных типов, но проверка среды выполнения требует некоторых дополнительных издержек.

    ```cpp
    Base* b = new Base();

    // Run-time check to determine whether b is actually a Derived*
    Derived* d3 = dynamic_cast<Derived*>(b);

    // If b was originally a Derived*, then d3 is a valid pointer.
    if(d3)
    {
       // Safe to call Derived method.
       cout << d3->DoSomethingMore() << endl;
    }
    else
    {
       // Run-time check failed.
       cout << "d3 is null" << endl;
    }

    //Output: d3 is null;
    ```

   Дополнительные сведения см. в разделе [dynamic_cast](../cpp/dynamic-cast-operator.md).

- **const_cast**, для приведения **константы const**-rvalue характеристики переменной или преобразования**неконстантной** переменной в **const**. Приведение **const**-rvalue характеристики с помощью этого оператора также подвержено ошибкам, так как оно использует приведение в стиле C, за исключением того, что при использовании преобразования с **константой** скорее всего будет выполняться случайное приведение. Иногда необходимо выполнить приведение **const**-rvalue характеристики переменной, например, чтобы передать переменную **const** в функцию, принимающую параметр, не являющийся**константой** . Следующий пример показывает, как это сделать.

    ```cpp
    void Func(double& d) { ... }
    void ConstCast()
    {
       const double pi = 3.14;
       Func(const_cast<double&>(pi)); //No error.
    }
    ```

   Дополнительные сведения см. в разделе [const_cast](../cpp/const-cast-operator.md).

- **reinterpret_cast**, для приведения между несвязанными типами, такими как **указатель** на **int**.

    > [!NOTE]
    >  Этот оператор приведения не используется так часто, как другие, и не гарантирует перенос в другие компиляторы.

   В следующем примере показано, как **reinterpret_cast** отличается от **static_cast**.

    ```cpp
    const char* str = "hello";
    int i = static_cast<int>(str);//error C2440: 'static_cast' : cannot
                                  // convert from 'const char *' to 'int'
    int j = (int)str; // C-style cast. Did the programmer really intend
                      // to do this?
    int k = reinterpret_cast<int>(str);// Programming intent is clear.
                                       // However, it is not 64-bit safe.
    ```

   Дополнительные сведения см. в разделе [оператор reinterpret_cast](../cpp/reinterpret-cast-operator.md).

## <a name="see-also"></a>См. также:

[C++система типов](../cpp/cpp-type-system-modern-cpp.md)<br/>
[Добро пожаловать обратно вC++](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
