---
title: Оператор new (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- new keyword [C++]
ms.assetid: 69fee812-1c28-4882-8fda-d1ad17860004
ms.openlocfilehash: 81dd7483c49a699ac53ea53d33481fa6539d484c
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87223659"
---
# <a name="new-operator-c"></a>Оператор new (C++)

Выделяет память для объекта или массива объектов *типа-Name* из свободного хранилища и возвращает подходящим образом типизированный ненулевой указатель на объект.

> [!NOTE]
> Расширения компонентов Microsoft C++ обеспечивают поддержку **`new`** ключевого слова для добавления записей слота vtable. Дополнительные сведения см. в разделе [создать (новый слот в таблице vtable)](../extensions/new-new-slot-in-vtable-cpp-component-extensions.md) .

## <a name="syntax"></a>Синтаксис

```
[::] new [placement] new-type-name [new-initializer]
[::] new [placement] ( type-name ) [new-initializer]
```

## <a name="remarks"></a>Remarks

В случае неудачи **`new`** возвращает ноль или создает исключение; дополнительные сведения см. [в разделе операторы new и DELETE](../cpp/new-and-delete-operators.md) . Это поведение по умолчанию можно изменить, написав настраиваемую подпрограммы обработки исключений и вызвав функцию [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) библиотеки времени выполнения с именем функции в качестве аргумента.

Сведения о создании объекта в управляемой куче см. в разделе [gcnew](../extensions/ref-new-gcnew-cpp-component-extensions.md).

Если **`new`** используется для выделения памяти для объекта класса C++, конструктор объекта вызывается после выделения памяти.

Используйте оператор [Delete](../cpp/delete-operator-cpp.md) , чтобы освободить память, выделенную с помощью **`new`** оператора.

В следующем примере выделяется и затем освобождается двумерный массив символов размером `dim` на 10. При выделении многомерного массива все измерения, кроме первого, должны быть константными выражениями, которые возвращают положительные значения; самое левое измерение массива может являться любым выражением, результатом которого является положительное значение. При выделении массива с помощью **`new`** оператора первое измерение может равняться нулю — **`new`** оператор возвращает уникальный указатель.

```cpp
char (*pchar)[10] = new char[dim][10];
delete [] pchar;
```

*Имя типа* не может содержать имена **`const`** , **`volatile`** , объявления классов или объявления перечислений. Таким образом, следующее выражение является недопустимым:

```cpp
volatile char *vch = new volatile char[20];
```

**`new`** Оператор не выделяет ссылочные типы, так как они не являются объектами.

**`new`** Оператор не может использоваться для выделения функции, но может использоваться для выделения указателей на функции. В следующем примере выделяется и затем освобождается массив из семи указателей на функции, которые возвращают целые числа.

```cpp
int (**p) () = new (int (*[7]) ());
delete *p;
```

Если вы используете оператор **`new`** без дополнительных аргументов и компилируете с параметром [/GX](../build/reference/gx-enable-exception-handling.md), [/EHa](../build/reference/eh-exception-handling-model.md)или [/EHs](../build/reference/eh-exception-handling-model.md) , компилятор создаст код для вызова оператора, **`delete`** Если конструктор выдаст исключение.

В следующем списке описаны элементы грамматики **`new`** :

*размещаем*<br/>
Предоставляет способ передачи дополнительных аргументов при перегрузке **`new`** .

*имя типа*<br/>
Определяет тип для распределения; может быть встроенным или пользовательским типом. Если спецификация типа является сложной, она может быть окружена круглыми скобками, чтобы принудительно реализовать порядок привязки.

*initializer*<br/>
Предоставляет значение для инициализированного объекта. Инициализаторы невозможно задать для массивов. **`new`** Оператор создает массивы объектов, только если у класса есть конструктор по умолчанию.

## <a name="example"></a>Пример

В следующем примере кода выделяется и освобождается массив символов и объект класса `CName`.

```cpp
// expre_new_Operator.cpp
// compile with: /EHsc
#include <string.h>

class CName {
public:
   enum {
      sizeOfBuffer = 256
   };

   char m_szFirst[sizeOfBuffer];
   char m_szLast[sizeOfBuffer];

public:
   void SetName(char* pszFirst, char* pszLast) {
     strcpy_s(m_szFirst, sizeOfBuffer, pszFirst);
     strcpy_s(m_szLast, sizeOfBuffer, pszLast);
   }

};

int main() {
   // Allocate memory for the array
   char* pCharArray = new char[CName::sizeOfBuffer];
   strcpy_s(pCharArray, CName::sizeOfBuffer, "Array of characters");

   // Deallocate memory for the array
   delete [] pCharArray;
   pCharArray = NULL;

   // Allocate memory for the object
   CName* pName = new CName;
   pName->SetName("Firstname", "Lastname");

   // Deallocate memory for the object
   delete pName;
   pName = NULL;
}
```

## <a name="example"></a>Пример

Если используется новая форма **`new`** оператора размещения, форма с аргументами в дополнение к размеру выделения, компилятор не поддерживает форму размещения **`delete`** оператора, если конструктор создает исключение. Например:

```cpp
// expre_new_Operator2.cpp
// C2660 expected
class A {
public:
   A(int) { throw "Fail!"; }
};
void F(void) {
   try {
      // heap memory pointed to by pa1 will be deallocated
      // by calling ::operator delete(void*).
      A* pa1 = new A(10);
   } catch (...) {
   }
   try {
      // This will call ::operator new(size_t, char*, int).
      // When A::A(int) does a throw, we should call
      // ::operator delete(void*, char*, int) to deallocate
      // the memory pointed to by pa2.  Since
      // ::operator delete(void*, char*, int) has not been implemented,
      // memory will be leaked when the deallocation cannot occur.

      A* pa2 = new(__FILE__, __LINE__) A(20);
   } catch (...) {
   }
}

int main() {
   A a;
}
```

## <a name="initializing-object-allocated-with-new"></a>Инициализация объектов, выделенных с помощью оператора new

Необязательное поле *инициализатора* включено в грамматику для **`new`** оператора. Это позволяет инициализировать новые объекты с помощью пользовательских конструкторов. Дополнительные сведения о том, как выполняется инициализация, см. в разделе [инициализаторы](../cpp/initializers.md). В следующем примере показано, как использовать выражение инициализации с **`new`** оператором:

```cpp
// expre_Initializing_Objects_Allocated_with_new.cpp
class Acct
{
public:
    // Define default constructor and a constructor that accepts
    //  an initial balance.
    Acct() { balance = 0.0; }
    Acct( double init_balance ) { balance = init_balance; }
private:
    double balance;
};

int main()
{
    Acct *CheckingAcct = new Acct;
    Acct *SavingsAcct = new Acct ( 34.98 );
    double *HowMuch = new double ( 43.0 );
    // ...
}
```

В этом примере объект `CheckingAcct` выделяется с помощью **`new`** оператора, но инициализация по умолчанию не задана. Поэтому вызывается конструктор по умолчанию для класса `Acct()`. Затем аналогичным образом выделяется объект `SavingsAcct` с единственным отличием: он явно инициализируется значением 34,98. Поскольку 34,98 имеет тип **`double`** , для работы с инициализацией вызывается конструктор, принимающий аргумент этого типа. Наконец, неклассовый тип `HowMuch` инициализируется значением 43,0.

Если объект имеет тип класса и этот класс имеет конструкторы (как в предыдущем примере), объект может инициализироваться **`new`** оператором только в том случае, если выполняется одно из следующих условий:

- Аргументы, предоставленные в инициализаторе, согласуются с аргументами конструктора.

- Класс имеет конструктор по умолчанию (конструктор, который можно вызвать без аргументов).

При выделении массивов с помощью оператора явная инициализация каждого элемента невозможна **`new`** ; вызывается только конструктор по умолчанию, если он имеется. Дополнительные сведения см. в разделе [аргументы по умолчанию](../cpp/default-arguments.md) .

Если выделение памяти завершается ошибкой (**оператор New** возвращает значение 0), инициализация не выполняется. Это обеспечивает защиту от попыток инициализировать данные, которые не существуют.

Как и в случае вызова функций, порядок вычисления выражений инициализации не определен. Кроме того, не следует полагаться на то, что эти выражения полностью вычислены до выделения памяти. Если выделение памяти завершается ошибкой и **`new`** оператор возвращает ноль, некоторые выражения в инициализаторе не могут быть полностью оценены.

## <a name="lifetime-of-objects-allocated-with-new"></a>Время жизни объектов, выделенных с помощью оператора new

Объекты, выделенные с помощью **`new`** оператора, не уничтожаются, когда закрывается область, в которой они определены. Поскольку **`new`** оператор возвращает указатель на объекты, которые он выделяет, программа должна определить указатель с подходящей областью для доступа к этим объектам. Например:

```cpp
// expre_Lifetime_of_Objects_Allocated_with_new.cpp
// C2541 expected
int main()
{
    // Use new operator to allocate an array of 20 characters.
    char *AnArray = new char[20];

    for( int i = 0; i < 20; ++i )
    {
        // On the first iteration of the loop, allocate
        //  another array of 20 characters.
        if( i == 0 )
        {
            char *AnotherArray = new char[20];
        }
    }

    delete [] AnotherArray; // Error: pointer out of scope.
    delete [] AnArray;      // OK: pointer still in scope.
}
```

После того как указатель `AnotherArray` в этом примере вышел за пределы области видимости, объект невозможно удалить.

## <a name="how-new-works"></a>Принцип работы оператора new

*Выражение распределения* — выражение, содержащее **`new`** оператор, выполняет три вещи:

- Находит и резервирует хранилище для объекта или объектов, которым нужно выделить память. После завершения этого этапа выделен требуемый объем памяти, но это еще не объект.

- Инициализирует объекты. После завершения инициализации имеется достаточно информации, чтобы выделенная память являлась объектом.

- Возвращает указатель на объекты типа указателя, производного от *new-Type-Name* или *Type-Name*. Программа использует этот указатель для доступа к новому объекту, которому выделена память.

**`new`** Оператор вызывает **оператор функции New**. Для массивов любого типа и для объектов, которые не относятся **`class`** к типу, **`struct`** или **`union`** , для выделения хранилища вызывается глобальная функция **:: operator new**. Объекты класса-типов могут определять **собственные статические** функции-члены для отдельных классов.

Когда компилятор обнаруживает **`new`** оператор для выделения объекта типа **Type**, он выдает вызов `type` **:: operator new (sizeof (** `type` **))** или, если не определен определенный пользователем **оператор New** , **:: оператор New (sizeof (** `type` **))**. Таким образом, **`new`** оператор может выделить правильный объем памяти для объекта.

> [!NOTE]
> Аргумент для **оператора New** имеет тип `size_t` . Этот тип определен в \<direct.h> , \<malloc.h> ,, \<memory.h> , \<search.h> \<stddef.h> , \<stdio.h> , \<stdlib.h> , \<string.h> и \<time.h> .

Параметр в грамматике разрешает указание *расположения* (см. статью грамматика для [оператора New](../cpp/new-operator-cpp.md)). Параметр *размещения* может использоваться только для определяемых пользователем реализаций **оператора New**; Он позволяет передавать дополнительные сведения **оператору New**. Выражение с полем *размещения* , например, `T *TObject = new ( 0x0040 ) T;` преобразуется в `T *TObject = T::operator new( sizeof( T ), 0x0040 );` , если класс T имеет оператор-член New, в противном случае — значение `T *TObject = ::operator new( sizeof( T ), 0x0040 );` .

Исходная цель поля *размещения* — разрешить выделение аппаратно зависимых объектов по указанным пользователем адресам.

> [!NOTE]
> Хотя в предыдущем примере показан только один аргумент в поле *размещения* , нет ограничений на количество дополнительных аргументов, которые можно передать **оператору** следующим образом.

Даже если для типа класса определен **оператор New** , глобальный оператор можно использовать в следующем примере:

```cpp
T *TObject =::new TObject;
```

Оператор разрешения области действия ( `::` ) принудительно использует глобальный **`new`** оператор.

## <a name="see-also"></a>См. также

[Выражения с унарными операторами](../cpp/expressions-with-unary-operators.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Операторы new и delete](../cpp/new-and-delete-operators.md)
