---
title: "Оператор New (C++) | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-language
ms.tgt_pltfrm: 
ms.topic: language-reference
dev_langs: C++
helpviewer_keywords: new keyword [C++]
ms.assetid: 69fee812-1c28-4882-8fda-d1ad17860004
caps.latest.revision: "11"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 68843f0619b5ebc057f83bdb4f49807a15fb86a1
ms.sourcegitcommit: 9a0a287d6940591523af959ebdac5affa36220da
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/25/2018
---
# <a name="new-operator-c"></a>Оператор new (C++)
Выделяет память для объекта или массива объектов *имя типа* из свободного хранилища и возвращает подходящим образом типизированный ненулевой указатель на объект.  
  
> [!NOTE]
>  Расширения компонентов Microsoft C++ обеспечивают поддержку ключевого слова `new` для добавления записей слота vtable. Дополнительные сведения см. в разделе [new (новый слот в vtable)](../windows/new-new-slot-in-vtable-cpp-component-extensions.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
[::] new [placement] new-type-name [new-initializer]  
[::] new [placement] ( type-name ) [new-initializer]  
```  
  
## <a name="remarks"></a>Примечания  
 В случае неудачи **новый** возвращает ноль или создает исключение; в разделе [новый и удаление операторов](../cpp/new-and-delete-operators.md) для получения дополнительной информации. Это поведение по умолчанию можно изменить, создав пользовательскую процедуру обработки исключений и вызвав [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) функции библиотеки времени выполнения с именем функции в качестве аргумента.  
  
 Сведения о том, как создать объект в управляемой куче см. в разделе [gcnew](../windows/ref-new-gcnew-cpp-component-extensions.md).  
  
 Когда **новый** — используется для выделения памяти для объекта класса C++, в конструктор объекта вызывается после выделения памяти.  
  
 Используйте [удаление](../cpp/delete-operator-cpp.md) оператор для освобождения памяти, выделенной с **новый** оператор.  
  
 В следующем примере выделяется и затем освобождается двумерный массив символов размером `dim` на 10. При выделении многомерного массива все измерения, кроме первого, должны быть константными выражениями, которые возвращают положительные значения; самое левое измерение массива может являться любым выражением, результатом которого является положительное значение. При выделении массива с помощью **новый** оператор, первое измерение может быть ноль — **новый** оператор возвращает уникальный указатель.  
  
```  
char (*pchar)[10] = new char[dim][10];  
delete [] pchar;  
```  
  
 *Имя типа* не может содержать **const**, `volatile`, объявления класса или объявления перечислений. Таким образом, следующее выражение является недопустимым:  
  
```  
volatile char *vch = new volatile char[20];  
```  
  
 **Новый** оператор не выделяет ссылочные типы, так как они не являются объектами.  
  
 **Новый** оператор не может использоваться для выделения функции, но он может использоваться для выделения указателей на функции. В следующем примере выделяется и затем освобождается массив из семи указателей на функции, которые возвращают целые числа.  
  
```  
int (**p) () = new (int (*[7]) ());  
delete *p;  
```  
  
 Если вы используете оператор **новый** без дополнительных аргументов и компиляция с [/GX](../build/reference/gx-enable-exception-handling.md), [/EHa](../build/reference/eh-exception-handling-model.md), или [/EHs](../build/reference/eh-exception-handling-model.md) параметр, компилятор будет создать код, вызывающий оператор **удалить** Если конструктор вызывает исключение.  
  
 В следующем списке описываются грамматические элементы **новый**:  
  
 *Размещение*  
 Предоставляет способ передачи дополнительных аргументов при перегрузке **новый**.  
  
 *type-name*  
 Определяет тип для распределения; может быть встроенным или пользовательским типом. Если спецификация типа является сложной, она может быть окружена круглыми скобками, чтобы принудительно реализовать порядок привязки.  
  
 *initializer*  
 Предоставляет значение для инициализированного объекта. Инициализаторы невозможно задать для массивов. **Новый** оператор создает массив объектов только в том случае, если класс имеет конструктор по умолчанию.  
  
## <a name="example"></a>Пример  
 В следующем примере кода выделяется и освобождается массив символов и объект класса `CName`.  
  
```  
// expre_new_Operator.cpp  
// compile with: /EHsc  
#include <string.h>  
  
class CName {  
public:  
   enum {  
      sizeOfBuffer = 256  
   };  
  
   char m_szFirst[sizeOfBuffer];  
   char m_szLast[sizeOfBuffer];  
  
public:  
   void SetName(char* pszFirst, char* pszLast) {  
     strcpy_s(m_szFirst, sizeOfBuffer, pszFirst);  
     strcpy_s(m_szLast, sizeOfBuffer, pszLast);  
   }  
  
};  
  
int main() {  
   // Allocate memory for the array  
   char* pCharArray = new char[CName::sizeOfBuffer];  
   strcpy_s(pCharArray, CName::sizeOfBuffer, "Array of characters");  
  
   // Deallocate memory for the array  
   delete [] pCharArray;             
   pCharArray = NULL;  
  
   // Allocate memory for the object  
   CName* pName = new CName;  
   pName->SetName("Firstname", "Lastname");  
  
   // Deallocate memory for the object  
   delete pName;  
   pName = NULL;  
}  
```  
  
## <a name="example"></a>Пример  
 При использовании новой формы размещения оператора **новый** , формы с аргументами в дополнение к размеру выделения, компилятор не поддерживает форму размещения оператора **удалить** оператор Если конструктор создает исключение. Пример:  
  
```  
// expre_new_Operator2.cpp  
// C2660 expected  
class A {  
public:  
   A(int) { throw "Fail!"; }  
};  
void F(void) {  
   try {  
      // heap memory pointed to by pa1 will be deallocated  
      // by calling ::operator delete(void*).  
      A* pa1 = new A(10);  
   } catch (...) {  
   }  
   try {  
      // This will call ::operator new(size_t, char*, int).  
      // When A::A(int) does a throw, we should call  
      // ::operator delete(void*, char*, int) to deallocate  
      // the memory pointed to by pa2.  Since  
      // ::operator delete(void*, char*, int) has not been implemented,  
      // memory will be leaked when the deallocation cannot occur.  
  
      A* pa2 = new(__FILE__, __LINE__) A(20);  
   } catch (...) {  
   }  
}  
  
int main() {  
   A a;  
}  
```  
  
## <a name="initializing-object-allocated-with-new"></a>Инициализация объектов, выделенных с помощью оператора new  
 Необязательный *инициализатора* поле включено в грамматику **новый** оператор. Это позволяет инициализировать новые объекты с помощью пользовательских конструкторов. Дополнительные сведения о выполнении инициализации см. в разделе [инициализаторы](../cpp/initializers.md). Следующий пример показывает, как можно использовать выражение инициализации с **новый** оператор:  
  
```  
// expre_Initializing_Objects_Allocated_with_new.cpp  
class Acct  
{  
public:  
    // Define default constructor and a constructor that accepts  
    //  an initial balance.  
    Acct() { balance = 0.0; }  
    Acct( double init_balance ) { balance = init_balance; }  
private:  
    double balance;  
};  
  
int main()  
{  
    Acct *CheckingAcct = new Acct;  
    Acct *SavingsAcct = new Acct ( 34.98 );  
    double *HowMuch = new double ( 43.0 );  
    // ...  
}  
```  
  
 В этом примере объект `CheckingAcct` выделяется с помощью **новый** указан оператор, но инициализация по умолчанию. Поэтому вызывается конструктор по умолчанию для класса `Acct()`. Затем аналогичным образом выделяется объект `SavingsAcct` с единственным отличием: он явно инициализируется значением 34,98. Поскольку значение 34,98 принадлежит типу **двойные**, для обработки инициализации вызывается конструктор, принимающий аргумент этого типа. Наконец, неклассовый тип `HowMuch` инициализируется значением 43,0.  
  
 Если объект является типом класса и этот класс содержит конструкторы (как в предыдущем примере), объект может быть инициализирован с **новый** оператор только в том случае, если выполняется одно из следующих условий:  
  
-   Аргументы, предоставленные в инициализаторе, согласуются с аргументами конструктора.  
  
-   Класс имеет конструктор по умолчанию (конструктор, который можно вызвать без аргументов).  
  
 Инициализация явный элемент можно сделать при выделении массивов с **новый** оператор; только конструктор по умолчанию вызывается при их наличии. В разделе [аргументы по умолчанию](../cpp/default-arguments.md) для получения дополнительной информации.  
  
 Если выделение памяти завершается с ошибкой (`operator new` возвращает значение 0), то инициализация не выполняется. Это обеспечивает защиту от попыток инициализировать данные, которые не существуют.  
  
 Как и в случае вызова функций, порядок вычисления выражений инициализации не определен. Кроме того, не следует полагаться на то, что эти выражения полностью вычислены до выделения памяти. Если происходит сбой выделения памяти и **новый** возвращает нуль, некоторые выражения в инициализаторе могут быть вычислены не полностью.  
  
## <a name="lifetime-of-objects-allocated-with-new"></a>Время жизни объектов, выделенных с помощью оператора new  
 Объекты, создаваемые с **новый** оператор, не удаляются при выходе из области видимости, в котором они определены. Поскольку **новый** оператор возвращает указатель на объекты, выделяется память, программа должна определить указатель с соответствующей областью видимости для обращения к этим объектам. Пример:  
  
```  
// expre_Lifetime_of_Objects_Allocated_with_new.cpp  
// C2541 expected  
int main()  
{  
    // Use new operator to allocate an array of 20 characters.  
    char *AnArray = new char[20];  
  
    for( int i = 0; i < 20; ++i )  
    {  
        // On the first iteration of the loop, allocate  
        //  another array of 20 characters.  
        if( i == 0 )  
        {  
            char *AnotherArray = new char[20];  
        }  
    }  
  
    delete [] AnotherArray; // Error: pointer out of scope.  
    delete [] AnArray;      // OK: pointer still in scope.  
}  
```  
  
 После того как указатель `AnotherArray` в этом примере вышел за пределы области видимости, объект невозможно удалить.  
  
## <a name="how-new-works"></a>Принцип работы оператора new  
 *Выражение выделения* — выражение, содержащее **новый** оператор — выполняет три действия:  
  
-   Находит и резервирует хранилище для объекта или объектов, которым нужно выделить память. После завершения этого этапа выделен требуемый объем памяти, но это еще не объект.  
  
-   Инициализирует объекты. После завершения инициализации имеется достаточно информации, чтобы выделенная память являлась объектом.  
  
-   Возвращает указатель на один или несколько объектов типа указателя, производный от *новым именем типа* или *имя типа*. Программа использует этот указатель для доступа к новому объекту, которому выделена память.  
  
 **Новый** оператор вызывает функцию `operator new`. Для массивов любого типа, а также для объектов, которые не имеют **класса**, `struct`, или **объединение** типы, глобальная функция **:: оператор new**, вызывается для выделения памяти. Объекты типа класса могут определять собственную статическую функцию-член `operator new` на уровне класса.  
  
 Когда компилятор встречает **новый** оператор, чтобы выделить объект типа `type`, он отправляет вызов для `type` **:: оператор new (sizeof (** `type` **))**  или, если нет пользовательских `operator new` определен, **:: оператор new (sizeof (** `type` **))**. Таким образом **новый** оператор можно выделить нужный объем памяти для объекта.  
  
> [!NOTE]
>  Аргумент `operator new` относится к типу **size_t**. Этот тип определен в \<direct.h >, \<malloc.h >, \<memory.h >, \<search.h >, \<stddef.h >, \<stdio.h >, \<stdlib.h >, \<string.h >, и \<time.h >.  
  
 Параметр в грамматике позволяет задавать *размещения* (см. грамматику для [оператор new](../cpp/new-operator-cpp.md)). *Размещения* параметр может использоваться только для пользовательских реализаций `operator new`; он обеспечивает дополнительную информацию для передачи `operator new`. Выражение с *размещения* поля, такие как `T *TObject = new ( 0x0040 ) T;` , преобразуется в `T *TObject = T::operator new( sizeof( T ), 0x0040 );` Если классе T имеется оператор-член новые возможности, в противном случае для `T *TObject = ::operator new( sizeof( T ), 0x0040 );`.  
  
 Изначально *размещения* было введено, чтобы разрешить аппаратно зависимым объектам память по адресам, определенным пользователем.  
  
> [!NOTE]
>  Несмотря на то, что в предыдущем примере показан только один аргумент в *размещения* поле, не существует ограничения на количество дополнительных аргументов могут передаваться `operator new` таким образом.  
  
 Даже если для типа класса определена функция `operator new`, приведенная в следующем примере форма позволяет использовать глобальный оператор.  
  
```  
T *TObject =::new TObject;  
```  
  
 Оператор разрешения области действия (`::`) Задает принудительное использование глобального **новый** оператор.  
  
## <a name="see-also"></a>См. также  
 [Выражения с унарными операторами](../cpp/expressions-with-unary-operators.md)   
 [Ключевые слова](../cpp/keywords-cpp.md)   
 [новые и удаление операторов](../cpp/new-and-delete-operators.md)