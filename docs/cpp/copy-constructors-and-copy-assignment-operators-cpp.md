---
title: Конструкторы копий и операторы присваивания копий (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- = operator [C++], copying objects
- assignment statements [C++], copying objects
- assignment operators [C++], for copying objects
- objects [C++], copying
- initializing objects, by copying objects
- copying objects
- assigning values to copy objects
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
ms.openlocfilehash: faf1a94e27f5a0a435d0a906661444f67709628e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87221800"
---
# <a name="copy-constructors-and-copy-assignment-operators-c"></a>Конструкторы копий и операторы присваивания копий (C++)

> [!NOTE]
> Начиная с C++ 11, в языке поддерживаются два вида присваивания: *копирование назначения* и *Перемещение*. В этой статье "присваивание" означает "присваивание копированием", если явно не указано другое. Сведения о назначении Move см. в разделе [конструкторы Move и операторы присваивания перемещения (C++)](move-constructors-and-move-assignment-operators-cpp.md).
>
> Как при операции назначения, так и при операции инициализации выполняется копирование объектов.

- **Назначение**: когда значение одного объекта присваивается другому объекту, первый объект копируется во второй объект. Таким образом,

    ```cpp
    Point a, b;
    ...
    a = b;
    ```

   приводит к тому, что значение `b` копируется в значение `a`.

- **Инициализация**: инициализация происходит при объявлении нового объекта, когда аргументы передаются в функции по значению или когда значения возвращаются из функций по значению.

Можно определить семантику копии объектов типа класса. Рассмотрим для примера такой код:

```cpp
TextFile a, b;
a.Open( "FILE1.DAT" );
b.Open( "FILE2.DAT" );
b = a;
```

Предыдущий код может означать "копировать содержимое FILE1.DAT в FILE2.DAT" или "игнорировать FILE2.DAT и сделать `b` вторым дескриптором FILE1.DAT". Необходимо вложить соответствующую семантику копирования в каждый класс следующим образом.

- С помощью оператора присваивания **operator =** вместе со ссылкой на тип класса в качестве возвращаемого типа и параметра, передаваемого по **`const`** ссылке, например `ClassName& operator=(const ClassName& x);` .

- С помощью конструктора копии.

Если конструктор копии не объявлен, компилятор создает конструктор копии для каждого члена.  Если оператор присваивания копированием не объявлен, компилятор создает оператор присваивания копированием для каждого члена. Объявление конструктора копии не подавляет созданный компилятором оператор присваивания копий, и наоборот. При реализации любого из этих способов рекомендуется также реализовать другой способ, чтобы значение кода было четким.

Конструктор копий принимает аргумент типа <em>Class-Name</em> <strong>&</strong> , где *Class-Name* — это имя класса, для которого определен конструктор. Пример:

```cpp
// spec1_copying_class_objects.cpp
class Window
{
public:
    Window( const Window& ); // Declare copy constructor.
    // ...
};

int main()
{
}
```

> [!NOTE]
> По возможности сделайте тип аргумента **`const`** <em>-имя класса</em> для конструктора копирования <strong>&</strong> . Это поможет избежать случайного изменения копируемого объекта конструктором копии. Он также позволяет копировать из **`const`** объектов.

## <a name="compiler-generated-copy-constructors"></a>Конструкторы копии, создаваемые компилятором

Созданные компилятором конструкторы копий, такие как пользовательские конструкторы копий, имеют один аргумент типа "ссылка на *имя-класса*". Исключением является то, что все базовые классы и классы элементов имеют конструкторы копий, объявленные как принимающие один аргумент типа **`const`** <em>Class-Name</em> <strong>&</strong> . В этом случае аргументом конструктора копии, созданным компилятором, также является **`const`** .

Если тип аргумента для конструктора копирования отсутствует **`const`** , инициализация путем копирования **`const`** объекта приводит к ошибке. Обратная неверно: Если аргумент имеет значение **`const`** , инициализацию можно выполнить путем копирования объекта, который не является **`const`** .

Созданные компилятором операторы присваивания следуют тому же шаблону, что и для **const.** Они принимают один аргумент типа <em>Class-Name</em> , <strong>&</strong> Если операторы присваивания во всех базовых классах и классов элементов не принимают аргументы типа **`const`** <em>Class-Name</em> <strong>&</strong> . В этом случае созданный классом оператор присваивания принимает **`const`** аргумент.

> [!NOTE]
> Если виртуальные базовые классы инициализируются конструкторами копии, создаются компиляторами или определяются пользователем, они инициализируются только один раз, во время создания.

Последствия аналогичны тем, которые имеет конструктор копии. Если тип аргумента не равен **`const`** , присваивание из **`const`** объекта приводит к ошибке. Обратная неверно: Если **`const`** значение присвоено значению, которое не является **`const`** , то назначение выполняется.

Дополнительные сведения о перегруженных операторах присваивания см. в разделе [назначение](../cpp/assignment.md).
