---
title: Конструкторы копий и операторы присваивания копий (C++) | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-language
ms.topic: language-reference
dev_langs:
- C++
helpviewer_keywords:
- = operator [C++], copying objects
- assignment statements [C++], copying objects
- assignment operators [C++], for copying objects
- objects [C++], copying
- initializing objects, by copying objects
- copying objects
- assigning values to copy objects
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 249182277473eebf5f11d4f6f3de1e8e7d275b61
ms.sourcegitcommit: 913c3bf23937b64b90ac05181fdff3df947d9f1c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2018
ms.locfileid: "46032618"
---
# <a name="copy-constructors-and-copy-assignment-operators-c"></a>Конструкторы копий и операторы присваивания копий (C++)

> [!NOTE]
> Начиная с версии C ++ 11, в языке поддерживаются два вида присваивания: *Копировать назначение* и *присваивание перемещением*. В этой статье "присваивание" означает "присваивание копированием", если явно не указано другое. Сведения о присваивании перемещением см. в разделе [конструкторы перемещения и операторы присваивания перемещения (C++)](move-constructors-and-move-assignment-operators-cpp.md).
>
> Как при операции назначения, так и при операции инициализации выполняется копирование объектов.

- **Назначение**: когда значение одного объекта присваивается другому объекту, первый объект копируется на второй объект. Поэтому

    ```cpp
    Point a, b;
    ...
    a = b;
    ```

   приводит к тому, что значение `b` копируется в значение `a`.

- **Инициализация**: инициализация происходит, если объект был объявлен, если аргументы функции передаются по значению или значения возвращаются из функции по значению.

Можно определить семантику копии объектов типа класса. Например, рассмотрим следующий код.

```cpp
TextFile a, b;
a.Open( "FILE1.DAT" );
b.Open( "FILE2.DAT" );
b = a;
```

Предыдущий код может означать "копировать содержимое FILE1.DAT в FILE2.DAT" или "игнорировать FILE2.DAT и сделать `b` вторым дескриптором FILE1.DAT". Необходимо вложить соответствующую семантику копирования в каждый класс следующим образом.

- С помощью оператора присваивания **оператор =** вместе со ссылкой на тип класса, как тип возвращаемого значения, а также параметр, который передается по **const** ссылки, например `ClassName& operator=(const ClassName& x);`.

- С помощью конструктора копии.

Если конструктор копии не объявлен, компилятор создает конструктор копии для каждого члена.  Если оператор присваивания копированием не объявлен, компилятор создает оператор присваивания копированием для каждого члена. Объявление конструктора копии не подавляет созданный компилятором оператор присваивания копий, и наоборот. При реализации любого из этих способов рекомендуется также реализовать другой способ, чтобы значение кода было четким.

Конструктор копии принимает аргумент типа <em>имя_класса</em><strong>&</strong>, где *имя_класса* — это имя класса, для которого определен конструктор. Пример:

```cpp
// spec1_copying_class_objects.cpp
class Window
{
public:
    Window( const Window& ); // Declare copy constructor.
    // ...
};

int main()
{
}
```

> [!NOTE]
> Сделайте тип аргумента конструктора копии **const** <em>имя_класса</em> <strong>&</strong> по возможности. Это поможет избежать случайного изменения копируемого объекта конструктором копии. Он также позволит выполнять копирование из **const** объектов.

## <a name="compiler-generated-copy-constructors"></a>Конструкторы копии, создаваемые компилятором

Конструкторы копии, созданный компилятором, например конструкторы копии, определяемые пользователем, имеют один аргумент типа «ссылка на *имя_класса*.» Исключение — когда все базовые классы и классов-членов объявлены конструкторы копии, принимающие один аргумент типа **const** <em>имя_класса</em><strong>&</strong>. В этом случае аргумент конструктора копии, создаваемые компилятором является также **const**.

Если тип аргумента для конструктора копии не **const**, инициализация путем копирования **const** возвращает ошибку. Не верно обратное: Если аргумент является **const**, выполнить инициализацию путем копирования объекта, не **const**.

Операторы присваивания, созданный компилятором следуют той же схеме, относится к **const.** Они принимают один аргумент типа <em>имя_класса</em> <strong>&</strong> Если операторы присваивания во всех базовых и дочерних классах принимают аргументы типа **const** <em>имя_класса</em><strong>&</strong>. Таким образом, созданный классом, принимает оператор присваивания **const** аргумент.

> [!NOTE]
> Если виртуальные базовые классы инициализируются конструкторами копии, создаются компиляторами или определяются пользователем, они инициализируются только один раз, во время создания.

Последствия аналогичны тем, которые имеет конструктор копии. Если аргумент имеет тип не **const**, назначение из **const** возвращает ошибку. Не верно обратное: Если **const** значение присваивается значение, которое не является **const**, присваивание завершается успешно.

Дополнительные сведения о перегруженных операторах присваивания см. в разделе [назначения](../cpp/assignment.md).