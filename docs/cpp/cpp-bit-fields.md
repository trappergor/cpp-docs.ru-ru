---
title: Битовые поля в C++
ms.date: 11/19/2018
helpviewer_keywords:
- bitfields [C++]
- fields [C++], bit
- bit fields
ms.assetid: 6f4b62e3-cc1d-4e5d-bf34-05904104f71a
ms.openlocfilehash: 7c2dbb6e2932265984c8cb4e1e34504921e5d666
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87221787"
---
# <a name="c-bit-fields"></a>Битовые поля в C++

Классы и структуры могут содержать члены, которые занимают меньше пространства в памяти, чем целочисленный тип. Эти члены определяются как битовые поля. Синтаксис для спецификации *объявления члена* в битовом поле приведен ниже:

## <a name="syntax"></a>Синтаксис

*декларатор* **:** *константное выражение*

## <a name="remarks"></a>Remarks

*Декларатор* (необязательный) — это имя, по которому осуществляется доступ к элементу в программе. Он должен иметь один из целочисленных типов (включая перечисляемые типы). *Константа-выражение* указывает количество битов, занимаемых элементом в структуре. Анонимные битовые поля, (т. е. битовые поля без идентификатора) можно использовать для заполнения.

> [!NOTE]
> Неименованное битовое поле Width 0 приводит к выравниванию следующего битового поля до границы следующего **типа** , где **Type** — это тип элемента.

В следующем примере объявляется структура, которая содержит битовые поля:

```cpp
// bit_fields1.cpp
// compile with: /LD
struct Date {
   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)
   unsigned short nMonthDay : 6;    // 0..31  (6 bits)
   unsigned short nMonth    : 5;    // 0..12  (5 bits)
   unsigned short nYear     : 8;    // 0..100 (8 bits)
};
```

На следующем рисунке показана концептуальная структура памяти для объекта типа `Date`.

![Структура памяти объекта данных](../cpp/media/vc38uq1.png "Структура памяти объекта данных") <br/>
Структура памяти объекта типа Date

Обратите внимание, что `nYear` имеет длину 8 бит и приведет к переполнению границы слова объявленного типа **`unsigned short`** . Поэтому он начинается в начале нового **`unsigned short`** . Совсем не обязательно, чтобы все битовые поля помещались в один объект базового типа; в зависимости от количества бит, запрошенных в объявлении, выделяются новые единицы хранения.

**Блок, относящийся только к системам Microsoft**

Данные, объявленные в качестве битовых полей, упорядочиваются от младшего бита к старшему, как показано на рисунке выше.

**Завершение блока, относящегося только к системам Майкрософт**

Объявление структуры может содержать неименованное поле длиной 0, как показано в следующем примере.

```cpp
// bit_fields2.cpp
// compile with: /LD
struct Date {
   unsigned nWeekDay  : 3;    // 0..7   (3 bits)
   unsigned nMonthDay : 6;    // 0..31  (6 bits)
   unsigned           : 0;    // Force alignment to next boundary.
   unsigned nMonth    : 5;    // 0..12  (5 bits)
   unsigned nYear     : 8;    // 0..100 (8 bits)
};
```

затем макет памяти показан на следующем рисунке:

![Компоновка объекта Date с битовым полем нулевой длины&#45;](../cpp/media/vc38uq2.png "Компоновка объекта Date с битовым полем нулевой длины&#45;") <br/>
Структура объекта типа Date с битовым полем нулевой длины

Базовый тип битового поля должен быть целочисленным типом, как описано в разделе [встроенные типы](../cpp/fundamental-types-cpp.md).

Если инициализатор для ссылки типа `const T&` является левосторонним значением, указывающим на битовое поле типа `T` , ссылка не привязывается к битовому полю напрямую. Вместо этого ссылка привязывается к временной инициализированной переменной для хранения значения битового поля.

## <a name="restrictions-on-bit-fields"></a>Ограничения для битовых полей

В следующем списке указаны ошибочные операции с битовыми полями:

- Получение адреса битового поля.

- Инициализация не **`const`** ссылки с битовым полем.

## <a name="see-also"></a>См. также раздел

[Классы и структуры](../cpp/classes-and-structs-cpp.md)
