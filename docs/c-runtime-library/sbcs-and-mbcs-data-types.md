---
title: Типы данных SBCS и MBCS | Документация Майкрософт
ms.custom: ''
ms.date: 04/11/2018
ms.technology:
- cpp-standard-libraries
ms.topic: reference
f1_keywords:
- MBCS
- SBCS
dev_langs:
- C++
helpviewer_keywords:
- SBCS and MBCS data types
- data types [C], MBCS and SBCS
ms.assetid: 4c3ef9da-e397-48d4-800e-49dba36db171
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: ccdec81251589ba36209f878f1fa8b727d7d2b98
ms.sourcegitcommit: be2a7679c2bd80968204dee03d13ca961eaa31ff
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32409281"
---
# <a name="sbcs-and-mbcs-data-types"></a>Типы данных SBCS и MBCS

Любая подпрограмма библиотеки среды выполнения Майкрософт с многобайтовой кодировкой, которая обрабатывает только один многобайтовый символ или один байт многобайтового символа, ожидает аргумент типа `unsigned int` (где 0x00 <= значение символа <= 0xFFFF и 0x00 <= значение байта <= 0xFF). Подпрограмма с многобайтовой кодировкой, обрабатывающая многобайтовые байты или символы в контексте строк, ожидает строку многобайтовых символов, представленную как указатель на тип `unsigned char`.

> [!CAUTION]
> Каждый байт многобайтового символа можно представить в виде 8-разрядного типа **char**. Однобайтовый символ типа **char** со значением, превышающем 0x7F, в однобайтовой или многобайтовой кодировке является отрицательным. Если такой символ преобразуется непосредственно в тип **int** или **long**, компилятор дополняет результат знаком, что может привести к непредсказуемым результатам.

Поэтому лучше представлять байт многобайтового символа как 8-разрядный тип `unsigned char`. Или во избежание отрицательного результата просто преобразуйте однобайтовый символ типа **char** в тип `unsigned char`, прежде чем преобразовывать его в тип **int** или **long**.

Поскольку некоторые функции обработки строк с однобайтовой кодировкой принимают параметры **char\*** (со знаком), при определении **_MBCS** отображается предупреждение компилятора о несоответствии типов. Существует три способа избежать этого предупреждения, они перечислены в порядке эффективности:

1. Использование подставляемых типобезопасных функций из файла TCHAR.H. Это поведение установлено по умолчанию.

1. Использование макроса перехода, содержащегося в файле TCHAR.H, посредством определения символа **_MB_MAP_DIRECT** в командной строке. После этого необходимо сопоставить типы вручную. Этот способ является наиболее быстрым, однако не обеспечивает типобезопасность.

1. Использование типобезопасных функций статической библиотеки, содержащихся в файле TCHAR.H. Для этого необходимо определить константу **_NO_INLINING** в командной строке. Это самый медленный и в то же время самый типобезопасный способ.

## <a name="see-also"></a>См. также

[Интернационализация](../c-runtime-library/internationalization.md)<br/>
[Универсальные подпрограммы среды выполнения C по категориям](../c-runtime-library/run-time-routines-by-category.md)<br/>
