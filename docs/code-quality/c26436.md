---
title: C26436
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26436
helpviewer_keywords:
- C26436
ms.assetid: 82d14d5d-5c5d-4e27-bdc8-268f9973a312
description: Правило CppCoreCheck, которое обеспечивает C++ Core Guidelines C. 35
ms.openlocfilehash: d182a35977f777af658a331510efaffb2d89fb89
ms.sourcegitcommit: e58918c45316d799c1952ca7797a85adbcd0c472
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/01/2020
ms.locfileid: "89281696"
---
# <a name="c26436-need_virtual_dtor"></a>C26436 NEED_VIRTUAL_DTOR

"Тип с виртуальной функцией должен иметь открытый виртуальный или защищенный невиртуальный деструктор".

[ **C++ Core Guidelines**: C. 35](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual): деструктор базового класса должен быть либо открытым, либо виртуальным, защищенным и невиртуальным.

Если класс определяет виртуальную функцию, она превращается в полиморфизм, что подразумевает, что производные классы могут изменять свое поведение, включая управление ресурсами и логику уничтожения. Поскольку клиентский код может вызывать polybase-типы посредством указателей на базовые классы, клиент не может явно выбрать, какое поведение подходит без образования производных. Чтобы обеспечить единообразное управление ресурсами, а уничтожение происходит в соответствии с правилами фактического типа, рекомендуется определить Открытый виртуальный деструктор. Если иерархия типов разработана таким образом, чтобы клиентский код не создавал объекты напрямую, деструкторы следует определять как защищенные, не являющиеся виртуальными.

## <a name="remarks"></a>Remarks

- Предупреждение отображается в первом определении виртуальной функции типа (он может быть виртуальным деструктором, если он не является открытым), один раз для каждого типа.
  - Поскольку определение может размещаться отдельно от объявления, оно может не всегда иметь ни одного из виртуальных описателей. Но предупреждение остается действительным — он проверяет фактическую "виртуальность" функции.

## <a name="example"></a>Пример
```cpp
namespace no_destructor
{
    struct base {
        virtual void foo() {} // C26436, see remarks to understand the placement of the warning.
    };
}
```

Предупреждение не отображается, если базовый класс содержит либо виртуальный Открытый деструктор, либо защищенный невиртуальный деструктор.
```cpp
namespace virtual_destructor
{
    struct base {
        virtual ~base();
        virtual void foo() {}
    };
}
namespace protected_destructor
{
    struct base {
        virtual void foo() {}
    protected:
        ~base() {}
    };
}
```
