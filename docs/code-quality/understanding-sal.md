---
title: Основные сведения о языке SAL
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: a94d6907-55f2-4874-9571-51d52d6edcfd
ms.openlocfilehash: fe48e31e5f4390915c4f3b5b6bf9c09bbd9fffe1
ms.sourcegitcommit: 6b3d793f0ef3bbb7eefaf9f372ba570fdfe61199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2020
ms.locfileid: "86403989"
---
# <a name="understanding-sal"></a>Основные сведения о языке SAL

Язык аннотирования Microsoft Source-Code (SAL) предоставляет набор заметок, которые можно использовать для описания того, как функция использует ее параметры, предположения, что она делает, и гарантирует, что она делает это после завершения. Заметки определяются в файле заголовка `<sal.h>` . Анализ кода Visual Studio для C++ использует аннотации SAL для изменения его анализа функций. Дополнительные сведения о языке SAL 2,0 для разработки драйверов Windows см. в статье [sal 2,0 заметки для драйверов Windows](/windows-hardware/drivers/devtest/sal-2-annotations-for-windows-drivers).

Изначально C и C++ предоставляют разработчикам только ограниченные способы согласованного определения намерений и расхождений. С помощью аннотаций SAL можно более подробно описать функции, чтобы разработчики, использующие их, могли лучше понять, как их использовать.

## <a name="what-is-sal-and-why-should-you-use-it"></a>Что такое SAL и зачем его использовать?

Говоря просто, SAL является недорогым способом позволить компилятору проверить ваш код.

### <a name="sal-makes-code-more-valuable"></a>SAL делает код более ценным

SAL поможет сделать разработку кода более понятной, как для людей, так и для средств анализа кода. Рассмотрим этот пример, в котором показана функция времени выполнения C `memcpy` :

```cpp

void * memcpy(
   void *dest,
   const void *src,
   size_t count
);
```

Можно ли узнать, что делает эта функция? При реализации или вызове функции необходимо поддерживать определенные свойства, чтобы обеспечить правильность программы. Просто взглянув на объявление, такое как в примере, вы не понимаете, что они представляют. Без аннотаций SAL вам пришлось полагаться на документацию или комментарии к коду. Вот как выглядит документация `memcpy` :

> " `memcpy` копирует *число* байтов из *src* в *dest*; `wmemcpy` *число* копий расширенных символов (2 байта). При перекрытии исходного и конечного буферов поведение `memcpy` не определено. Используется `memmove` для управления перекрывающимися областями.
> **Важно.** Убедитесь, что целевой буфер имеет тот же размер или больше, чем исходный буфер. Дополнительные сведения см. в разделе Предотвращение переполнения буфера.

В документации содержится несколько данных, которые предполагают, что код должен поддерживать определенные свойства для обеспечения правильности программы:

- `memcpy`копирует `count` байты из исходного буфера в целевой буфер.

- Конечный буфер должен быть не меньше размера исходного буфера.

Однако компилятор не может прочитать документацию или неформальные комментарии. Это не знает, что существует связь между двумя буферами и `count` , а также не может эффективно догадаться о связи. SAL может предоставить более наглядные сведения о свойствах и реализации функции, как показано ниже:

```cpp

void * memcpy(
   _Out_writes_bytes_all_(count) void *dest,
   _In_reads_bytes_(count) const void *src,
   size_t count
);
```

Обратите внимание, что эти заметки похожи на сведения в документации, но они более лаконичны и следуют семантическому шаблону. При чтении этого кода можно быстро понять свойства этой функции и избежать проблем безопасности переполнения буфера. Более того, Семантические шаблоны, предоставляемые SAL, могут повысить эффективность и эффективность автоматизированных средств анализа кода при раннем обнаружении потенциальных ошибок. Представьте себе, что кто-то пишет эту реализацию ошибками `wmemcpy` :

```cpp

wchar_t * wmemcpy(
   _Out_writes_all_(count) wchar_t *dest,
   _In_reads_(count) const wchar_t *src,
   size_t count)
{
   size_t i;
   for (i = 0; i <= count; i++) { // BUG: off-by-one error
      dest[i] = src[i];
   }
   return dest;
}
```

Эта реализация содержит общее сообщение об ошибке. К счастью, автор кода включил аннотацию размера буфера SAL — средство анализа кода может перехватить ошибку, анализируя только эту функцию.

### <a name="sal-basics"></a>Основы SAL

SAL определяет четыре основных типа параметров, которые классифицируются по шаблону использования.

|Категория|Аннотация параметра|Описание|
|--------------|--------------------------|-----------------|
|**Входные данные для вызываемой функции**|`_In_`|Данные передаются в вызываемую функцию и обрабатываются как доступная только для чтения.|
|**Вход в вызываемую функцию и вывод в вызывающий объект**|`_Inout_`|Пригодные для использования данные передаются в функцию и потенциально изменяются.|
|**Вывод в вызывающий объект**|`_Out_`|Вызывающий объект предоставляет только пространство для вызываемой функции для записи. Вызываемая функция записывает данные в это пространство.|
|**Вывод указателя на вызывающий объект**|`_Outptr_`|Как и **выходные данные в вызывающий объект**. Значение, возвращаемое вызываемой функцией, является указателем.|

Эти четыре основные аннотации можно сделать более явными различными способами. По умолчанию предполагается, что параметры указателей с заметками являются обязательными — они не должны иметь значение NULL, чтобы функция была выполнена. Наиболее часто используемый вариант основных заметок указывает на то, что параметр указателя является необязательным — если он равен NULL, функция может продолжать работать.

В этой таблице показано, как различать обязательные и необязательные параметры.

||Параметры обязательны|Параметры являются необязательными|
|-|-----------------------------|-----------------------------|
|**Входные данные для вызываемой функции**|`_In_`|`_In_opt_`|
|**Вход в вызываемую функцию и вывод в вызывающий объект**|`_Inout_`|`_Inout_opt_`|
|**Вывод в вызывающий объект**|`_Out_`|`_Out_opt_`|
|**Вывод указателя на вызывающий объект**|`_Outptr_`|`_Outptr_opt_`|

Эти аннотации помогают определить возможные неинициализированные значения и недопустимые использование пустых указателей в формальном и точном порядке. Передача значения NULL в обязательный параметр может вызвать сбой или привести к возвращению кода ошибки "сбой". В любом случае функция не может быть выполнена в своей работе.

## <a name="sal-examples"></a>Примеры SAL

В этом разделе приведены примеры кода для базовых аннотаций SAL.

### <a name="using-the-visual-studio-code-analysis-tool-to-find-defects"></a>Использование средства анализа Visual Studio Code для поиска дефектов

В примерах средство анализа Visual Studio Code используется вместе с аннотациями SAL для поиска дефектов кода. Вот как это сделать.

#### <a name="to-use-visual-studio-code-analysis-tools-and-sal"></a>Использование средств анализа кода Visual Studio и SAL

1. В Visual Studio откройте проект C++, содержащий аннотации SAL.

1. В строке меню выберите **Сборка**, **запустите анализ кода для решения**.

     Рассмотрим \_ пример в \_ этом разделе. При выполнении анализа кода на нем отображается следующее предупреждение:

    > **C6387 недопустимое значение параметра** "команду" может быть "0": это не соответствует спецификации функции "uncalled".

### <a name="example-the-_in_-annotation"></a>Пример. \_ Аннотация в \_ заметке

`_In_`Заметка указывает на следующее:

- Параметр должен быть допустимым и не будет изменяться.

- Функция будет считывать только из одноэлементного буфера.

- Вызывающий объект должен предоставить буфер и инициализировать его.

- `_In_`Указывает "только для чтения". Распространенной ошибкой является применение `_In_` к параметру, который `_Inout_` вместо этого должен иметь заметку.

- `_In_`параметр разрешен, но игнорируется анализатором для скаляров, не являющихся указателями.

```cpp
void InCallee(_In_ int *pInt)
{
   int i = *pInt;
}

void GoodInCaller()
{
   int *pInt = new int;
   *pInt = 5;

   InCallee(pInt);
   delete pInt;
}

void BadInCaller()
{
   int *pInt = NULL;
   InCallee(pInt); // pInt should not be NULL
}
```

При использовании Visual Studio Code анализа в этом примере проверяется, что вызывающие объекты передают указатель, отличный от NULL, в инициализированный буфер для `pInt` . В этом случае `pInt` указатель не может иметь значение null.

### <a name="example-the-_in_opt_-annotation"></a>Пример: \_ в \_ \_ заметке opt

`_In_opt_`тот же, что и `_In_` , за исключением того, что входной параметр может иметь значение null, поэтому функция должна проверить это.

```cpp

void GoodInOptCallee(_In_opt_ int *pInt)
{
   if(pInt != NULL) {
      int i = *pInt;
   }
}

void BadInOptCallee(_In_opt_ int *pInt)
{
   int i = *pInt; // Dereferencing NULL pointer 'pInt'
}

void InOptCaller()
{
   int *pInt = NULL;
   GoodInOptCallee(pInt);
   BadInOptCallee(pInt);
}
```

Visual Studio Codeный анализ проверяет, что функция проверяет наличие значения NULL перед обращением к буферу.

### <a name="example-the-_out_-annotation"></a>Пример. \_ Аннотация out \_

`_Out_`поддерживает общий сценарий, в котором передается указатель, не имеющий значения NULL, указывающий на буфер элемента, а функция инициализирует элемент. Вызывающему объекту не нужно инициализировать буфер перед вызовом; вызываемая функция обещает инициализировать ее перед возвратом.

```cpp
void GoodOutCallee(_Out_ int *pInt)
{
   *pInt = 5;
}

void BadOutCallee(_Out_ int *pInt)
{
   // Did not initialize pInt buffer before returning!
}

void OutCaller()
{
   int *pInt = new int;
   GoodOutCallee(pInt);
   BadOutCallee(pInt);
   delete pInt;
}
```

Средство анализа Visual Studio Code проверит, что вызывающий объект передает указатель, отличный от NULL, в буфер для `pInt` и что буфер инициализируется функцией перед возвратом.

### <a name="example-the-_out_opt_-annotation"></a>Пример. \_ Аннотация out \_ \_

`_Out_opt_`то же самое, что и `_Out_` , за исключением того, что параметру может быть присвоено значение null, поэтому функция должна проверить это.

```cpp
void GoodOutOptCallee(_Out_opt_ int *pInt)
{
   if (pInt != NULL) {
      *pInt = 5;
   }
}

void BadOutOptCallee(_Out_opt_ int *pInt)
{
   *pInt = 5; // Dereferencing NULL pointer 'pInt'
}

void OutOptCaller()
{
   int *pInt = NULL;
   GoodOutOptCallee(pInt);
   BadOutOptCallee(pInt);
}
```

Visual Studio Codeный анализ проверяет, что эта функция проверяет наличие значения NULL перед `pInt` разыменованием, и если не `pInt` имеет значение null, то буфер инициализируется функцией перед возвратом.

### <a name="example-the-_inout_-annotation"></a>Пример. \_ Аннотация InOut \_

`_Inout_`используется для добавления примечания к параметру указателя, который может быть изменен функцией. Указатель должен указывать на допустимые инициализированные данные перед вызовом, и даже если он изменяется, он по-прежнему должен иметь допустимое значение для возврата. Заметка указывает, что функция может свободно считывать из буфера с одним элементом и записывать в него. Вызывающий объект должен предоставить буфер и инициализировать его.

> [!NOTE]
> Like `_Out_` , `_Inout_` должен применяться к изменяемому значению.

```cpp
void InOutCallee(_Inout_ int *pInt)
{
   int i = *pInt;
   *pInt = 6;
}

void InOutCaller()
{
   int *pInt = new int;
   *pInt = 5;
   InOutCallee(pInt);
   delete pInt;
}

void BadInOutCaller()
{
   int *pInt = NULL;
   InOutCallee(pInt); // 'pInt' should not be NULL
}
```

Visual Studio Codeный анализ проверяет, что вызывающие объекты передают указатель, отличный от NULL, в инициализированный буфер для `pInt` , и что перед возвратом `pInt` все еще имеет значение, отличное от NULL, и буфер инициализируется.

### <a name="example-the-_inout_opt_-annotation"></a>Пример: \_ Аннотация по \_ требованию \_ InOut

`_Inout_opt_`тот же, что и `_Inout_` , за исключением того, что входной параметр может иметь значение null, поэтому функция должна проверить это.

```cpp
void GoodInOutOptCallee(_Inout_opt_ int *pInt)
{
   if(pInt != NULL) {
      int i = *pInt;
      *pInt = 6;
   }
}

void BadInOutOptCallee(_Inout_opt_ int *pInt)
{
   int i = *pInt; // Dereferencing NULL pointer 'pInt'
   *pInt = 6;
}

void InOutOptCaller()
{
   int *pInt = NULL;
   GoodInOutOptCallee(pInt);
   BadInOutOptCallee(pInt);
}
```

Visual Studio Codeный анализ проверяет, что эта функция проверяет наличие значения NULL перед обращением к буферу, и если не `pInt` имеет значение null, то буфер инициализируется функцией перед возвратом.

### <a name="example-the-_outptr_-annotation"></a>Пример. \_ Аннотация аутптр \_

`_Outptr_`используется для аннотации параметра, который должен возвращать указатель.  Сам параметр не должен иметь значение NULL, а вызываемая функция возвращает в нее указатель, отличный от NULL, и этот указатель указывает на инициализированные данные.

```cpp
void GoodOutPtrCallee(_Outptr_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 5;

   *pInt = pInt2;
}

void BadOutPtrCallee(_Outptr_ int **pInt)
{
   int *pInt2 = new int;
   // Did not initialize pInt buffer before returning!
   *pInt = pInt2;
}

void OutPtrCaller()
{
   int *pInt = NULL;
   GoodOutPtrCallee(&pInt);
   BadOutPtrCallee(&pInt);
}
```

Visual Studio Codeный анализ проверяет, что вызывающий объект передает указатель, отличный от NULL `*pInt` , для, и что буфер инициализируется функцией перед возвратом.

### <a name="example-the-_outptr_opt_-annotation"></a>Пример: \_ аутптр \_ \_ Аннотация

`_Outptr_opt_`то же самое `_Outptr_` , что и, за исключением того, что параметр является необязательным — вызывающий объект может передать пустой указатель для параметра.

```cpp
void GoodOutPtrOptCallee(_Outptr_opt_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 6;

   if(pInt != NULL) {
      *pInt = pInt2;
   }
}

void BadOutPtrOptCallee(_Outptr_opt_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 6;
   *pInt = pInt2; // Dereferencing NULL pointer 'pInt'
}

void OutPtrOptCaller()
{
   int **ppInt = NULL;
   GoodOutPtrOptCallee(ppInt);
   BadOutPtrOptCallee(ppInt);
}
```

Visual Studio Codeный анализ проверяет, что эта функция проверяет наличие значения NULL перед `*pInt` разыменованием, и что буфер инициализируется функцией перед возвратом.

### <a name="example-the-_success_-annotation-in-combination-with-_out_"></a>Пример: \_ Аннотация успеха \_ в сочетании с \_ out\_

Заметки можно применять к большинству объектов.  В частности, можно закомментировать всю функцию.  Одной из самых очевидных характеристик функции является то, что она может завершиться успешно или неудачно. Но, как и в связи между буфером и его размером, C/C++ не может выражать успешную или неудачную работу функции. С помощью `_Success_` аннотации можно сказать, как выглядит успешная функция.  Параметром для `_Success_` заметки является просто выражение, которое, если оно равно true, указывает, что функция выполнена успешно. Выражение может быть любым, которое может обрабатывать средство синтаксического анализа заметок. Эффекты заметок после возврата функции применимы только в случае, если функция выполнена. В этом примере показано `_Success_` , как взаимодействует с `_Out_` , чтобы выполнить нужное действие. `return`Для представления возвращаемого значения можно использовать ключевое слово.

```cpp
_Success_(return != false) // Can also be stated as _Success_(return)
bool GetValue(_Out_ int *pInt, bool flag)
{
   if(flag) {
      *pInt = 5;
      return true;
   } else {
      return false;
   }
}
```

`_Out_`Заметка приводит к тому, что Visual Studio Codeный анализ проверит, что вызывающий объект передает указатель, отличный от NULL, в буфер для `pInt` и что буфер инициализируется функцией перед возвратом.

## <a name="sal-best-practice"></a>Рекомендации по SAL

### <a name="adding-annotations-to-existing-code"></a>Добавление заметок к существующему коду

SAL — это мощная технология, которая может помочь повысить безопасность и надежность кода. После изучения SAL можно применить новые навыки к повседневной работе. В новом коде спецификации на основе SAL можно использовать по принципу разработки. в старом коде можно добавлять заметки постепенно и таким образом повышать их преимущества при каждом обновлении.

У общедоступных заголовков Майкрософт уже есть аннотации. Поэтому мы рекомендуем использовать в своих проектах, что сначала закомментировать функции и функции конечных узлов, вызывающие API-интерфейсы Win32, чтобы получить наибольшее преимущество.

### <a name="when-do-i-annotate"></a>Когда делать аннотации?

Ниже приведены некоторые рекомендации.

- Закомментировать все параметры указателя.

- Закомментировать заметки диапазона значений, чтобы анализ кода мог обеспечить безопасность буфера и указателя.

- Закомментировать правила блокировки и блокировать побочные эффекты. Дополнительные сведения см. в разделе [Аннотирование режима блокировки](../code-quality/annotating-locking-behavior.md).

- Добавление заметка к свойствам драйвера и другим свойствам, зависящим от домена.

Кроме того, можно добавить заметки ко всем параметрам, чтобы сделать свою намерение понятной, чтобы упростить проверку выполнения заметок.

## <a name="see-also"></a>См. также раздел

- [Использование аннотаций SAL для сокращения количества дефектов в коде C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md)
- [Создание примечаний к параметрам и возвращаемым значениям функций](../code-quality/annotating-function-parameters-and-return-values.md)
- [Аннотация поведения функций](../code-quality/annotating-function-behavior.md)
- [Аннотация структур и классов](../code-quality/annotating-structs-and-classes.md)
- [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md)
- [Указание времени и места применения примечания](../code-quality/specifying-when-and-where-an-annotation-applies.md)
- [Рекомендации и примеры](../code-quality/best-practices-and-examples-sal.md)
