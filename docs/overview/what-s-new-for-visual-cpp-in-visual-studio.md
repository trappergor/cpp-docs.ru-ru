---
title: Новые возможности C++ в Visual Studio
ms.date: 11/15/2017
ms.technology: cpp-ide
ms.assetid: 8801dbdb-ca0b-491f-9e33-01618bff5ae9
author: mikeblome
ms.author: mblome
ms.openlocfilehash: bdf9775702b2c7099bcacc82fd462e3c1ff245bc
ms.sourcegitcommit: 5cecccba0a96c1b4ccea1f7a1cfd91f259cc5bde
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2019
ms.locfileid: "58782331"
---
# <a name="whats-new-for-c-in-visual-studio-2017"></a>Новые возможности C++ в Visual Studio 2017

В Visual Studio 2017 реализовано множество изменений и исправлений для среды C++. Мы исправили более 250 ошибок и сообщили о проблемах с компилятором и средствами, многие из которых были отправлены клиентами с помощью инструментов [Сообщить о проблеме](/visualstudio/how-to-report-a-problem-with-visual-studio-2017) и [Отправить предложение](https://visualstudio.uservoice.com/) в разделе **Отправить отзыв**. Спасибо, что сообщаете нам об ошибках! Дополнительные сведения о новых возможностях всех компонентов Visual Studio см. на странице [Новые возможности в Visual Studio 2017](/visualstudio/ide/whats-new-in-visual-studio).

<!--The compiler and tools version number in Visual Studio 2017 is 14.10.24629. -->

## <a name="c-compiler"></a>компилятор C++

### <a name="c-conformance-improvements"></a>Улучшение соответствия C++

В данном выпуске мы обновили компилятор C++ и стандартную библиотеку, добавив расширенную поддержку функций C++11 и C++14, а также предварительную поддержку некоторых функций, которые должны появиться в стандарте C++17. Подробные сведения см. в статье [C++ conformance improvements in Visual Studio 2017](cpp-conformance-improvements-2017.md) (Улучшения соответствия C++ в Visual Studio 2017).

**Visual Studio 2017 версии 15.5**: Компилятор поддерживает около 75 % новых возможностей C++17, включая структурированные привязки, лямбда-выражения `constexpr`, `if constexpr`, встроенные переменные, выражения свертывания и добавление `noexcept` в систему типов. Они доступны в параметре **/std:c++17**. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2017](cpp-conformance-improvements-2017.md).

**Visual Studio 2017 версии 15.7**: Набор инструментов компилятора MSVC в Visual Studio версии 15.7 теперь соответствует стандарту C++. Дополнительные сведения см. в статьях [Announcing: MSVC Conforms to the C++ Standard](https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/) (Объявление: MSVC соответствует стандарту C++) и [Соответствие стандартам языка Visual C++](visual-cpp-language-conformance.md).

### <a name="new-compiler-options"></a>Новые параметры компилятора

- [/permissive-](../build/reference/permissive-standards-conformance.md): включение всех параметров компилятора, обеспечивающих строгое соответствие стандартам, и отключение большей части расширений от Майкрософт (но не `__declspec(dllimport)`, например). В Visual Studio 2017 версии 15.5 этот параметр включен по умолчанию.  Режим соответствия **/permissive-** включает поддержку двухфазного поиска имени. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2017](cpp-conformance-improvements-2017.md).

- [/diagnostics](../build/reference/diagnostics-compiler-diagnostic-options.md): отображение номера строки, номера строки и столбца либо номера строки, столбца и курсора в строке кода, где найдена ошибка или предупреждение системы диагностики.

- [/debug:fastlink](../build/reference/debug-generate-debug-info.md): ускорение компоновки на 30 % (по сравнению с Visual Studio 2015) без копирования всех сведений об отладке в PDB-файл. PDB-файл указывает на отладочную информацию для файлов объекта и библиотеки, используемых для создания исполняемого файла. См. статьи [Ускорение цикла сборки C++ в VS "15"с помощью /Debug:fastlink](https://blogs.msdn.microsoft.com/vcblog/2016/10/05/faster-c-build-cycle-in-vs-15-with-debugfastlink/) и [Рекомендации по повышению скорости сборок C++ в Visual Studio](https://blogs.msdn.microsoft.com/vcblog/2016/10/26/recommendations-to-speed-c-builds-in-visual-studio/).

- В Visual Studio 2017 можно использовать [/sdl](../build/reference/sdl-enable-additional-security-checks.md) с [/await](../build/reference/await-enable-coroutine-support.md). Мы удалили ограничение [/RTC](../build/reference/rtc-run-time-error-checks.md) для соподпрограмм.

   **Visual Studio 2017 версия 15.3**:

- [/std:c++14 и /std:c++latest](../build/reference/std-specify-language-standard-version.md): эти параметры компилятора позволяют выбирать в проекте конкретные версии языка программирования C++, соответствующие стандарту ISO. Большинство новых стандартных функций защищены с помощью параметра **/std:c++latest**.

- [/std:c++17](../build/reference/std-specify-language-standard-version.md) включает набор функций C++17, который реализован с помощью компилятора. Этот параметр отключает компилятор и поддержку стандартной библиотеки для измененных и новых функций в более поздних версиях рабочего проекта и исключает обновления C++ Standard после выхода C++17. Чтобы включить эти функции, используйте параметр **/std:c++latest**.

### <a name="codegen-security-diagnostics-and-versioning"></a>Создание кода, безопасность, диагностика и управления версиями

В этом выпуске представлено несколько улучшений в области оптимизации и создания кода, управления версиями набора инструментов и диагностики. К важным улучшениям можно отнести следующие:

- Улучшенное создание кода циклов. Поддержка автоматической векторизации деления целочисленных констант и улучшенное распознавание шаблонов memset.
- Повышенная защищенность кода. Более полная диагностика компилятора при переполнении буфера. Параметр [/guard:cf](../build/reference/guard-enable-control-flow-guard.md) теперь обеспечивает защиту операторов switch, которые создают таблицы переходов.
- Управление версиями. Значение встроенного препроцессорного макроса **\_MSC\_VER** теперь монотонно обновляется при каждом обновлении набора инструментов Visual C++. Дополнительные сведения см. в статье [Visual C++ Compiler Version](https://blogs.msdn.microsoft.com/vcblog/2016/10/05/visual-c-compiler-version/) (Версия компилятора Visual C++).
- Новое расположение набора инструментов. Компилятор и связанные средства сборки имеют новое расположение и структуру каталогов на компьютере разработки. Новый макет позволяет параллельно устанавливать несколько версий компилятора. Дополнительные сведения см. в статье [Макет инструментов компилятора в Visual Studio "15"](https://blogs.msdn.microsoft.com/vcblog/2016/10/07/compiler-tools-layout-in-visual-studio-15/).
- Улучшенная диагностика. В окне вывода теперь отображается столбец, в котором произошла ошибка. Дополнительные сведения см. в статье [Усовершенствования функций диагностики компилятора C++ в VS "15" Preview 5](https://blogs.msdn.microsoft.com/vcblog/2016/10/05/c-compiler-diagnostics-improvements-in-vs-15-rc/).
- При использовании совместных подпрограмм экспериментальное ключевое слово **yield** (в параметре **/await**) удалено. Нужно обновить код для использования `co_yield` вместо него. Дополнительные сведения см. в [блоге команды разработчиков Visual C++](https://blogs.msdn.microsoft.com/vcblog/).

**Visual Studio 2017 версия 15.3**:

дополнительные улучшения диагностики в компиляторе. Дополнительные сведения см. в статье [Diagnostic Improvements in Visual Studio 2017 15.3.0](https://blogs.msdn.microsoft.com/vcblog/2017/07/21/diagnostic-improvements-in-vs2017-15-3-0/) (Улучшения диагностики в Visual Studio 2017 версии 15.3.0).

**Visual Studio 2017 версии 15.5**:

улучшение производительности времени выполнения Visual C++ благодаря повышению качества генерируемого кода. Это означает, что можно просто перекомпилировать код, и приложение будет работать быстрее. Представлен ряд совершенно новых оптимизаций компилятора, например векторизация условных скалярных хранилищ, объединение вызовов функций `sin(x)` и `cos(x)` в новую функцию `sincos(x)` и устранение избыточных инструкций из оптимизатора SSA. Другие виды оптимизации компилятора являются усовершенствованиями существующих функциональных возможностей, например эвристика векторизатора для условных выражений, улучшенные оптимизации цикла и codegen функции min и max. Компоновщик имеет новую и более быструю реализацию **/OPT:ICF,** что может привести к 9-процентному ускорению времени компоновки, также доступны другие улучшения производительности инкрементной компоновки. Дополнительные сведения см. в разделах [Параметр /OPT (оптимизации)](../build/reference/opt-optimizations.md) и [Параметр /INCREMENTAL (инкрементная компоновка)](../build/reference/incremental-link-incrementally.md).

Компилятор Microsoft C++ поддерживает AVX-512 от Intel, включая инструкции по длине вектора, которые привносят новые функции AVX-512 в 128- и 256-битные регистры.

Параметр [/Zc:noexceptTypes-](../build/reference/zc-noexcepttypes.md) можно использовать для возврата к версии C++14 `noexcept` при использовании режима C++17 в целом. Это позволяет обновить исходный код для соответствия C++17, не переписывая весь код `throw()`. Дополнительные сведения см. в разделе [Удаление спецификации динамических исключений и noexcept](cpp-conformance-improvements-2017.md#noexcept_removal).

**Visual Studio 2017 версии 15.7**:

- Новый переключатель компилятора [/Qspectre ](../build/reference/qspectre.md) предназначен для противодействия упреждающему исполнению атак по сторонним каналам. Дополнительные сведения см. в записи блога [Spectre mitigations in MSVC](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/) (Устранение рисков Spectre в MSVC).
- Новое диагностическое предупреждение для устранения рисков Spectre. Дополнительные сведения см. в записи блога [Spectre diagnostic in Visual Studio 2017 Version 15.7 Preview 4](https://blogs.msdn.microsoft.com/vcblog/2018/04/20/spectre-diagnostic-in-visual-studio-2017-version-15-7-preview-4/) (Устранение рисков Spectre в Visual Studio 2017 версии 15.4 предварительной версии 4).
- Новое значение для параметра /Zc **/Zc:__cplusplus** обеспечивает корректное информирование о поддержке стандарта C++. Например, если этот переключатель установлен и компилятор находится в режиме /std:c++17, значение будет расширено до **201703L**. Дополнительные  сведения см. в записи блога [MSVC now correctly reports __cplusplus](https://blogs.msdn.microsoft.com/vcblog/2018/04/09/msvc-now-correctly-reports-__cplusplus/) (MSVC теперь корректно сообщает значение __cplusplus).

## <a name="c-standard-library-improvements"></a>Улучшения стандартной библиотеки C++

- Незначительные усовершенствования диагностики `basic_string` `_ITERATOR_DEBUG_LEVEL != 0`. При активации проверки IDL в механизме обработки строк теперь указывается конкретное поведение, которое стало причиной этого. Например, вместо "string iterator not dereferencable" (итератор строки не является разыменуемым) вы получите сообщение "cannot dereference string iterator because it is out of range (e.g. an end iterator)" (не удается разыменовать итератор строки, так как он выходит за пределы диапазона, например конечный итератор).
- Улучшение производительности: выполненные перегрузки `basic_string::find(char)` вызывают `traits::find` только один раз. Ранее это было реализовано в качестве общего механизма поиска строки для строки длиной 1.
- Улучшение производительности: `basic_string::operator==` теперь проверяет размер строки перед сравнением содержимого строк.
- Улучшение производительности: удалена взаимозависимость элементов управления в `basic_string`, которая вызывала трудности при анализе оптимизатором компилятора. Обратите внимание, что для всех коротких строк вызов `reserve` по-прежнему имеет ненулевое значение затрат при отсутствии выполняемых операций.
- Добавлены \<any\>, \<string_view\>, `apply()`, `make_from_tuple()`.
- `std::vector` был переработан для обеспечения правильной работы и производительности: присвоение псевдонима во время вставки и назначения места теперь обрабатывается правильно, в соответствии с требованиями стандарта; посредством `move_if_noexcept()` и другой логики предоставляется надежная гарантия исключения в тех случаях, когда того требует стандарт, а при вставке или назначении места выполняется меньше операций с элементами.
- Стандартная библиотека C++ теперь избегает разыменования пустых (NULL) указателей.
- Добавлены \<optional\>, \<variant\>, `shared_ptr::weak_type` и \<cstdalign\>.
- Включено C++14 `constexpr` в `min(initializer_list)`, `max(initializer_list)`, и `minmax(initializer_list)`, и `min_element()`, `max_element()`, и `minmax_element()`.
- Улучшена производительность `weak_ptr::lock()`.
- Исправлен оператор присваивания перемещением `std::promise`, из-за которого раньше в коде могла возникнуть вечная блокировка.
- Устранены ошибки в компиляторе, связанные с неявным преобразованием `atomic<T*>` в `T*`.
- `pointer_traits<Ptr>` теперь корректно обнаруживает `Ptr::rebind<U>`.
- Исправлен отсутствующий квалификатор `const` в операторе вычитания `move_iterator`.
- Исправлено автоматическое неправильное создание кода для определяемых пользователем распределителей с отслеживанием состояния, запрашивающих `propagate_on_container_copy_assignment` и `propagate_on_container_move_assignment`.
- `atomic<T>` теперь допускает перегруженные `operator&()`.
- Для повышения скорости работы компилятора заголовки стандартной библиотеки C++ теперь не включают объявления для ненужных встроенных функций компилятора.
- Немного улучшилась диагностика компилятора для неверных вызовов `bind()`.
- Производительность конструкторов перемещения `std::string`и `std::wstring` повышена более чем в 3 раза.

Полный список стандартных библиотек в см. в статье [Standard Library Fixes In VS 2017 RTM](https://blogs.msdn.microsoft.com/vcblog/2017/02/06/stl-fixes-in-vs-2017-rtm/) (Исправления стандартной библиотеки в Visual Studio 2017 RTM).

### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

#### <a name="c17-features"></a>Функции C++17

Реализовано несколько дополнительных функций C++17. Дополнительные сведения см. в статье [Соответствие стандартам языка Visual C++](cpp-conformance-improvements-2017.md#improvements_153).

#### <a name="other-new-features"></a>Другие новые функции

- Реализовано исправление P0602R0: variant и optional должны распространять тривиальность копирования и перемещения.
- Стандартная библиотека теперь официально допускает отключение динамической RTTI с помощью параметра [/GR-](../build/reference/gr-enable-run-time-type-information.md). Для `dynamic_pointer_cast()` и `rethrow_if_nested()` изначально требуется `dynamic_cast`, поэтому стандартная библиотека теперь помечает их как `=delete` в параметре **/GR-**.
- Даже если динамическая RTTI отключена через **/GR-**, статистическая RTTI (в форме `typeid(SomeType)`) все еще доступна и позволяет использовать несколько компонентов стандартной библиотеки. Стандартная библиотека теперь также поддерживает отключение через **/D\_HAS\_STATIC\_RTTI=0**. Обратите внимание, что в этом случае будут отключены функции-члены `std::any`, `target()` и `target_type()` для `std::function` и дружественная функция-член `get_deleter()` для `std::shared_ptr` и `std::weak_ptr`.

#### <a name="correctness-fixes-in-visual-studio-2017-version-153"></a>Исправления ошибок в Visual Studio 2017 версии 15.3

- Теперь контейнеры стандартной библиотеки выполняют приведение `max_size()` в `numeric_limits<difference_type>::max()`, а не `max()` `size_type`. Это гарантирует, что результат `distance()` с итераторами из этого контейнера можно представить в возвращаемом типе `distance()`.
- Исправлена отсутствующая специализация `auto_ptr<void>`.
- Алгоритмы `for_each_n()`, `generate_n()` и `search_n()` ранее не удавалось скомпилировать, так как аргумент length не был целочисленного типа. Теперь они пытаются преобразовать нецелочисленные типы lengths в `difference_type` итераторов.
- `normal_distribution<float>` больше не выдает предупреждения в стандартной библиотеке об ограничении из типа double во float.
- Исправлены некоторые операции `basic_string`, которые сравнивали с `npos` вместо `max_size()` при проверке максимального размера переполнения.
- `condition_variable::wait_for(lock, relative_time, predicate)` приходилось ожидать в течение всего относительного времени в случае ложного пробуждения. Теперь он будет ожидать только в течение одного интервала относительного времени.
- `future::get()` теперь не допускает `future`, как того требует стандарт.
- `iterator_traits<void *>` являлся критической ошибкой, так как он пытался сформировать `void&`. Теперь он становится пустой структурой, позволяющей использовать `iterator_traits` в условиях SFINAE is iterator.
- Некоторые предупреждения, выдававшиеся в **-Wsystem-headers** Clang, были исправлены.
- Кроме того, исправлена ошибка "Спецификация исключений в объявлении не соответствует предыдущему объявлению", о которой сообщал Clang **-Wmicrosoft-exception-spec**.
- Кроме того, исправлены предупреждения упорядочивания mem-initializer-list, о которых сообщают Clang и C1XX.
- Неупорядоченные контейнеры не переключают свое хэширование или предикаты при переключении контейнеров. Теперь они это делают.
- Многие операции переключения контейнеров теперь помечены как `noexcept` (так как наша стандартная библиотека никогда не будет выдавать исключение при обнаружении неопределенного условия поведения non-`propagate_on_container_swap` non-equal-allocator).
- Многие операции `vector<bool>` теперь помечены как `noexcept`.
- Стандартная библиотека теперь будет обеспечивать сопоставление распределителя `value_type` (в режиме C++17) с помощью отказа.
- Исправлены некоторые условия, при которых self-range-insert в `basic_string` будет шифровать содержимое строки. (Обратите внимание, что использование self-range-insert в векторах все еще запрещено стандартной библиотекой.)
- `basic_string::shrink_to_fit()` больше не затрагивается `propagate_on_container_swap`распределителя.
- `std::decay` теперь обрабатывает недопустимые типы функций (например, типы функций с квалификацией типа cv или ref).
- Изменены директивы включения для использования правильного учета регистра и косых черт, улучшая мобильность.
- Исправлено предупреждение C4061 "перечислитель *перечислитель* в параметре перечисления *перечисление* неявно обработан меткой регистра". Это предупреждение отключено по умолчанию и было исправлено в качестве исключения в общей политике предупреждений в стандартной библиотеке. (В стандартной библиотеке не используется **/W4**, но используется **/Wall**. Множество отключенных по умолчанию предупреждений срабатывают слишком часто и не предназначены для постоянного использования.)
- Улучшены проверки отладки `std::list`. Итераторы списка теперь проверяют `operator->()`, а `list::unique()` помечает итераторы как недействительные.
- Исправлено метапрограммирование uses-allocator в `tuple`.

#### <a name="performancethroughput-fixes"></a>Исправления производительности и пропускной способности

- Устранена проблема взаимодействия с `noexcept`, которая не позволяла встраивать реализацию `std::atomic` в функции, которые используют структурированную обработку исключений (SEH).
- Изменена внутренняя функция стандартной библиотеки `_Deallocate()` для оптимизации в коде меньшего размера, позволяя встроить ее в большее количество мест.
- Изменен `std::try_lock()` для использования расширения пакета вместо рекурсии.
- Улучшен алгоритм предотвращения взаимоблокировки `std::lock()` при использовании операций `lock()` вместо обращения ко всем методам `try_lock()` блокировки.
- Включена оптимизация именованных возвращаемых значений в `system_category::message()`.
- `conjunction` и `disjunction` теперь создает экземпляры типов N + 1 вместо 2N + 2.
- `std::function` больше не создает экземпляры механизмов поддержки распределителя для каждого вызываемого элемента с удалением типа, улучшая пропускную способность и уменьшая размер .obj в программах, которые передают много различных лямбда-выражений в `std::function`.
- `allocator_traits<std::allocator>` содержит вручную встроенные операции `std::allocator`, уменьшая объем кода в коде, который взаимодействует с `std::allocator` только через `allocator_traits` (то есть, в большей части кода).
- Интерфейс минимального распределителя C++11 теперь обрабатывается таким образом: стандартная библиотека напрямую вызывает `allocator_traits`, а не помещает распределитель во внутренний класс `_Wrap_alloc`. Так уменьшается размер кода, создаваемого для поддержки распределителя, в некоторых случаях улучшается способность оптимизатора делать выводы о контейнерах стандартной библиотеки и оптимизируется отладка (так как теперь в отладчике отображается тип распределителя, а не `_Wrap_alloc<your_allocator_type>`).
- Удалено метапрограммирование для настроенного `allocator::reference`, чьи распределители фактически запрещено настраивать. (Распределители могут настроить в контейнерах использование специальных указателей, но не специальных ссылок.)
- Интерфейс компилятора настроен для распаковывания итераторов отладки в цикле for на основе диапазона, улучшая производительность отладочных сборок.
- Путь внутреннего сжатия `basic_string` для `shrink_to_fit()` и `reserve()` больше не перераспределяет операции, уменьшая объем кода для всех участников изменения.
- Внутренний путь создания `basic_string` больше не находится в пути `shrink_to_fit()`.
- Операции изменения `basic_string` теперь факторизованы в быстром пути без распределения и в функциях медленного пути с распределением, повышая вероятность встраивания стандартного сценария без распределения в вызывающие объекты.
- Операции изменения `basic_string` теперь создают перераспределенные буферы в предпочтительном состоянии, а не изменяют их размер на месте. Например, при включении в начале строки теперь содержимое после вставки перемещается только один раз (на уровень вниз или в выделенный буфер) вместо двух в случае перераспределения (в выделенный буфер, а затем на уровень вниз).
- Операции, вызывающие стандартную библиотеку C в \<string\> теперь кэшируют адрес `errno` для удаления повторяющегося взаимодействия с протоколом TLS.
- Упрощена реализация `is_pointer`.
- Завершено изменение основанного на функции выражения SFINAE на `struct` или `void_t`.
- Алгоритмы стандартной библиотеки теперь избегают итераторов последующего увеличения.
- Устранены предупреждения об усечении при использовании 32-разрядных распределителей в 64-разрядных системах.
- `std::vector` перемещает назначение эффективнее в случае использования неравного распределителя без применения non-POCMA, повторно используя буфер по необходимости.

#### <a name="readability-and-other-improvements"></a>Читабельность и другие усовершенствования

- Стандартная библиотека теперь использует C++14 `constexpr` без дополнительный условий вместо макросов, определяемых условиями.
- Стандартная библиотека теперь использует шаблоны псевдонимов внутренним образом.
- Стандартная библиотека теперь использует `nullptr` внутренне вместо `nullptr_t{}`. (NULL больше не используется внутренне. Внутреннее использование 0 в качестве null постепенно отменяется.)
- Стандартная библиотека теперь использует `std::move()` внутренне вместо стилистически неправильного использования `std::forward()`.
- Изменено с `static_assert(false, "message")` на `#error message`. Таким образом вы получаете более точную диагностику компилятора, так как `#error` немедленно прекращает компиляцию.
- Стандартная библиотека больше не помечает функции как `__declspec(dllimport)`. Для современных компоновщиков это больше не требуется.
- Извлечены SFINAE для аргументов шаблона по умолчанию, которые сокращают нагрузку по сравнению с типами возвращаемых данных и типами аргумента функции.
- При проверке отладки \<random\> теперь используются обычные механизмы стандартной библиотеки вместо внутренней функции `_Rng_abort()`, которая называется `fputs()` в **stderr**. Реализация этой функции сохраняется для двоичной совместимости, но была удалена в следующей версии стандартной библиотеки, несовместимой с двоичным форматом

### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

В соответствии со стандартом C++17 были добавлены, признаны нерекомендуемыми и удалены несколько функций стандартной библиотеки. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio](cpp-conformance-improvements-2017.md#improvements_155).

#### <a name="new-experimental-features"></a>Новые экспериментальные функции

- Экспериментальная поддержка следующих параллельных алгоритмов:
  - `all_of`
  - `any_of`
  - `for_each`
  - `for_each_n`
  - `none_of`
  - `reduce`
  - `replace`
  - `replace_if`
  - `sort`
- Добавлены, но пока не параллелизованы сигнатуры для следующих параллельных алгоритмов. Профилирование не показало преимуществ от параллелизации алгоритмов, которые только перемещают или переставляют элементы:
  - `copy`
  - `copy_n`
  - `fill`
  - `fill_n`
  - `move`
  - `reverse`
  - `reverse_copy`
  - `rotate`
  - `rotate_copy`
  - `swap_ranges`

#### <a name="performance-fixes-and-improvements"></a>Исправления и усовершенствования производительности

- `basic_string<char16_t>` теперь использует те же `memcmp`, `memcpy`, а также аналогичные оптимизации, применяемые `basic_string<wchar_t>`.
- Ограничение оптимизатора, которое не позволяло указателям на функции быть представленными как встроенные в Visual Studio 2015 с обновлением 3, было устранено, что способствует восстановлению производительности `lower_bound(iter, iter, function pointer)`.
- Затраты на проверку порядка входных данных для включаемых файлов, `includes`, `set_difference`, `set_symmetric_difference` и `set_union`, выполняемую при отладке итератора, были сокращены за счет распаковки итераторов перед проверкой.
- `std::inplace_merge` теперь пропускает элементы, которые уже находятся в нужной позиции.
- При создании `std::random_device` больше не создается и затем удаляется `std::string`.
- У `std::equal` и `std::partition` была передача оптимизации потоков перехода, сохраняющая сравнения итераторов.
- Когда `std::reverse` передает указатели на традиционно копируемый `T`, передача будет выполняться в рукописную векторизированную реализацию.
- `std::fill`, `std::equal` и `std::lexicographical_compare` могут выполнять передачу в `memset` и `memcmp` для `std::byte` и `gsl::byte` (и другие аналогичные символьным перечисления и классы перечислений). Обратите внимание, что `std::copy` передает с помощью `is_trivially_copyable`, поэтому вносить изменения не требуется.
- Стандартная библиотека больше не содержит деструкторы с пустыми скобками, единственное действие которых заключалось в том, чтобы сделать типы нетривиально уничтожаемыми.

#### <a name="correctness-fixes-in-visual-studio-2017-version-155"></a>Исправления ошибок в Visual Studio 2017 версии 15.5

- `std::partition` теперь вызывает предикат N раз вместо N + 1 раз, как того требует стандарт.
- Попытки избежать магической статики в версии 15.3 исправлены в версии 15.5.
- `std::atomic<T>` больше не требуется `T`, чтобы быть конструируемым по умолчанию.
- Алгоритмы кучи, использующие логарифмическое время, больше не делают утверждение линейного времени о том, что входное значение на самом деле является кучей, если включена отладка итератора.
- Теперь `__declspec(allocator)` защищен только для C1XX, чтобы предотвращать вывод предупреждений из Clang, который не понимает declspec.
- `basic_string::npos` теперь доступен в качестве константы времени компиляции.
- `std::allocator` теперь правильно обрабатывает выделение чрезмерно выровненных типов (типов, выравнивание которых больше `max_align_t`) в режиме C++17 (если не отключено с помощью **/Zc:alignedNew-**).  Например, векторы объектов с 16- или 32-байтовым выравниванием теперь правильно выравниваются для инструкций SSE и AVX.

### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- \<memory_resource>
- Основы работы с библиотеками V1
- Удаление назначения polymorphic_allocator
- Улучшение выведения аргументов шаблонов класса

### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- поддержка параллельных алгоритмов теперь не является экспериментальной
- новая реализация \<filesystem>
- простые преобразования строк (частично)
- std::launder()
- std::byte
- hypot(x,y,z)
- отказ от лишнего вырождения
- специальные математические функции
- constexpr char_traits
- указания по выведению для STL

Дополнительные сведения см. в статье [Соответствие стандартам языка Visual C++](visual-cpp-language-conformance.md).

## <a name="other-libraries"></a>Прочие библиотеки

### <a name="open-source-library-support"></a>Поддержка библиотеки с открытым исходным кодом

**Vcpkg** является средством командной строки с открытым исходным кодом, которое значительно упрощает процесс получения и создания статических библиотек открытым исходным кодом C++ и библиотек DLL в Visual Studio. Дополнительные сведения см. в разделе [vcpkg: диспетчер пакетов для C++](../build/vcpkg.md).

**Visual Studio 2017 версии 15.5**:

### <a name="cpprest-sdk-290"></a>Пакет SDK для CPPRest 2.9.0

CPPRestSDK, кроссплатформенный веб-API для C++, был обновлен до версии 2.9.0. Дополнительные сведения см. в статье [Доступность CppRestSDK 2.9.0 в GitHub](https://blogs.msdn.microsoft.com/vcblog/2016/10/21/cpprestsdk-2-9-0-is-available-on-github/).

### <a name="atl"></a>ATL

- Еще один набор исправлений соответствия поиска по имени.
- Имеющиеся конструкторы перемещения и операторы присваивания перемещения теперь правильно помечены как не предусматривающие формирование исключений.
- Отменено отключение допустимого предупреждения C4640 о потокобезопасной инициализации локальных статических элементов в atlstr.h.
- Потокобезопасная инициализация локальных статических элементов была автоматически отключена в наборе инструментов XP при [использовании ATL и сборке библиотеки DLL]. Этот режим больше не используется. Если нужно отключить потокобезопасную инициализацию, в настройки проекта можно добавить **/Zc:threadsafeinit-**.

### <a name="visual-c-runtime"></a>Среда выполнения Visual C++

- Новый заголовок "cfguard.h" для символов защиты потока управления.

## <a name="c-ide"></a>IDE C++

- Повышена производительность изменения конфигурации для проектов в машинном коде на C++ и проектов C++/CLI. При первой активации конфигурации решения процесс теперь будет работать быстрее, а все последующие активации будут происходить практически мгновенно.

**Visual Studio 2017 версия 15.3**:

- Некоторые мастера проекта и кода были переписаны в стиле диалоговых окон с подписями.
- При выборе пункта меню **Добавить класс** теперь запускается мастер добавления классов. Все остальные элементы, которые ранее здесь находились, теперь доступны в разделе **Добавить > Новый элемент**.
- Проекты Win32 теперь находятся в каталоге **Классические приложения Windows** в диалоговом окне **Создание проекта**.
- При выборе шаблонов **Консольное приложение Windows** и **Классическое приложение Windows** теперь создаются проекты без вызова мастера. Теперь доступен новый **мастер создания классических приложений Windows**. Он отображается в той же категории, что и прежний мастер **создания консольных приложение Win32**, и с теми же параметрами.

**Visual Studio 2017 версии 15.5**:

несколько операций C++, которые используют модуль IntelliSense для навигации по коду и рефакторинга кода, работают гораздо быстрее. Следующие данные основаны на решении Visual Studio Chromium решения с 3500 проектами.

|||
|-|-|
|Функция|Повышение производительности|
|Переименовать|в 5,3 раза|
|Изменение сигнатуры |в 4,5 раза|
|Найти все ссылки|в 4,7 раза|

C++ теперь поддерживает комбинацию клавиши CTRL+щелчок мыши, что упрощает **переход к определениям** с помощью мыши. Визуализатор структуры из пакета инструментов повышения производительности теперь также включен в продукт по умолчанию.

## <a name="intellisense"></a>IntelliSense

- По умолчанию теперь используется новое ядро СУБД на основе SQLite. Это позволяет ускорить операции базы данных, такие как **переход к определению** и **поиск всех ссылок**, а также значительно ускорить первоначальный анализ решения. Параметр был перемещен в меню **Инструменты > Параметры > Текстовый редактор > C/C++ > Дополнительно** (ранее он был в разделе "...C/C++ > Экспериментальные").

- Улучшена производительность IntelliSense в проектах и файлах, где не используются предкомпилированные заголовки. В текущем файле для заголовков будет создан автоматический предкомпилированный заголовок.

- Добавлена фильтрация ошибок и справка по ошибкам IntelliSense для списка ошибок. Теперь выполнить фильтрацию можно, просто щелкнув столбец ошибок. Кроме того, если щелкнуть конкретные ошибки или нажать клавишу F1, запустится поиск сообщения об ошибке в сети.

  ![Список ошибок](media/ErrorList1.png "Список ошибок")

  ![Отфильтрованный список ошибок](media/ErrorList2.png "Отфильтрованный список ошибок")

- Добавлена фильтрация пунктов списка элементов по виду.

  ![Фильтрация списка элементов](media/mlfiltering.png "Фильтрация списка элементов")

- Добавлена новая экспериментальная возможность, прогнозный IntelliSense, обеспечивающая фильтрацию содержимого списка элементов с учетом контекста. См. статью [Усовершенствования C++ IntelliSense — прогнозная технология IntelliSense и фильтрация](https://blogs.msdn.microsoft.com/vcblog/2016/10/05/c-intellisense-improvements-predictive-intellisense-filtering/).
- Команда **Найти все ссылки** (SHIFT+F12) теперь позволяет легко перемещаться даже по сложным базам кода. Она предоставляет расширенные возможности группирования, фильтрации, сортировки, поиска в найденном и цветового выделения результатов. Это дает вам четкое понимание ссылок. Для C++ новый компонент пользовательского интерфейса содержит информацию о том, выполняется ли чтение из переменной или запись в переменную.
- Функция замены точки на стрелку IntelliSense была перенесена из экспериментальных в расширенные и теперь включена по умолчанию. Функции **расширения областей** и **приоритета расширения** в редакторе также были перенесены из экспериментальных в расширенные.
- Экспериментальные функции рефакторинга **Изменить сигнатуру** и **Извлечь функцию** теперь доступны по умолчанию.
- Экспериментальная функция для C++ проектов "Меньшее время загрузки проекта". Когда вы в следующий раз откроете проект C++, он загрузится быстрее, а в последующий раз — очень быстро.
- Некоторые из этих функций являются общими для других языков, а некоторые специфичны для C++. Дополнительные сведения об этих новых возможностях см. в [объявлении о выпуске Visual Studio "15"](https://blogs.msdn.microsoft.com/visualstudio/2016/10/05/announcing-visual-studio-15-preview-5/).

**Visual Studio 2017 версии 15.7**: добавлена поддержка ClangFormat. Дополнительные сведения см. в записи блога [ClangFormat Support in Visual Studio 2017](https://blogs.msdn.microsoft.com/vcblog/2018/03/13/clangformat-support-in-visual-studio-2017-15-7-preview-1/) (Поддержка ClangFormat в Visual Studio).

## <a name="non-msbuild-projects-with-open-folder"></a>Поддержка проектов, отличных от MSBuild, с помощью функции "Открыть папку"

В Visual Studio 2017 появилась функция **Открыть папку**, позволяющая создавать код, выполнять сборку и отладку в папке с исходным кодом без необходимости создавать решения или проекты. Это намного упрощает начало работы с Visual Studio, даже если проект не основан на MSBuild. С помощью функции **Открыть папку** вы получаете доступ к эффективным возможностям в области понимания, изменения, создания и отладки кода, уже предоставляемых Visual Studio для проектов MSBuild. Дополнительные сведения см. в статье [Проекты "Открыть папку" для C++](../build/open-folder-projects-cpp.md).

- Улучшения в процедуре открытия папки. Можно выполнить настройку с помощью следующих файлов JSON.
  - CppProperties.json используется для настройки работы с IntelliSense и браузером.
  - Tasks.json используется для настройки этапов сборки.
  - Launch.json используется для настройки процедуры отладки.

**Visual Studio 2017 версия 15.3**:

- Улучшенная поддержка альтернативных компиляторов и сред сборки, таких как MinGW и Cygwin. Дополнительные сведения см. в статье [Using MinGW and Cygwin with Visual C++ and Open Folder](https://blogs.msdn.microsoft.com/vcblog/2017/07/19/using-mingw-and-cygwin-with-visual-cpp-and-open-folder/) (Использование MinGW и Cygwin с Visual C++ и функцией "Открыть папку").
- Добавлена поддержка определения глобальных и зависящих от конфигурации переменных среды в файлах CppProperties.json и CMakeSettings.json. Эти переменные среды могут использоваться в конфигурациях отладки, определенных в файле launch.vs.json, и в задачах, определенных в файле tasks.vs.json. Дополнительные сведения см. в статье [Использование MinGW и Cygwin с Visual C++ и функцией "Открыть папку"](https://blogs.msdn.microsoft.com/vcblog/2017/11/02/customizing-your-environment-with-visual-c-and-open-folder/).
- Улучшена поддержка генератора CMake Ninja, включая упрощение выбора 64-разрядной платформы в качестве целевой.

## <a name="cmake-support-via-open-folder"></a>Поддержка CMake с помощью функции "Открыть папку"

В Visual Studio 2017 добавлена поддержка использования проектов CMake без преобразования в файлы проекта MSBuild (с расширением VCXPROJ). Дополнительные сведения см. в статье [Проекты CMake в Visual C++](../build/cmake-projects-in-visual-studio.md). При открытии проектов CMake с помощью функции **Открыть папку** автоматически настраивается среда для редактирования, сборки и отладки C++.

- Для работы C++ IntelliSense не требуется создавать файл CppProperties.json в корневой папке. Кроме того, мы добавили новый раскрывающийся список, позволяющий пользователям легко переключаться между конфигурациями, предоставляемыми файлами CMake и CppProperties.json.

- Дальнейшая настройка поддерживается посредством файла CMakeSettings.json, который находится в одной папке с файлом CMakeLists.txt.

  ![Функция "Открыть папку" в Cmake](media/cmake_cpp.png "Функция \"Открыть папку\" в Cmake")

**Visual Studio 2017 версия 15.3**: добавлена поддержка генератора CMake Ninja.

**Visual Studio 2017 версии 15.5**: добавлена поддержка импорта существующих кэшей CMake.

**Visual Studio 2017 версии 15.7**: добавлена поддержка CMake 3.11, анализ кода в проектах CMake, представление целевых объектов в обозревателе решений, параметры формирования кэша и компиляция на базе одного файла. Дополнительные сведения см. в статьях [CMake support in Visual Studio](https://blogs.msdn.microsoft.com/vcblog/2018/04/09/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/) (Поддержка CMake в Visual Studio) [CMake projects in Visual C++](../build/cmake-projects-in-visual-studio.md) (Проекты CMake в Visual C++).

## <a name="windows-desktop-development-with-c"></a>Разработка классических приложений для Windows на C++

Теперь предоставляется более точный контроль над процедурой установки исходной рабочей нагрузки C++. Мы добавили возможность выбора компонентов, чтобы вы могли устанавливать только необходимые инструменты.  Обратите внимание, что в пользовательском интерфейсе установщика указаны неточные размеры установки для компонентов. Таким образом, общий размер занижен.

Чтобы успешно создавать проекты Win32 в рабочей нагрузке для разработки приложений на C++, необходимо установить набор средств и пакет SDK для Windows. Для этого следует установить рекомендуемые (выбранные) компоненты **Набор средств VC++ 2017 v141 (x86, x64)** и **Пакет SDK Windows 10 (10.0.nnnnn)**. Если необходимые средства не установлены, создание проектов завершится ошибкой, а мастер может зависнуть.

**Visual Studio 2017 версии 15.5**:

Visual C++ Build Tools (ранее доступный как отдельный продукт), теперь включен в Visual Studio Installer в качестве рабочей нагрузки. Эта рабочая нагрузка устанавливает только инструменты, необходимые для сборки проектов C++ без установки среды Visual Studio. Включены наборы инструментов v141 и v140. Набор инструментов v141 содержит последние улучшения в Visual Studio 2017 версии 15.5. Дополнительные сведения см. в статье [В состав Visual Studio Build Tools теперь входят наборы инструментов MSVC VS2017 и VS2015](https://blogs.msdn.microsoft.com/vcblog/2017/11/02/visual-studio-build-tools-now-include-the-vs2017-and-vs2015-msvc-toolsets/).

## <a name="linux-development-with-c"></a>Разработка приложений для Linux на C++

Популярное расширение, [Visual C++ для разработки приложений Linux](https://visualstudiogallery.msdn.microsoft.com/725025cf-7067-45c2-8d01-1e0fd359ae6e), теперь стало частью Visual Studio. В этой установке представлено все необходимое для разработки и отладки приложений C++, работающих в среде Linux.

**Visual Studio 2017 версии 15.2**:

улучшение использования кроссплатформенного кода и типа визуализации. Дополнительные сведения см. в статье [Linux C++ improvements for cross-platform code sharing and type visualization](https://blogs.msdn.microsoft.com/vcblog/2017/05/10/linux-cross-platform-and-type-visualization/) (Улучшения Linux C++ при использовании кроссплатформенного кода и визуализации типов).

**Visual Studio 2017 версии 15.5**:

- Рабочая нагрузка Linux имеет дополнительную поддержку для **rsync** в качестве альтернативы **sftp** для синхронизации файлов на удаленных компьютерах Linux.
- Добавлена поддержка для перекрестной компиляции, предназначенной для микроконтроллеров ARM. Чтобы включить ее в установку, выберите рабочую нагрузку по **разработке приложений Linux на C++** и **разработку для встроенных платформ и Интернета вещей**. В вашу установку будут добавлены инструменты перекрестной компиляции ARM GCC и Make. Дополнительные сведения см. в статье [Перекрестная компиляция ARM GCC в Visual Studio](https://blogs.msdn.microsoft.com/vcblog/2017/10/23/arm-gcc-cross-compilation-in-visual-studio/).
- Добавлена поддержка для CMake. Теперь вы можете работать с существующей базой кода, не преобразовывая ее в проект Visual Studio. Дополнительные сведения см. в разделе [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).
- Добавлена поддержка для выполнения удаленных задач. Эта возможность позволяет запускать любую команду в удаленной системе, которая определена в диспетчере подключений Visual Studio. Удаленные задачи также позволяют копировать файлы в удаленную систему.
Дополнительные сведения см. в разделе [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).

**Visual Studio 2017 версии 15.7**:

- Различные улучшения сценариев рабочих нагрузок в Linux. Дополнительные сведения см. в записи блога [Изменения в рабочих нагрузках C++ в Linux для системы проектов, консольного окна Linux, rsync and команды "Присоединение к процессу"](https://blogs.msdn.microsoft.com/vcblog/2018/03/13/linux-c-workload-improvements-to-the-project-system-linux-console-window-rsync-and-attach-to-process/).
- IntelliSense для заголовков удаленных подключений Linux. Дополнительные сведения см. в статьях [IntelliSense for Remote Linux Headers](https://blogs.msdn.microsoft.com/vcblog/2018/04/09/intellisense-for-remote-linux-headers/) (IntelliSense для удаленных заголовков Linux) и [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).

## <a name="game-development-with-c"></a>Разработка игр на C++

Доступны все возможности C++ для создания профессиональных игр на базе DirectX или Cocos2d.

## <a name="mobile-development-with-c-android-and-ios"></a>Разработка мобильных приложений на C++ (для iOS и Android)

Теперь в Visual Studio можно создавать мобильные приложения для Android и iOS и отлаживать их.

## <a name="universal-windows-apps"></a>Универсальные приложения Windows

C++ поставляется как дополнительный компонент для рабочей нагрузки универсального приложения для Windows.  Сейчас обновление проектов C++ следует выполнять вручную. При открытии проекта, ориентированного на v140 UWP, в Visual Studio 2017 следует выбрать набор инструментов платформы v141 на страницах свойств проекта, если у вас не установлена среда Visual Studio 2015.

## <a name="new-options-for-c-on-universal-windows-platform-uwp"></a>Новые возможности C++ на универсальной платформе Windows (UWP)
Доступны новые возможности написания и упаковки приложений C++ для универсальной платформы Windows и Microsoft Store. Используйте инфраструктуру моста для классических приложений, чтобы создавать пакеты существующих классических приложений или СОМ-объектов, предназначенные для развертывания в Microsoft Store или через имеющиеся каналы загрузки неопубликованных приложений. Благодаря новым возможностям в Windows 10 можно добавлять функции UWP в классическое приложение различными способами. Дополнительные сведения см. в статье [Мост для классических приложений](/windows/uwp/porting/desktop-to-uwp-root).

**Visual Studio 2017 версии 15.5**: Добавлен шаблон **Проект упаковки приложений Windows**, который значительно упрощает упаковку классических приложений благодаря использованию моста для классических приложений. Он находится в разделе **Файл | Создать | Проект | Установленные | Visual C++ | Универсальная платформа Windows**. Дополнительные сведения см. в статье [Упаковка приложения с помощью Visual Studio (мост для классических приложений)](/windows/uwp/porting/desktop-to-uwp-packaging-dot-net).

При написании кода теперь можно использовать C++/WinRT — это проекция стандартного C++ для среды выполнения Windows, реализованная исключительно за счет файлов заголовков. Она позволяет как создавать, так и использовать API среды выполнения Windows с помощью любого соответствующего стандартам компилятора C++. C++/WinRT предоставляет разработчикам на C++ первоклассный доступ к современным API Windows. Дополнительные сведения см. в статье [Доступность C++/WinRT в GitHub](https://moderncpp.com/).

На момент выхода сборки 17025 Insider Preview пакета SDK Windows C++/WinRT входит в пакет Windows SDK. Дополнительные сведения см. в статье [C++/WinRT включен в состав пакета Windows SDK](https://blogs.msdn.microsoft.com/vcblog/2017/11/01/cppwinrt-is-now-included-the-windows-sdk/).

## <a name="clangc2-platform-toolset"></a>Набор средств платформы Clang/C2

Набор инструментов Clang/C2, который поставляется с Visual Studio 2017, теперь поддерживает параметр **/bigobj**, который крайне важен для сборки больших проектов. Он также включает несколько важных исправлений как во внутренней, так и во внешней части компилятора.

## <a name="c-code-analysis"></a>Анализ кода C++

Средства проверки на соответствие кода C++ [проверенным рекомендациям](https://github.com/isocpp/CppCoreGuidelines) (C++ Core Checker) теперь распространяются вместе с Visual Studio. Просто включите средства проверки на странице **Code Analysis Extensions** (Расширения анализа кода) на страницах свойств проекта, и расширения будут включены при выполнении анализа кода. Дополнительные сведения см. в статье [Using the C++ Core Guidelines checkers](/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers) (Использование средств проверки на соответствие рекомендациям C++ Core).

![CppCoreCheck](media/CppCoreCheck.png "Страница свойств CppCoreCheck")

**Visual Studio 2017 версия 15.3**: поддержка правил, связанных с управлением ресурсов.

**Visual Studio 2017 версии 15.5**: новые проверки C++ Core Guidelines проверяют корректность интеллектуальных указателей, правильность использования глобальных инициализаторов и применение флагов конструкций, таких как `goto` и неправильные приведения.

Некоторые номера предупреждений, которые можно встретить в версии 15.3, больше не доступны в версии 15.5. Эти предупреждения были заменены более конкретными проверками.

**Visual Studio 2017 версии 15.6**:

- Добавлена поддержка анализа одиночного файла, а также улучшения в анализе производительности времени выполнения. Дополнительные сведения см. в статье [C++ Static Analysis Improvements for Visual Studio 2017 15.6 Preview 2](https://blogs.msdn.microsoft.com/vcblog/2018/01/10/c-static-analysis-improvements-for-visual-studio-2017-15-6-preview-2/) (Усовершенствования статического анализа C++ в Visual Studio 2017 15.6 Preview 2)

**Visual Studio 2017 версии 15.7**:

- Добавлена поддержка параметра [/ analyze: ruleset](../build/reference/analyze-code-analysis.md), который позволяет указать, какие применять правила анализа кода.
- Добавлена поддержка дополнительных правил C++ Core Guidelines.  Дополнительные сведения см. в статье [Using the C++ Core Guidelines checkers](/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers) (Использование средств проверки на соответствие рекомендациям C++ Core).

## <a name="unit-testing"></a>Модульное тестирование

**Visual Studio 2017 версии 15.5**:

Google Test Adapter и Boost.Test Adapter теперь доступны как компоненты рабочей нагрузки **Разработка классических приложений на C++** и интегрированы с **обозревателем тестов**. Добавлена поддержка CTest для проектов Cmake (с использованием функции "Открыть папку"), хотя полная интеграция с **обозревателем тестов** еще не доступна. Дополнительные сведения см. в разделе [Создание модульных тестов для C/C++](/visualstudio/test/writing-unit-tests-for-c-cpp).

**Visual Studio 2017 версии 15.6**:

- Добавлена поддержка динамической библиотеки Boost.Test.
- В интегрированной среде разработки теперь доступен шаблон элемента Boost.Test.

Дополнительные сведения см. в статье [Boost.Test Unit Testing: Dynamic Library support and New Item Template](https://blogs.msdn.microsoft.com/vcblog/2018/01/10/boost-test-unit-testing-dynamic-library-support-and-new-item-template/) (Модульное тестирование Boost.Test: поддержка динамических библиотек и новый шаблон элемента).

**Visual Studio 2017 версии 15.7**:

Добавлена поддержка [CodeLens](/visualstudio/ide/find-code-changes-and-other-history-with-codelens) для проектов модульного тестирования C++. Дополнительные сведения см. в записи блога [Announcing CodeLens for C++ Unit Testing](https://blogs.msdn.microsoft.com/vcblog/2018/04/09/announcing-codelens-for-c-unit-testing/) (Объявлена поддержка CodeLens для модульного тестирования C++).

## <a name="visual-studio-graphics-diagnostics"></a>Диагностика графики в Visual Studio

Диагностика графики Visual Studio — это набор инструментов для регистрации и анализа проблем с производительностью и отрисовкой в приложениях Direct3D. Функции диагностики графики можно использовать для приложений, которые выполняются локально на компьютере под управлением Windows, в эмуляторе устройства Windows либо на удаленном компьютере или устройстве.

- **Ввод и вывод для шейдеров вершин и геометрии.** Возможность просмотра входных и выходных данных шейдеров вершин и геометрии была одной из наиболее часто запрашиваемых функций, и теперь она поддерживается в инструментах. Просто выберите этап шейдера вершин или геометрических объектов в представлении "Этапы конвейера", чтобы запустить проверку входных и выходных данных в приведенной ниже таблице.

  ![Входные и выходные данные для шейдеров](media/io-shaders.png)

- **Поиск и фильтрация в таблице объектов.** Теперь доступен простой и быстрый поиск нужных ресурсов.

  ![Поиск](media/search.png)

- **Журнал ресурсов.** Новое упрощенное представление всей истории изменений ресурса по мере его использования в ходе отрисовки захваченного кадра. Чтобы открыть журнал для любого ресурса, просто щелкните значок часов рядом с гиперссылкой на ресурс.

  ![Журнал ресурсов](media/resource-history.png)

  Откроется новое окно **журнала ресурсов**, заполненное данными об изменении ресурса.

  ![Изменение журнала ресурсов](media/resource-history-change.png)

  Обратите внимание, что если кадр был записан с включенной функцией записи полного стека вызовов (**Visual Studio > Инструменты > Параметры**, раздел **Диагностика графики**), то контекст каждого события изменения можно быстро вывести и проверить в проекте Visual Studio.

- **Статистика API.** Обобщенная сводка по использованию API в вашем кадре. Это может быть удобно при обнаружении вызовов, осуществление которых вы можете не осознавать, или вызовов, которые вы осуществляете слишком много. Это окно можно открыть в анализаторе графики Visual Studio, выбрав **Вид > Статистика использования API**.

  ![Статистика использования API](media/api-stats.png)

- **Статистика памяти.** Просмотр объема памяти, выделяемого драйвером для создаваемых ресурсов в кадре. Это окно можно открыть в **анализаторе графики Visual Studio**, выбрав **Вид > Статистика использования памяти**. Данные можно скопировать в CSV-файл для просмотра в таблице. Для этого щелкните правой кнопкой мыши и выберите команду **Копировать все**.

  ![Статистика использования памяти](media/memory-stats.png)

- **Проверка кадров.** Новый список ошибок и предупреждений позволяет легко просматривать события, где обнаружены потенциальные проблемы на уровне отладки Direct3D. Чтобы открыть окно, в анализаторе графики Visual Studio выберите **Вид > Проверка кадра**. Затем щелкните **Выполнить проверку**, чтобы начать анализ. В зависимости от сложности кадра процесс может занять несколько минут.

  ![Проверка кадра](media/frame-validation.png)

- **Анализ кадров для D3D12.** Используйте анализ кадров для оценки работы вызовов рисования с помощью контролируемых экспериментов. Перейдите на вкладку "Анализ кадров", чтобы просмотреть отчет. Дополнительные сведения см. в видеоролике [GoingNative 25: Visual Studio Graphics Frame Analysis](https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-25-Offline-Analysis-Graphics-Tool), посвященном анализу кадров графики Visual Studio.

  ![Анализ кадров](media/frame-analysis.png)

- **Усовершенствованный анализ использования GPU.** Выполняйте более подробный анализ, открывая трассировки, полученные профилировщиком использования GPU в Visual Studio, в представлении GPU или инструменте Windows Performance Analyzer (WPA). Если у вас установлен набор средств для оценки производительности Windows, в правом нижнем углу экрана общих сведений о сеансе вы увидите две гиперссылки — одна для WPA, а другая для режима GPU.

  ![Использование GPU](media/gpu-usage.png)

  Трассировки, открытые в режиме GPU с помощью этой ссылки, поддерживают синхронизированное масштабирование и панорамирование на временной шкале в режимах VS и GPU. Флажок в VS используется для включения или отключения синхронизации.

  ![Режим GPU](media/gpu-view.png)
