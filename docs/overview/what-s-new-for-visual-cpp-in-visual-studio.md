---
title: Новые возможности C++ в Visual Studio
ms.date: 05/19/2020
ms.technology: cpp-ide
ms.assetid: 8801dbdb-ca0b-491f-9e33-01618bff5ae9
ms.openlocfilehash: 28b3708c8064623a364b7a60eb63c508808b0a0b
ms.sourcegitcommit: 6e55aeb538b1c39af754f82d6f7738a18f5aa031
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/29/2020
ms.locfileid: "87390004"
---
# <a name="whats-new-for-c-in-visual-studio"></a>Новые возможности C++ в Visual Studio

::: moniker range=">=vs-2019"

В Visual Studio 2019 реализовано множество изменений и исправлений для среды Microsoft C++. Мы исправили множество ошибок и проблем с компилятором и средствами. Сообщения о многих из них были отправлены клиентами с помощью инструментов [Сообщить о проблеме](/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019) и [Отправить предложение](https://developercommunity.visualstudio.com/spaces/62/index.html) в разделе **Отправить отзыв**. Спасибо, что сообщаете нам об ошибках! Дополнительные сведения о новых возможностях всех компонентов Visual Studio см. на странице [What's new in Visual Studio 2019](/visualstudio/ide/whats-new-visual-studio-2019) (Новые возможности Visual Studio 2019). Сведения о новых возможностях для C++ в Visual Studio 2017 см. в статье [What's New for C++ in Visual Studio 2017](/cpp/overview/what-s-new-for-visual-cpp-in-visual-studio?view=vs-2017) (Новые возможности для C++ в Visual Studio 2017). Сведения о новых возможностях для C++ в Visual Studio 2015 и более ранних версиях см. в статье [Visual C++ What's New 2003 through 2015](/cpp/porting/visual-cpp-what-s-new-2003-through-2015) (Новые возможности Visual C++ в версиях с 2003 по 2015).

## <a name="c-compiler"></a>компилятор C++

- Улучшенная поддержка функций C++17 и корректирующие исправления, а также экспериментальная поддержка функций C++20, таких как модули и сопрограммы. Подробные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2019](cpp-conformance-improvements.md).

- Параметр `/std:c++latest` теперь поддерживает функции C++20, которые не обязательно завершены, включая начальную поддержку оператора C++20 \<=> ("космический корабль") для трехстороннего сравнения.

- Параметр компилятора C++ `/Gm` теперь считается устаревшим. Рекомендуется отключить параметр `/Gm` в скриптах сборки, если он задан явно. Можно просто проигнорировать предупреждение об устаревании `/Gm`, так как оно не считается ошибкой при использовании режима "Обрабатывать предупреждения как ошибки" (`/WX`).

- В MSVC уже внедряются функции из проекта стандарта C++20 с флагом `/std:c++latest`, поэтому `/std:c++latest` теперь несовместим с `/clr` (все варианты), `/ZW` и `/Gm`. В Visual Studio 2019 используйте режим `/std:c++17` или `/std:c++14` при компиляции с параметром `/clr`, `/ZW` или `/Gm` (но обратите внимание на предыдущий пункт).

- Предкомпилированные заголовки больше не создаются по умолчанию для консоли C++ и настольных приложений.

### <a name="codegen-security-diagnostics-and-versioning"></a>Создание кода, безопасность, диагностика и управления версиями

Доступен параметр `/Qspectre` для более эффективного анализа и устранения рисков, связанных с уязвимостью Spectre 1-го варианта (CVE-2017-5753). Дополнительные сведения см. в записи блога [Устранение рисков Spectre в MSVC](https://devblogs.microsoft.com/cppblog/spectre-mitigations-in-msvc/).

## <a name="c-standard-library-improvements"></a>Улучшения стандартной библиотеки C++

- Реализация дополнительных функций библиотек и корректирующих исправлений C++17 и C++20. Подробные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2019](cpp-conformance-improvements.md).

- Для улучшения читаемости кода в заголовках стандартной библиотеки C++ используется Clang-Format.

- Так как Visual Studio теперь поддерживает функцию "Только мой код" для C++, стандартная библиотека больше не должна предоставлять настраиваемый механизм для `std::function` и `std::visit`, чтобы обеспечить такой же результат. Удаление этого механизма будет почти незаметным для пользователя. Одно исключение: компилятор больше не будет сообщать о наличии проблем в строках 15732480 и 16707566 для \<type_traits> или \<variant>.

## <a name="performancethroughput-improvements-in-the-compiler-and-standard-library"></a>Повышение производительности и пропускной способности в компиляторе и стандартной библиотеке

- Реализованы усовершенствования пропускной способности сборки, включая обработку компоновщиком ввода-вывода файлов и время компоновки при объединении и создании типа PDB.

- Добавлена базовая поддержка векторизации OpenMP SIMD. Вы можете включить ее с помощью нового параметра компилятора **`/openmp:experimental`** . Эта опция позволяет при необходимости векторизовать циклы, аннотированные с `#pragma omp simd`. Векторизация не гарантируется, и циклы с аннотацией, но без векторизации, будут выдавать предупреждение. Предложения SIMD не поддерживаются, они просто игнорируются с предупреждением.

- Добавлен новый параметр встраивания командной строки **`/Ob3`** , который представляет собой более эффективную версию **`/Ob2`** . **`/O2`** (оптимизация двоичного файла для скорости) по-прежнему подразумевает **`/Ob2`** по умолчанию. Если обнаружится, что компилятор неэффективно выполняет встраивание, попробуйте передать **`/O2 -Ob3`** .

- Добавлена поддержка встроенных функций Short Vector Math Library (SVML). Эти функции вычисляют 128-разрядные, 256-разрядные или 512-разрядные векторные эквиваленты. Мы добавили их для поддержки векторизации вручную циклов с вызовами функций математических библиотек и некоторых других операций, таких как целочисленное деление. См. раздел [Руководство по встроенным функциям Intel](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#!=undefined&techs=SVML) с определениями поддерживаемых функций.

- Новые и улучшенные оптимизации:

  - Свертывание констант и арифметические упрощения для выражений с помощью встроенных функций SIMD (вектор) для чисел с плавающей запятой и целых чисел.

  - Более эффективный анализ для извлечения данных из потока управления (инструкции if/else/switch) для удаления ветвей, которые всегда имеют значение true или false.

  - Улучшенное развертывание memset для использования векторных инструкций SSE2.

  - Улучшенное удаление бесполезных копий структур или классов, особенно для программ C++, которые передают по значению.

  - Улучшена оптимизация кода с использованием `memmove`, например конструкции `std::copy` или `std::vector` и `std::string`.

- Оптимизирована физическая структура стандартной библиотеки, чтобы избежать компиляции ее частей, которые явно не включены. Это в два раза ускоряет сборку пустого файла, включающего только \<vector>. В результате этого изменения вам, возможно, потребуется добавить директивы `#include` для заголовков, которые ранее были включены косвенно. Например, если в коде используется `std::out_of_range`, теперь в него нужно добавить `#include <stdexcept>`. В коде с оператором вставки потока, возможно, потребуется добавить `#include <ostream>`. Преимущество заключается в том, что нагрузка на пропускную способность будет возникать только при компиляции тех единиц преобразования, которые фактически используют компоненты \<stdexcept> или \<ostream>.

- `if constexpr` теперь более широко применяется в стандартной библиотеке для снижения нагрузки на пропускную способность и уменьшения размера кода в операциях копирования и преобразования (обращение и вращение), а также в библиотеке параллельных алгоритмов.

- Стандартная библиотека теперь внутренне использует `if constexpr` для ускорения компиляции даже в режиме C++14.

- При обнаружении динамической компоновки в среде выполнения для библиотеки параллельных алгоритмов для хранения массива с указателями на функции больше не используется целая страница. Использование этой памяти только для чтения более не считается важным для безопасности.

- Конструктор `std::thread` больше не ожидает запуска потока и не вставляет так много уровней вызова функции между базовой библиотекой C `_beginthreadex` и предоставляемым вызываемым объектом. Ранее `std::thread` размещал шесть функций между `_beginthreadex` и предоставляемым вызываемым объектом. Это число функций уменьшено до трех, две из которых просто `std::invoke`. Это изменение также позволяет устранить редкую ошибку, связанную со временем, когда конструктор `std::thread` переставал отвечать на запросы, если системное время было изменено в момент создания `std::thread`.

- Устранена проблема с производительностью в `std::hash`, которая начала появляться после добавления `std::hash<std::filesystem::path>`.

- Иногда для обеспечения корректности стандартная библиотека теперь использует деструкторы, а не блоки catch. Это изменение приводит к улучшению взаимодействия с отладчиком: Исключения, которые вызывались через библиотеку в затронутых расположениях, теперь будут отображаться как исключения из расположения их возникновения (а не из расположения повторного вызова). Устранены не все блоки catch стандартной библиотеки. Мы планируем сократить число блоков catch в последующих выпусках MSVC.

- Проблема с неоптимальной работой генератора кода в `std::bitset` из-за условного вызова в функции noexcept устранена. Для этого путь вызова был вынесен за скобки.

- `std::list` и семейство `std::unordered_*` более широко внутренне используют итераторы без возможности отладки.

- Несколько членов `std::list` теперь не освобождают и не выделяют заново узлы списков, а при возможности повторно используют их. Например, если размер `list<int>` уже равен 3, вызов `assign(4, 1729)` теперь перезапишет значения int в первых трех узлах списков и выделит один новый узел списка со значением 1729.

- Все вызовы `erase(begin(), end())` из стандартной библиотеки изменены на `clear()`.

- В некоторых случаях `std::vector` теперь более эффективно инициализирует и удаляет элементы.

- Усовершенствован `std::variant` для более удобной работы с оптимизатором, что приводит к улучшению сформированного кода. Встраивание кода теперь гораздо лучше с `std::visit`.

## <a name="c-ide"></a>IDE C++

### <a name="live-share-c-support"></a>Поддержка Live Share C++

[Live Share](/visualstudio/liveshare/) теперь поддерживает C++, позволяя разработчикам, использующим Visual Studio или Visual Studio Code, сотрудничать в режиме реального времени. Дополнительные сведения см. в статьях [Объявление Live Share для C++: общий доступ и совместная работа в режиме реального времени](https://devblogs.microsoft.com/cppblog/cppliveshare/)

### <a name="intellicode-for-c"></a>IntelliCode для C++

##### <a name="visual-studio-2019-version-161"></a>Visual Studio 2019 версии 16.1

IntelliCode использует обучение и контекст кода для вывода тех вариантов, которые вы чаще всего используете, в верхней части списка завершения. Он также часто устраняет необходимость прокручивать список. IntelliCode для C++ работает наиболее эффективно при использовании популярных библиотек, таких как стандартная библиотека. IntelliCode — это дополнительное расширение, доступное в качестве компонента рабочей нагрузки в установщике. Дополнительные сведения см. в разделе [Рекомендации по завершению кода на базе ИИ в C++ через IntelliCode](https://devblogs.microsoft.com/cppblog/cppintellicode/).

### <a name="template-intellisense"></a>Шаблон IntelliSense

В **строке шаблона** теперь используется пользовательский интерфейс **Окно просмотра**, а не модальное окно, поддерживаются вложенные шаблоны и автоматически заполняются аргументы по умолчанию в **Окне просмотра**. Дополнительные сведения см. в статье [Усовершенствования шаблона IntelliSense для Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/template-intellisense-improvements-for-visual-studio-2019-preview-2/). Раскрывающийся список **Недавно использовавшиеся** в **строке шаблона** позволяет быстро переключаться между предыдущими наборами аргументов шаблона.

### <a name="new-start-window-experience"></a>Новый интерфейс начального окна

При запуске интегрированной среды разработки откроется новое начальное окно. С помощью элементов в нем можно открыть последние проекты, клонировать код из системы управления версиями, открыть локальный код как решение или папку и создать новый проект. Диалоговое окно создания проекта также теперь ориентировано на поиск и фильтрацию.

### <a name="new-names-for-some-project-templates"></a>Новые имена для некоторых шаблонов проектов

Мы изменили несколько имен и описаний шаблонов проектов в соответствии с обновленным диалоговым окном создания проекта.

### <a name="various-productivity-improvements"></a>Различные улучшения производительности

Visual Studio 2019 включает в себя следующие возможности, которые помогут сделать процесс кодирования более простым и интуитивным:

- Быстрые исправления для:
  - Добавление недостающих #include
  - NULL и nullptr
  - Добавление недостающих точек с запятой.
  - Разрешение отсутствующего пространства имен или области
  - Замена неправильных операндов косвенного обращения (\* на & и & на \*)
- Краткие сведения для блока при наведении указателя на закрывающую скобку
- Просмотреть файл заголовка или кода
- "Перейти к определению" для #include открывает файл

Дополнительные сведения см. в статье [Улучшения производительности C++ в Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/c-productivity-improvements-in-visual-studio-2019-preview-2/).

### <a name="quickinfo-improvements"></a>Усовершенствования подсказок

##### <a name="visual-studio-2019-version-161"></a>Visual Studio 2019 версии 16.1

При отображении подсказок теперь учитывается семантическая подсветка в редакторе. Также доступна новая ссылка **Поиск в Интернете**, с помощью которой можно находить онлайн-документацию по конструкции кода, на которую наведен указатель мыши. Для кода, подчеркнутого волнистой красной линией, ссылка в подсказке позволяет выполнить поиск сведений об ошибке в Интернете. То есть вам не придется повторно вводить сообщение в браузере. Подробные сведения см. в записи блога [Quick Info Improvements in Visual Studio 2019: Colorization and Search Online](https://devblogs.microsoft.com/cppblog/quick-info-improvements-in-visual-studio-2019-colorization-and-search-online/) (Улучшения подсказок в Visual Studio 2019: подсветка и поиск в Интернете).

### <a name="intellicode-available-in-c-workload"></a>Компонент IntelliCode доступен в рабочей нагрузке C++

##### <a name="visual-studio-2019-version-161"></a>Visual Studio 2019 версии 16.1

IntelliCode теперь предоставляется в виде дополнительного компонента в рабочей нагрузке **Разработка классических приложений на C++** . Подробные сведения см. в записи блога [Improved C++ IntelliCode now Ships with Visual Studio 2019](https://devblogs.microsoft.com/cppblog/improved-c-intellicode-now-ships-with-visual-studio-2019/) (Улучшенный компонент IntelliCode для C++ теперь предоставляется с Visual Studio 2019).

## <a name="cmake-support"></a>Поддержка CMake

- Поддержка CMake 3.14

- Visual Studio теперь может открыть существующие кэши CMake, созданные внешними средствами, например CMakeGUI или пользовательскими системами мета-сборки, или создать скрипты, которые сами вызывают cmake.exe.

- Усовершенствование производительности IntelliSense.

- Новый редактор параметров предоставляет альтернативу редактированию файла CMakeSettings.json вручную и частичное равенство с CMakeGUI.

- Visual Studio помогает начать разработку на C++ с помощью CMake в Linux, определяя наличие совместимой версии CMake на компьютере Linux. Если она отсутствует, предлагается ее установить.

- Несовместимые параметры в CMakeSettings, например несоответствие архитектур или несовместимые параметры генератора CMake, выделены волнистыми линиями в редакторе JSON и отображаются в списке ошибок.

- Цепочка инструментов vcpkg автоматически обнаруживается и включается для проектов CMake, которые открыты в интегрированной среде разработки, после запуска `vcpkg integrate install`. Это поведение можно отключить, указав пустой файл цепочки инструментов в CMakeSettings.

- Проекты CMake теперь включают отладку "Только мой код" по умолчанию.

- Предупреждения статического анализа теперь обрабатываются в фоновом режиме и отображаются в редакторе для проектов CMake.

- Более понятные сообщения о конце и начале сборки и конфигурации для проектов CMake и поддержка пользовательского интерфейса хода сборки Visual Studio. Кроме того, теперь есть параметр детализации CMake в разделе **Сервис > Параметры** для настройки уровня детализации сообщений о сборке и конфигурации CMake в окне вывода.

- Параметр `cmakeToolchain` теперь поддерживается в CMakeSettings.json для указания цепочек инструментов без изменения командной строки CMake вручную.

- Новое сочетание клавиш для меню **Собрать все** — **CTRL+SHIFT+B**.

##### <a name="visual-studio-2019-version-161"></a>Visual Studio 2019 версии 16.1

- Встроенная поддержка редактирования, сборки и отладки проектов CMake с Clang/LLVM. Подробные сведения см. в записи блога [Clang/LLVM Support in Visual Studio](https://devblogs.microsoft.com/cppblog/clang-llvm-support-in-visual-studio/) (Поддержка Clang/LLVM в Visual Studio).

## <a name="linux-and-the-windows-subsystem-for-linux"></a>Linux и подсистема Windows для Linux.

##### <a name="visual-studio-2019-version-161"></a>Visual Studio 2019 версии 16.1

- Поддержка [AddressSanitizer (ASan)](https://github.com/google/sanitizers/wiki/AddressSanitizer) в Linux и кроссплатформенных проектах CMake. Подробные сведения см. в записи блога [AddressSanitizer (ASan) for the Linux Workload in Visual Studio 2019](https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-the-linux-workload-in-visual-studio-2019/) (AddressSanitizer (ASan) для рабочей нагрузки Linux в Visual Studio 2019).

- Интегрированная поддержка Visual Studio для использования C++ с подсистемой Windows для Linux (WSL). Подробные сведения см. в записи блога [C++ with Visual Studio 2019 and Windows Subsystem for Linux (WSL)](https://devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/) (C++ с Visual Studio 2019 и подсистемой Windows для Linux (WSL)).

## <a name="incredibuild-integration"></a>Интеграция IncrediBuild

IncrediBuild теперь включается в виде дополнительного компонента в рабочую нагрузку **Разработка классических приложений на C++** . Монитор сборки IncrediBuild полностью интегрирован в IDE Visual Studio. Подробные сведения см. в записи блога [Visualize your build with IncrediBuild’s Build Monitor and Visual Studio 2019](https://devblogs.microsoft.com/cppblog/visualize-your-build-with-incredibuilds-build-monitor-and-visual-studio-2019/) (Визуализация сборки с помощью монитора сборки IncrediBuild и Visual Studio 2019).

## <a name="debugging"></a>Отладка

- Для приложений на C++, работающих в Windows, PDB-файлы теперь загружаются в отдельном 64-разрядном процессе. Это изменение устраняет ряд сбоев, вызванных нехваткой памяти для отладчика. Например, были возможны сбои при отладке приложений, содержащих большое количество модулей и PDB-файлов.

- Поиск включен в окнах **контрольных значений**, **видимых переменных** и **локальных переменных**.

## <a name="windows-desktop-development-with-c"></a>Разработка классических приложений для Windows на C++

- Следующие мастера C++, ATL и MFC больше не доступны:

  - Мастер компонентов ATL COM+ 1.0
  - Мастер компонентов ATL ASP
  - Мастер поставщика ATL OLE DB
  - Мастер страницы свойств ATL
  - Мастер потребителя ATL OLE DB
  - Потребитель ODBC MFC
  - Класс MFC из элемента управления ActiveX
  - Класс MFC из TypeLib.

  Пример кода для этих технологий находится в архиве в документации Майкрософт и репозитории VCSamples на GitHub.

- Пакет средств разработки программного обеспечения (SDK) Windows 8.1 больше не доступен в установщике Visual Studio. Обновите проекты C++ до последней версии пакета SDK для Windows 10. Если у вас есть жесткая зависимость от версии 8.1, ее можно скачать из архива Windows SDK.

- Windows XP больше нельзя выбрать в качестве целевой платформы для последнего набора инструментов C++. XP для библиотек и компилятора MSVC уровня VS 2017 по-прежнему поддерживается и может устанавливаться через раздел "Отдельные компоненты".

- В нашей документации настоятельно не рекомендуется использовать модули слияния для развертывания среды выполнения Visual C++. В этом выпуске мы принимаем дополнительные меры, чтобы отметить MSM как нерекомендуемые. Возможно, следует перенести центральное развертывание VCRuntime из MSM в распространяемый пакет.

## <a name="mobile-development-with-c-android-and-ios"></a>Разработка мобильных приложений на C++ (для iOS и Android)

C++ для Android теперь по умолчанию равняется на Android SDK 25 и пакет NDK для Android 16b.

## <a name="clangc2-platform-toolset"></a>Набор средств платформы Clang/C2

Экспериментальный компонент Clang/C2 удален. Для обеспечения полного соответствия стандартам C++ используйте набор инструментов MSVC с параметрами `/permissive-` и `/std:c++17` или же цепочку инструментов Clang/LLVM для Windows.

## <a name="code-analysis"></a>Анализ кода

- Анализ кода теперь выполняется автоматически в фоновом режиме. Предупреждения отображаются зелеными волнистыми линиями в редакторе при вводе. Дополнительные сведения см. в разделе [Анализа кода в редакторе в Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/in-editor-code-analysis-in-visual-studio-2019-preview-2/).

- Новые экспериментальные правила ConcurrencyCheck для хорошо известных типов стандартной библиотеки из заголовка \<mutex>. Дополнительные сведения см. в разделе [Параллельный анализ кода в Visual Studio 2019](https://devblogs.microsoft.com/cppblog/concurrency-code-analysis-in-visual-studio-2019/).

- Обновленная частичная реализация [инструмента проверки профиля времени существования](https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/) для обнаружения висячих указателей и ссылок. Дополнительные сведения см. в разделе [Обновление профиля времени существования в Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/lifetime-profile-update-in-visual-studio-2019-preview-2/).

- Дополнительные проверки сопрограмм, включая C26138, C26810, C26811 и экспериментальное правило C26800. Дополнительные сведения см. в разделе [Новые проверки анализа кода в Visual Studio 2019: использование после перемещения и сопрограмма](https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/).

##### <a name="visual-studio-2019-version-161"></a>Visual Studio 2019 версии 16.1

- Новые быстрые исправления для проверок неинициализированных переменных. Подробные сведения см. в записи блога [New code analysis quick fixes for uninitialized memory (C6001) and use before init (C26494) warnings](https://devblogs.microsoft.com/cppblog/new-code-analysis-quick-fixes-for-uninitialized-memory-c6001-and-use-before-init-c26494-warnings/) (Новые быстрые исправления анализа кода для предупреждений о неинициализированной памяти (C6001) и использовании переменных перед инициализацией (C26494)).

## <a name="unit-testing"></a>Модульное тестирование

Шаблон управляемого тестового проекта C++ больше не доступен. Вы можете продолжить использование платформы управляемых тестов C++ в существующих проектах. Но для новых модульных тестов мы рекомендуем использовать собственные тестовые платформы, для которых Visual Studio предоставляет шаблоны (MSTest, Google Test), или шаблон управляемого тестового проекта C#.

::: moniker-end

::: moniker range="=vs-2017"

В Visual Studio 2017 реализовано множество изменений и исправлений для среды C++. Мы устранили более 250 ошибок и обнаруженных проблем в компиляторе и инструментах. О многих из них нам сообщили клиенты с помощью инструментов для [отправки сообщения о проблеме и отправки предложения](/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2017) в разделе **Отправить отзыв**. Спасибо, что сообщаете нам об ошибках! Дополнительные сведения о новых возможностях всех компонентов Visual Studio см. на странице [Новые возможности Visual Studio 2017](/visualstudio/ide/whats-new-visual-studio-2017?view=vs-2017). Сведения о новых возможностях для C++ в Visual Studio 2019 см. в статье [What's New for C++ in Visual Studio](/cpp/overview/what-s-new-for-visual-cpp-in-visual-studio?view=vs-2019) (Новые возможности для C++ в Visual Studio). Сведения о новых возможностях для C++ в Visual Studio 2015 и более ранних версиях см. в статье [Visual C++ What's New 2003 through 2015](/cpp/porting/visual-cpp-what-s-new-2003-through-2015) (Новые возможности Visual C++ в версиях с 2003 по 2015).

## <a name="visual-studio-2017-c-compiler"></a>Компилятор C++ в Visual Studio 2017

### <a name="c-conformance-improvements"></a>Улучшение соответствия C++

Мы обновили компилятор C++ и стандартную библиотеку в этом выпуске с улучшенной поддержкой возможностей C++11 и C++14. Кроме того, в предварительном виде реализована поддержка определенных возможностей, которые, как предполагается, войдут в стандарт C++17. Подробные сведения см. в статье [C++ conformance improvements in Visual Studio 2017](cpp-conformance-improvements.md) (Улучшения соответствия C++ в Visual Studio 2017).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Компилятор поддерживает около 75 % новых возможностей C++17, включая структурированные привязки, лямбда-выражения **`constexpr`** , `if constexpr`, встроенные переменные, выражения свертывания и добавление **`noexcept`** в систему типов. Эти возможности доступны с использованием параметра **`/std:c++17`** . Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2017](cpp-conformance-improvements.md).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

Набор инструментов компилятора MSVC в Visual Studio версии 15.7 теперь соответствует стандарту C++. Дополнительные сведения см. в статьях [Announcing: MSVC Conforms to the C++ Standard](https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-c-standard/) (Объявление: MSVC соответствует стандарту C++) и [Соответствие стандартам языка Visual C++](../visual-cpp-language-conformance.md).

##### <a name="visual-studio-2017-version-158"></a>Visual Studio 2017 версии 15.8

Параметр компилятора [`/experimental:preprocessor`](../build/reference/experimental-preprocessor.md) позволяет включить новый экспериментальный препроцессор MSVC, который в будущем будет соответствовать всем применимым стандартам C и C++. Дополнительные сведения см. в статье [MSVC experimental preprocessor overview](../preprocessor/preprocessor-experimental-overview.md) (Обзор экспериментального препроцессора MSVC).

### <a name="new-compiler-options"></a>Новые параметры компилятора

- [`/permissive-`](../build/reference/permissive-standards-conformance.md): включение всех параметров компилятора, обеспечивающих строгое соответствие стандартам, и отключение большей части расширений от Майкрософт (но не `__declspec(dllimport)`, например). В Visual Studio 2017 версии 15.5 этот параметр включен по умолчанию.  Режим соответствия **`/permissive-`** включает поддержку двухэтапного поиска имени. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio](cpp-conformance-improvements.md).

- [`/diagnostics`](../build/reference/diagnostics-compiler-diagnostic-options.md): отображение расположения ошибки или предупреждения диагностики одним из трех способов: только номер строки, номер строки и столбец, номер строки и столбец с курсором в строке кода, вызвавшей ошибку.

- [`/debug:fastlink`](../build/reference/debug-generate-debug-info.md): ускорение компоновки на 30 % (по сравнению с Visual Studio 2015) без копирования всех сведений об отладке в PDB-файл. PDB-файл указывает на отладочную информацию для файлов объекта и библиотеки, используемых для создания исполняемого файла. См. статьи [Ускорение цикла сборки C++ в VS "15"с помощью `/Debug:fastlink`](https://devblogs.microsoft.com/cppblog/faster-c-build-cycle-in-vs-15-with-debugfastlink/) и [Рекомендации ускорению операций сборки C++ в Visual Studio](https://devblogs.microsoft.com/cppblog/recommendations-to-speed-c-builds-in-visual-studio/).

- В Visual Studio 2017 можно использовать [`/sdl`](../build/reference/sdl-enable-additional-security-checks.md) с [`/await`](../build/reference/await-enable-coroutine-support.md). Мы удалили ограничение [`/RTC`](../build/reference/rtc-run-time-error-checks.md) для сопрограмм.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- [`/std:c++14` и `/std:c++latest`](../build/reference/std-specify-language-standard-version.md): Эти параметры компилятора позволяют выбирать в проекте конкретные версии языка программирования C++, соответствующие стандарту ISO. Большинство новых стандартных функций защищены с помощью параметра **`/std:c++latest`** .

- [`/std:c++17`](../build/reference/std-specify-language-standard-version.md) включает набор функций C++17, который реализован с помощью компилятора. Этот параметр отключает компилятор и поддержку стандартной библиотеки для функций после выхода C++17 — тех функций, что были изменены и добавлены в более поздних версиях рабочего проекта — и исключает обновления стандарта C++. Чтобы включить эти функции, используйте **`/std:c++latest`** .

### <a name="codegen-security-diagnostics-and-versioning"></a>Создание кода, безопасность, диагностика и управления версиями

В этом выпуске представлено несколько улучшений в области оптимизации и создания кода, управления версиями набора инструментов и диагностики. К важным улучшениям можно отнести следующие:

- Улучшенное создание кода циклов. Поддержка автоматической векторизации деления целочисленных констант и улучшенное распознавание шаблонов memset.
- Повышенная защищенность кода. Более полная диагностика компилятора при переполнении буфера. Параметр [`/guard:cf`](../build/reference/guard-enable-control-flow-guard.md) теперь обеспечивает защиту операторов switch, которые создают таблицы переходов.
- Управление версиями. Значение встроенного препроцессорного макроса **\_MSC\_VER** теперь монотонно обновляется при каждом обновлении набора инструментов Visual C++. Дополнительные сведения см. в статье [Visual C++ Compiler Version](https://devblogs.microsoft.com/cppblog/visual-c-compiler-version/) (Версия компилятора Visual C++).
- Новое расположение набора инструментов. Компилятор и связанные средства сборки имеют новое расположение и структуру каталогов на компьютере разработки. Новый макет позволяет параллельно устанавливать несколько версий компилятора. Дополнительные сведения см. в статье [Compiler Tools Layout in Visual Studio 2017](https://devblogs.microsoft.com/cppblog/compiler-tools-layout-in-visual-studio-15/) (Макет инструментов компилятора в Visual Studio 2017).
- Улучшенная диагностика. В окне вывода теперь отображается столбец, в котором произошла ошибка. Дополнительные сведения см. в статье [Усовершенствования функций диагностики компилятора C++ в VS "15" Preview 5](https://devblogs.microsoft.com/cppblog/c-compiler-diagnostics-improvements-in-vs-15-rc/).
- При использовании сопрограмм экспериментальное ключевое слово **yield** (в параметре **`/await`** ) удалено. Нужно обновить код для использования `co_yield` вместо него. Дополнительные сведения см. в статье [о преобразовании ключевого слова `yield` в `co_yield` в Visual Studio 2017](https://devblogs.microsoft.com/cppblog/yield-keyword-to-become-co_yield-in-vs-2017/).

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

дополнительные улучшения диагностики в компиляторе. Дополнительные сведения см. в статье [Diagnostic Improvements in Visual Studio 2017 15.3.0](https://devblogs.microsoft.com/cppblog/diagnostic-improvements-in-vs2017-15-3-0/) (Улучшения диагностики в Visual Studio 2017 версии 15.3.0).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Улучшение производительности среды выполнения Visual C++ все так же реализуется за счет повышения качества генерируемого кода. Это означает, что можно просто перекомпилировать код, и приложение будет работать быстрее. Представлен ряд совершенно новых оптимизаций компилятора, например векторизация условных скалярных хранилищ, объединение вызовов функций `sin(x)` и `cos(x)` в новую функцию `sincos(x)`,а также устранение избыточных инструкций из оптимизатора SSA. Другие виды оптимизации компилятора являются улучшениями существующих функций, например эвристика векторизатора для условных выражений, улучшенные оптимизации цикла и значения типа float для функций min и max генератора кода. Компоновщик имеет новую и более быструю реализацию **`/OPT:ICF`** , что может привести к ускорению компоновки на 9 %. Также доступны другие улучшения производительности инкрементной компоновки. Дополнительные сведения см. в разделах [Параметр /OPT (оптимизации)](../build/reference/opt-optimizations.md) и [Параметр /INCREMENTAL (инкрементная компоновка)](../build/reference/incremental-link-incrementally.md).

Компилятор Microsoft C++ поддерживает Intel AVX-512. Он содержит инструкции, касающиеся длины вектора, которые применяют новые функции AVX-512 к 128-разрядным и 256-разрядным регистрам.

Параметр [/Zc:noexceptTypes-](../build/reference/zc-noexcepttypes.md) можно использовать для возврата к версии C++14 **`noexcept`** при использовании режима C++17 в целом. Этот параметр позволяет обновить исходный код для соответствия C++17, без необходимости переписывать весь код `throw()`. Дополнительные сведения см. в разделе [Удаление спецификации динамических исключений и noexcept](cpp-conformance-improvements.md#noexcept_removal).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Новый переключатель компилятора [/Qspectre](../build/reference/qspectre.md) предназначен для противодействия спекулятивному выполнению атак по сторонним каналам. Дополнительные сведения см. в записи блога [Spectre mitigations in MSVC](https://devblogs.microsoft.com/cppblog/spectre-mitigations-in-msvc/) (Устранение рисков с использованием Spectre в MSVC).
- Новое диагностическое предупреждение для устранения рисков Spectre. Подробнее см. в записи блога [Spectre diagnostic in Visual Studio 2017 Version 15.7 Preview 4](https://devblogs.microsoft.com/cppblog/spectre-diagnostic-in-visual-studio-2017-version-15-7-preview-4/) (Диагностика с использованием Spectre в Visual Studio 2017 версии 15.4, предварительная версия 4).
- Новое значение для параметра /Zc **`/Zc:__cplusplus`** обеспечивает корректное информирование о поддержке стандарта C++. Например, если этот параметр установлен и компилятор находится в режиме **`/std:c++17`** , значение будет расширено до **`201703L`** . Дополнительные сведения см. в записи блога [MSVC now correctly reports __cplusplus](https://devblogs.microsoft.com/cppblog/msvc-now-correctly-reports-__cplusplus/) (MSVC теперь корректно сообщает значение __cplusplus).

## <a name="c-standard-library"></a>Стандартная библиотека C++

### <a name="correctness-improvements"></a>Усовершенствования правильности

##### <a name="visual-studio-2017-rtm-version-150"></a>Visual Studio 2017 RTM (версия 15.0)

- Незначительные усовершенствования диагностики `basic_string``_ITERATOR_DEBUG_LEVEL != 0`. При активации проверки IDL в механизме обработки строк теперь указывается конкретное поведение, которое стало причиной активации. Например, вместо "string iterator not dereferencable" (итератор строки не является разыменуемым) вы получите сообщение "cannot dereference string iterator because it is out of range (e.g. an end iterator)" (не удается разыменовать итератор строки, так как он выходит за пределы диапазона, например конечный итератор).
- Исправлен оператор присваивания перемещением `std::promise`, из-за которого раньше в коде могла возникнуть вечная блокировка.
- Устранены ошибки в компиляторе, связанные с неявным преобразованием `atomic<T*>` в `T*`.
- `pointer_traits<Ptr>` теперь корректно обнаруживает `Ptr::rebind<U>`.
- Исправлен отсутствующий квалификатор **`const`** в операторе вычитания `move_iterator`.
- Исправлено автоматическое неправильное создание кода для определяемых пользователем распределителей с отслеживанием состояния, запрашивающих `propagate_on_container_copy_assignment` и `propagate_on_container_move_assignment`.
- `atomic<T>` теперь допускает перегруженные `operator&()`.
- Немного улучшилась диагностика компилятора для неверных вызовов `bind()`.

В Visual Studio 2017 RTM представлены и другие улучшения стандартной библиотеки. Полный список см. в записи блога команды разработчиков C++ [об исправлениях стандартной библиотеки в Visual Studio 2017 RTM](https://devblogs.microsoft.com/cppblog/stl-fixes-in-vs-2017-rtm/).

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Теперь контейнеры стандартной библиотеки выполняют приведение `max_size()` в `numeric_limits<difference_type>::max()`, а не `max()` в `size_type`. Это гарантирует, что результат `distance()` с итераторами из этого контейнера можно представить в возвращаемом типе `distance()`.
- Исправлена отсутствующая специализация `auto_ptr<void>`.
- Алгоритмы `for_each_n()`, `generate_n()` и `search_n()` ранее не компилировались, если аргумент длины не был целочисленного типа. Теперь они пытаются преобразовать значения длины нецелочисленного типа в тип `difference_type` итераторов.
- `normal_distribution<float>` больше не выдает предупреждения в стандартной библиотеке о сужающем преобразовании из типа double во float.
- Исправлены некоторые операции `basic_string`, которые использовали `npos` вместо `max_size()` при проверке переполнения максимального размера.
- `condition_variable::wait_for(lock, relative_time, predicate)` приходилось ожидать в течение всего относительного времени в случае ложного пробуждения. Теперь этот метод ожидает только в течение одного интервала относительного времени.
- `future::get()` теперь не допускает `future`, как того требует стандарт.
- `iterator_traits<void *>` являлся критической ошибкой, так как он пытался сформировать `void&`. Теперь он становится пустой структурой, позволяющей использовать `iterator_traits` в условиях SFINAE is iterator.
- Некоторые предупреждения, выдававшиеся в **-Wsystem-headers** Clang, были исправлены.
- Кроме того, исправлена ошибка "Спецификация исключений в объявлении не соответствует предыдущему объявлению", о которой сообщал Clang **-Wmicrosoft-exception-spec**.
- Кроме того, исправлены предупреждения упорядочивания mem-initializer-list, о которых сообщают Clang и C1XX.
- Неупорядоченные контейнеры не переключали хэширование и предикаты при переключении. Теперь они это делают.
- Многие операции переключения контейнеров теперь помечены как **`noexcept`** (так как наша стандартная библиотека никогда не будет выдавать исключение при обнаружении неопределенного условия поведения non-`propagate_on_container_swap` non-equal-allocator).
- Многие операции `vector<bool>` теперь помечены как **`noexcept`** .
- Стандартная библиотека теперь будет требовать сопоставление распределителя `value_type` (в режиме C++17) с резервной возможностью отказа.
- Исправлены некоторые условия, при которых self-range-insert в `basic_string` будет шифровать содержимое строки. (Обратите внимание, что использование self-range-insert в векторах все еще запрещено стандартной библиотекой.)
- `basic_string::shrink_to_fit()` больше не затрагивается `propagate_on_container_swap`распределителя.
- `std::decay` теперь обрабатывает недопустимые типы функций (например, типы функций с квалификацией типа cv, ref или обоих типов одновременно).
- Изменены директивы включения для использования правильного учета регистра и косых черт, улучшая мобильность.
- Исправлено предупреждение C4061 "перечислитель *перечислитель* в параметре перечисления *перечисление* неявно обработан меткой регистра". Это предупреждение отключено по умолчанию и исправлено в качестве исключения в общей политике предупреждений в стандартной библиотеке. (В стандартной библиотеке обеспечивается чистота **`/W4`** , но не **`/Wall`** . Множество отключенных по умолчанию предупреждений срабатывают слишком часто и не предназначены для постоянного использования.)
- Улучшены проверки отладки `std::list`. Итераторы списка теперь проверяют `operator->()`, а `list::unique()` помечает итераторы как недействительные.
- Исправлено метапрограммирование uses-allocator в `tuple`.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- `std::partition` теперь вызывает предикат `N` раз вместо `N + 1` раз, в соответствии с требованиями стандарта.
- Попытки избежать магической статики в версии 15.3 исправлены в версии 15.5.
- `std::atomic<T>` больше не требуется `T`, чтобы быть конструируемым по умолчанию.
- Алгоритмы кучи, которые принимают логарифмическое время, теперь работают иначе, если включена отладка итератора. Они больше не реализуют утверждение линейного времени о том, что входные данные на самом деле представляют собой кучу.
- `__declspec(allocator)` теперь защищается только для C1XX, чтобы предотвращать вывод предупреждений из Clang, который не понимает declspec.
- `basic_string::npos` теперь доступен в качестве константы времени компиляции.
- `std::allocator` теперь правильно обрабатывает выделение чрезмерно выровненных типов (типов, выравнивание которых больше `max_align_t`) в режиме C++17 (если не отключено с помощью **`/Zc:alignedNew-`** ).  Например, векторы объектов с 16- или 32-байтовым выравниванием теперь правильно выравниваются для инструкций SSE и AVX.

### <a name="conformance-improvements"></a>Улучшение соответствия

- Были добавлены \<any\>, \<string_view\>, `apply()`, `make_from_tuple()`.
- Добавлены \<optional\>, \<variant\>, `shared_ptr::weak_type` и \<cstdalign\>.
- Включено C++14 **`constexpr`** в `min(initializer_list)`, `max(initializer_list)`, `minmax(initializer_list)`, `min_element()`, `max_element()` и `minmax_element()`.

Дополнительные сведения см. в статье [Таблица соответствия Microsoft Visual C++ стандартам языка](../visual-cpp-language-conformance.md).

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Реализовано несколько дополнительных функций C++17. Дополнительные сведения см. в статье [Таблица соответствия Microsoft Visual C++ стандартам языка](cpp-conformance-improvements.md#improvements_153).
- Реализовано исправление P0602R0: variant и optional должны распространять тривиальность копирования и перемещения.
- Стандартная библиотека теперь официально допускает отключение динамической RTTI с помощью параметра [/GR-](../build/reference/gr-enable-run-time-type-information.md). Для `dynamic_pointer_cast()` и `rethrow_if_nested()` изначально требуется **`dynamic_cast`** , поэтому стандартная библиотека теперь помечает их как `=delete` в параметре **`/GR-`** .
- Даже если динамическая идентификация типа (RTTI) отключена через **`/GR-`** , статистическая RTTI (в виде `typeid(SomeType)`) все еще доступна и позволяет применять несколько компонентов стандартной библиотеки. Стандартная библиотека теперь также поддерживает отключение этой возможности с использованием **`/D_HAS_STATIC_RTTI=0`** . Этот флаг отключает также функции-члены `std::any`, `target()` и `target_type()` для `std::function` и дружественную функцию-член `get_deleter()` для `std::shared_ptr` и `std::weak_ptr`.
- Стандартная библиотека теперь использует C++14 **`constexpr`** без дополнительный условий вместо макросов, определяемых условиями.
- Стандартная библиотека теперь использует шаблоны псевдонимов внутренним образом.
- Стандартная библиотека теперь внутренне использует **`nullptr`** вместо `nullptr_t{}`. (NULL больше не используется внутренне. Внутреннее использование 0 в качестве null постепенно отменяется.)
- Стандартная библиотека теперь внутренне использует `std::move()` вместо стилистически неправильного использования `std::forward()`.
- Изменено с `static_assert(false, "message")` на `#error message`. Это изменение улучшает диагностику компилятора, так как `#error` немедленно прекращает компиляцию.
- Стандартная библиотека больше не помечает функции как `__declspec(dllimport)`. Для современных компоновщиков это больше не требуется.
- Извлечены SFINAE для аргументов шаблона по умолчанию, что сокращает беспорядок по сравнению с типами возвращаемых данных и типами аргумента функции.
- При проверке отладки в режиме \<random\> теперь используются обычные механизмы стандартной библиотеки вместо внутренней функции `_Rng_abort()`, которая вызывала `fputs()` в **stderr**. Реализация этой функции оставлена для совместимости на уровне двоичного кода. Мы удалим ее в следующей версии стандартной библиотеки, несовместимой с двоичным кодом.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- В соответствии со стандартом C++17 были добавлены, признаны нерекомендуемыми и удалены несколько функций стандартной библиотеки. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio](cpp-conformance-improvements.md#improvements_155).
- Экспериментальная поддержка следующих параллельных алгоритмов:
  - `all_of`
  - `any_of`
  - `for_each`
  - `for_each_n`
  - `none_of`
  - `reduce`
  - `replace`
  - `replace_if`
  - `sort`
- В настоящее время подписи для следующих параллельных алгоритмов добавлены, но не параллелизированы. Согласно результатам профилирования, нет смысла использовать алгоритмы параллелизации, которые только перемещают или переставляют элементы:
  - `copy`
  - `copy_n`
  - `fill`
  - `fill_n`
  - `move`
  - `reverse`
  - `reverse_copy`
  - `rotate`
  - `rotate_copy`
  - `swap_ranges`

##### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- \<memory_resource>
- Основы работы с библиотеками V1
- Удаление присваивания `polymorphic_allocator`
- Улучшение выведения аргументов шаблонов класса

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Поддержка параллельных алгоритмов теперь не является экспериментальной
- Новая реализация \<filesystem>
- Простые преобразования строк (частично)
- `std::launder()`
- `std::byte`
- `hypot(x,y,z)`
- Отказ от лишнего вырождения
- Специальные математические функции
- `constexpr char_traits`
- Рекомендации по удержанию для стандартной библиотеки

Дополнительные сведения см. в статье [Таблица соответствия Microsoft Visual C++ стандартам языка](../visual-cpp-language-conformance.md).

### <a name="performance-and-throughput-fixes"></a>Повышение производительности и пропускной способности

- Теперь перегрузки `basic_string::find(char)` вызывают `traits::find` только один раз. Ранее это было реализовано в качестве общего механизма поиска строки для строки длиной 1.
- Теперь `basic_string::operator==` проверяет размер строки перед сравнением содержимого строк.
- Удалена взаимозависимость элементов управления в `basic_string`, которая вызывала трудности при анализе оптимизатором компилятора. Для всех коротких строк вызов `reserve` по-прежнему имеет ненулевое значение затрат при отсутствии выполняемых операций.
- Мы значительно изменили `std::vector` для обеспечения правильной работы и производительности. Теперь присвоение псевдонима во время вставки и назначения места обрабатывается правильно и в соответствии с требованиями стандарта. При использовании `move_if_noexcept()` и другой логики гарантируется возникновение исключений в тех случаях, когда того требует стандарт, а при вставке или назначении места выполняется меньше операций с элементами.
- Стандартная библиотека C++ теперь избегает разыменования пустых (NULL) указателей.
- Улучшена производительность `weak_ptr::lock()`.
- Для повышения скорости работы компилятора заголовки стандартной библиотеки C++ теперь не включают объявления для ненужных встроенных функций компилятора.
- Производительность конструкторов перемещения `std::string`и `std::wstring` повышена более чем в 3 раза.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Устранена проблема взаимодействия с **`noexcept`** , которая не позволяла встраивать реализацию `std::atomic` в функции, которые используют структурированную обработку исключений (SEH).
- Изменена внутренняя функция стандартной библиотеки `_Deallocate()`, чтобы оптимизировать ее в код меньшего размера, что позволяет встроить ее в большее количество мест.
- Изменен `std::try_lock()` для использования расширения пакета вместо рекурсии.
- Улучшен алгоритм предотвращения взаимоблокировки `std::lock()` при использовании операций `lock()` вместо обращения ко всем методам `try_lock()` блокировки.
- Включена оптимизация именованных возвращаемых значений в `system_category::message()`.
- `conjunction` и `disjunction` теперь создают экземпляры типов `N + 1`, а не типов `2N + 2`.
- `std::function` больше не создает экземпляры механизмов поддержки распределителя для каждого вызываемого элемента с удалением типа, улучшая пропускную способность и уменьшая размер .obj в программах, которые передают много различных лямбда-выражений в `std::function`.
- `allocator_traits<std::allocator>` содержит вручную встроенные операции `std::allocator`, уменьшая объем кода в коде, который взаимодействует с `std::allocator` только через `allocator_traits` (то есть, в большей части кода).
- Интерфейс минимального распределителя C++11 теперь обрабатывается таким образом: стандартная библиотека напрямую вызывает `allocator_traits`, а не помещает распределитель во внутренний класс `_Wrap_alloc`. Это изменение уменьшает размер кода, создаваемого для поддержки распределителя, в некоторых случаях улучшается способность оптимизатора делать выводы о контейнерах стандартной библиотеки и оптимизируется отладка (так как теперь в отладчике отображается тип распределителя, а не `_Wrap_alloc<your_allocator_type>`).
- Удалено метапрограммирование для настроенного метода `allocator::reference`, распределители которого запрещено настраивать. (Распределители могут настроить в контейнерах использование специальных указателей, но не специальных ссылок.)
- Интерфейс компилятора переделан для распаковывания итераторов отладки в цикле for на основе диапазона, улучшая производительность отладочных сборок.
- Путь внутреннего сжатия `basic_string` для `shrink_to_fit()` и `reserve()` больше не перераспределяет операции, уменьшая объем кода для всех участников изменения.
- Внутренний путь создания `basic_string` больше не находится в пути `shrink_to_fit()`.
- Операции изменения `basic_string` теперь факторизованы в быстром пути без распределения и в функциях медленного пути с распределением, повышая вероятность встраивания стандартного сценария без распределения в вызывающие объекты.
- Операции изменения `basic_string` теперь создают перераспределенные буферы в предпочтительном состоянии, а не изменяют их размер на месте. Например, вставка в начале строки теперь перемещает содержимое после вставки только один раз. Оно перемещается либо вниз, либо в новый выделенный буфер. Оно больше не перемещается дважды в регистре перераспределения — сначала в новый выделенный буфер, а затем вниз.
- Операции, вызывающие стандартную библиотеку C в \<string\>, теперь кэшируют адрес `errno` для удаления повторяющегося взаимодействия с протоколом TLS.
- Упрощена реализация `is_pointer`.
- Завершено изменение основанного на функции выражения SFINAE на **`struct`** или `void_t`.
- Алгоритмы стандартной библиотеки теперь не используют итераторы последующего увеличения.
- Устранены предупреждения об усечении при использовании 32-разрядных распределителей в 64-разрядных системах.
- `std::vector` перемещает назначение эффективнее в случае использования неравного распределителя без применения non-POCMA, повторно используя буфер по необходимости.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- `basic_string<char16_t>` теперь использует те же `memcmp`, `memcpy`, а также аналогичные оптимизации, применяемые `basic_string<wchar_t>`.
- Ограничение оптимизатора, которое не позволяло указателям на функции быть представленными как встроенные в Visual Studio 2015 с обновлением 3, устранено, что способствует восстановлению производительности `lower_bound(iter, iter, function pointer)`.
- Затраты на проверку порядка входных данных для включаемых файлов, `includes`, `set_difference`, `set_symmetric_difference` и `set_union`, выполняемую при отладке итератора, были сокращены за счет распаковки итераторов перед проверкой.
- `std::inplace_merge` теперь пропускает элементы, которые уже находятся в нужной позиции.
- При создании `std::random_device` больше не создается и затем удаляется `std::string`.
- `std::equal` и `std::partition` использовали проход оптимизации потоков перехода, который избавлял от сравнения итераторов.
- Когда `std::reverse` передает указатели на традиционно копируемый `T`, передача будет выполняться в рукописную векторизированную реализацию.
- `std::fill`, `std::equal` и `std::lexicographical_compare` могут выполнять передачу в `memset` и `memcmp` для `std::byte` и `gsl::byte` (и другие аналогичные символьным перечисления и классы перечислений). `std::copy` выполняет диспетчеризацию с помощью `is_trivially_copyable`, поэтому вносить изменения не требуется.
- Стандартная библиотека больше не содержит деструкторы с пустыми скобками, единственное действие которых заключалось в том, чтобы сделать типы нетривиально уничтожаемыми.

## <a name="other-libraries"></a>Прочие библиотеки

### <a name="open-source-library-support"></a>Поддержка библиотеки с открытым исходным кодом

**Vcpkg** является средством командной строки с открытым исходным кодом, которое значительно упрощает процесс получения и создания статических библиотек открытым исходным кодом C++ и библиотек DLL в Visual Studio. Дополнительные сведения см. в разделе [vcpkg: диспетчер пакетов для C++](../build/vcpkg.md).

### <a name="cpprest-sdk-290"></a>Пакет SDK для CPPRest 2.9.0

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

CPPRestSDK, кроссплатформенный веб-API для C++, был обновлен до версии 2.9.0. Дополнительные сведения см. в статье [Доступность CppRestSDK 2.9.0 в GitHub](https://devblogs.microsoft.com/cppblog/cpprestsdk-2-9-0-is-available-on-github/).

### <a name="atl"></a>ATL

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- Еще один набор исправлений соответствия поиска по имени.
- Имеющиеся конструкторы перемещения и операторы присваивания перемещения теперь правильно помечены как не предусматривающие формирование исключений.
- Отменено отключение допустимого предупреждения C4640 о потокобезопасной инициализации локальных статических элементов в atlstr.h.
- Потокобезопасная инициализация локальных статических элементов автоматически отключалась в наборе инструментов XP при использовании ATL и сборке библиотеки DLL. Теперь этого не происходит. Если вы не хотите использовать потокобезопасную инициализацию, добавьте **`/Zc:threadSafeInit-`** в параметры проекта.

### <a name="visual-c-runtime"></a>Среда выполнения Visual C++

- Новый заголовок "cfguard.h" для символов защиты потока управления.

## <a name="visual-studio-2017-c-ide"></a>Интегрированная среда разработки для языка C++ Visual Studio 2017

- Повышена производительность изменения конфигурации для проектов в машинном коде на C++ и проектов C++/CLI. При первой активации конфигурации решения процесс теперь будет работать быстрее, а все последующие активации будут происходить практически мгновенно.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Некоторые мастера проекта и кода были переписаны в стиле диалоговых окон с подписями.
- При выборе пункта меню **Добавить класс** теперь запускается мастер добавления классов. Все остальные элементы, которые ранее здесь находились, теперь доступны в разделе **Добавить > Новый элемент**.
- Проекты Win32 теперь находятся в каталоге **Классические приложения Windows** в диалоговом окне **Создание проекта**.
- При выборе шаблонов **Консольное приложение Windows** и **Классическое приложение Windows** теперь создаются проекты без вызова мастера. Теперь доступен новый **мастер создания классических приложений Windows**. Он отображается в той же категории, что и прежний мастер **создания консольных приложение Win32**, и с теми же параметрами.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

несколько операций C++, которые используют модуль IntelliSense для навигации по коду и рефакторинга кода, работают гораздо быстрее. Следующие данные основаны на решении Visual Studio Chromium решения с 3500 проектами.

| Функция | Повышение производительности |
|--|--|
| Переименовать | в 5,3 раза |
| Изменение сигнатуры | в 4,5 раза |
| Найти все ссылки | в 4,7 раза |

C++ теперь поддерживает комбинацию клавиши CTRL+щелчок мыши, что упрощает **переход к определениям** с помощью мыши. Визуализатор структуры из пакета инструментов повышения производительности теперь также включен в продукт по умолчанию.

## <a name="intellisense"></a>IntelliSense

- По умолчанию теперь используется новое ядро СУБД на основе SQLite. Новый модуль ускоряет операции базы данных, такие как **переход к определению** и **поиск всех ссылок**. Он значительно сокращает начальное время анализа решения. Параметр перемещен в раздел **Средства > Параметры > Текстовый редактор > C/C++ > Дополнительно**. (Раньше он находился в разделе ...C/ C++ > Экспериментальные.)

- Улучшена производительность IntelliSense в проектах и файлах, где не используются предкомпилированные заголовки. В текущем файле для заголовков будет создан автоматический предкомпилированный заголовок.

- Добавлена фильтрация ошибок и справка по ошибкам IntelliSense для списка ошибок. Теперь выполнить фильтрацию можно, просто щелкнув столбец ошибок. Кроме того, если щелкнуть конкретные ошибки или нажать клавишу F1, запустится поиск сообщения об ошибке в сети.

  ![Список ошибок](media/ErrorList1.png "Список ошибок")

  ![Отфильтрованный список ошибок](media/ErrorList2.png "Отфильтрованный список ошибок")

- Добавлена фильтрация пунктов списка элементов по виду.

  ![Фильтрация списка элементов](media/mlfiltering.png "Фильтрация списка элементов")

- Добавлена новая экспериментальная возможность — прогнозная технология IntelliSense, — которая фильтрует содержимое списка элементов с учетом контекста. Подробнее см. статью [Усовершенствования C++ IntelliSense — прогнозная технология IntelliSense и фильтрация](https://devblogs.microsoft.com/cppblog/c-intellisense-improvements-predictive-intellisense-filtering/).
- Команда **Найти все ссылки** (SHIFT+F12) теперь позволяет легко перемещаться даже по сложным базам кода. Она предоставляет расширенные возможности группирования, фильтрации, сортировки, поиска в найденном и цветового выделения результатов. Это дает вам четкое понимание ссылок. Для C++ предоставлен новый компонент пользовательского интерфейса, который содержит информацию о том, выполняется ли чтение из переменной или запись в переменную.
- Функция замены точки на стрелку IntelliSense была перенесена из экспериментальных в расширенные и теперь включена по умолчанию. Функции **расширения областей** и **приоритета расширения** в редакторе также были перенесены из экспериментальных в расширенные.
- Экспериментальные функции рефакторинга **Изменить сигнатуру** и **Извлечь функцию** теперь доступны по умолчанию.
- Добавлена экспериментальная функция для проектов C++ "Меньшее время загрузки проекта". Когда вы в следующий раз откроете проект C++, он загрузится быстрее, а в следующий раз — *очень* быстро.
- Некоторые из этих функций являются общими для других языков, а некоторые специфичны для C++. Дополнительные сведения об этих новых возможностях см. в [объявлении о выпуске Visual Studio 15, предварительная версия 5](https://devblogs.microsoft.com/visualstudio/announcing-visual-studio-15-preview-5/).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- добавлена поддержка ClangFormat. Дополнительные сведения см. в записи блога [ClangFormat Support in Visual Studio 2017](https://devblogs.microsoft.com/cppblog/clangformat-support-in-visual-studio-2017-15-7-preview-1/) (Поддержка ClangFormat в Visual Studio).

## <a name="non-msbuild-projects-with-open-folder"></a>Поддержка проектов, отличных от MSBuild, с помощью функции "Открыть папку"

В Visual Studio 2017 появилась функция **Открыть папку**. Она позволяет писать код, выполнять сборку и отладку в папке, содержащей исходный код, не создавая каких-либо решений и проектов. Стало намного проще начать работу с Visual Studio, даже если проект не основан на MSBuild. Функция **Открыть папку** предоставляет доступ к мощным средствам для анализа, редактирования, сборки и отладки кода. Это та же функция, которую Visual Studio уже предоставляет для проектов MSBuild. Дополнительные сведения см. в статье [Проекты "Открыть папку" для C++](../build/open-folder-projects-cpp.md).

- Улучшения в процедуре открытия папки. Можно выполнить настройку с помощью следующих файлов JSON.
  - CppProperties.json используется для настройки работы с IntelliSense и браузером.
  - Tasks.json используется для настройки этапов сборки.
  - Launch.json используется для настройки процедуры отладки.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Улучшенная поддержка альтернативных компиляторов и сред сборки, таких как MinGW и Cygwin. Дополнительные сведения см. в статье [Using MinGW and Cygwin with Visual C++ and Open Folder](https://devblogs.microsoft.com/cppblog/using-mingw-and-cygwin-with-visual-cpp-and-open-folder/) (Использование MinGW и Cygwin с Visual C++ и функцией "Открыть папку").
- Добавлена поддержка определения глобальных и зависящих от конфигурации переменных среды в файлах CppProperties.json и CMakeSettings.json. Эти переменные среды могут использоваться в конфигурациях отладки, определенных в файле launch.vs.json, и в задачах, определенных в файле tasks.vs.json. Дополнительные сведения см. в статье [Использование MinGW и Cygwin с Visual C++ и функцией "Открыть папку"](https://devblogs.microsoft.com/cppblog/customizing-your-environment-with-visual-c-and-open-folder/).
- Улучшена поддержка генератора CMake Ninja, включая упрощение выбора 64-разрядной платформы в качестве целевой.

## <a name="cmake-support-via-open-folder"></a>Поддержка CMake с помощью функции "Открыть папку"

В Visual Studio 2017 добавлена поддержка использования проектов CMake без преобразования в файлы проекта MSBuild (с расширением VCXPROJ). Дополнительные сведения см. в статье [Проекты CMake в Visual C++](../build/cmake-projects-in-visual-studio.md). При открытии проектов CMake с помощью функции **Открыть папку** автоматически настраивается среда для редактирования, сборки и отладки кода C++.

- Для работы C++ IntelliSense не требуется создавать файл CppProperties.json в корневой папке. Мы также добавили новый раскрывающийся список, который позволяет пользователям легко переключаться между конфигурациями, предоставляемыми файлами CMake и CppProperties.json.

- Дальнейшая настройка поддерживается посредством файла CMakeSettings.json, который находится в одной папке с файлом CMakeLists.txt.

  ![Функция "Открыть папку" в CMake](media/cmake-cpp.png "Функция "Открыть папку" в CMake")

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- добавлена поддержка генератора CMake Ninja.

##### <a name="visual-studio-2017-version-154"></a>Visual Studio 2017 версии 15.4

- добавлена поддержка импорта существующих кэшей CMake.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- добавлена поддержка CMake 3.11, анализ кода в проектах CMake, представление целевых объектов в обозревателе решений, параметры формирования кэша и компиляция на базе одного файла. Дополнительные сведения см. в статьях [CMake support in Visual Studio](https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/) (Поддержка CMake в Visual Studio) [CMake projects in Visual C++](../build/cmake-projects-in-visual-studio.md) (Проекты CMake в Visual C++).

## <a name="windows-desktop-development"></a>Разработка классических приложений для Windows

Теперь предоставляется более точный контроль над процедурой установки исходной рабочей нагрузки C++. Мы добавили возможность выбора компонентов, чтобы вы могли устанавливать только необходимые инструменты. В пользовательском интерфейсе установщика указаны неточные размеры установки для компонентов. Таким образом, общий размер занижен.

Чтобы успешно создавать проекты Win32 в рабочей нагрузке для разработки приложений на C++, необходимо установить набор средств и пакет SDK для Windows. Для гарантии работы следует установить рекомендуемые (выбранные) компоненты **Набор средств VC++ 2017 v141 (x86, x64)** и **Пакет SDK Windows 10 (10.0.nnnnn)** . Если необходимые средства не установлены, создание проектов завершится ошибкой, а мастер перестанет отвечать на запросы.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Visual C++ Build Tools (ранее доступный как отдельный продукт), теперь включен в Visual Studio Installer в качестве рабочей нагрузки. Эта рабочая нагрузка устанавливает только инструменты, необходимые для сборки проектов C++ без установки среды Visual Studio. Включены наборы инструментов v141 и v140. Набор инструментов v141 содержит последние улучшения в Visual Studio 2017 версии 15.5. Дополнительные сведения см. в статье [В состав Visual Studio Build Tools теперь входят наборы инструментов MSVC VS2017 и VS2015](https://devblogs.microsoft.com/cppblog/visual-studio-build-tools-now-include-the-vs2017-and-vs2015-msvc-toolsets/).

## <a name="linux-development-with-c"></a>Разработка приложений для Linux на C++

Популярное расширение, [Visual C++ для разработки приложений Linux](https://marketplace.visualstudio.com/items?itemName=VisualCppDevLabs.VisualCforLinuxDevelopment), теперь стало частью Visual Studio. В этой установке представлено все необходимое для разработки и отладки приложений C++, работающих в среде Linux.

##### <a name="visual-studio-2017-version-152"></a>Visual Studio 2017 версии 15.2

улучшение использования кроссплатформенного кода и типа визуализации. Дополнительные сведения см. в статье [Linux C++ improvements for cross-platform code sharing and type visualization](https://devblogs.microsoft.com/cppblog/linux-cross-platform-and-type-visualization/) (Улучшения Linux C++ при использовании кроссплатформенного кода и визуализации типов).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- Рабочая нагрузка Linux имеет дополнительную поддержку для **rsync** в качестве альтернативы **sftp** для синхронизации файлов на удаленных компьютерах Linux.
- Добавлена поддержка для перекрестной компиляции, предназначенной для микроконтроллеров ARM. Чтобы включить ее в установку, выберите рабочую нагрузку **Разработка приложений Linux на C++** и установите флажок **Разработка для встроенных платформ и Интернета вещей**. В вашу установку будут добавлены инструменты перекрестной компиляции ARM GCC и Make. Дополнительные сведения см. в статье [Перекрестная компиляция ARM GCC в Visual Studio](https://devblogs.microsoft.com/cppblog/arm-gcc-cross-compilation-in-visual-studio/).
- Добавлена поддержка для CMake. Теперь вы можете работать с существующей базой кода, не преобразовывая ее в проект Visual Studio. Дополнительные сведения см. в разделе [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).
- Добавлена поддержка для выполнения удаленных задач. Эта возможность позволяет запускать любую команду в удаленной системе, которая определена в диспетчере подключений Visual Studio. Удаленные задачи также позволяют копировать файлы в удаленную систему.
Дополнительные сведения см. в разделе [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Различные улучшения сценариев рабочих нагрузок в Linux. Дополнительные сведения см. в записи блога [Изменения в рабочих нагрузках C++ в Linux для системы проектов, консольного окна Linux, rsync and команды "Присоединение к процессу"](https://devblogs.microsoft.com/cppblog/linux-c-workload-improvements-to-the-project-system-linux-console-window-rsync-and-attach-to-process/).
- IntelliSense для заголовков удаленных подключений Linux. Дополнительные сведения см. в статьях [IntelliSense for Remote Linux Headers](https://devblogs.microsoft.com/cppblog/intellisense-for-remote-linux-headers/) (IntelliSense для удаленных заголовков Linux) и [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).

## <a name="game-development-with-c"></a>Разработка игр на C++

Доступны все возможности C++ для создания профессиональных игр на базе DirectX или Cocos2d.

## <a name="mobile-development-with-c-for-android-and-ios"></a>Разработка мобильных приложений на C++ для iOS и Android

Теперь в Visual Studio можно создавать мобильные приложения для Android и iOS и отлаживать их.

## <a name="universal-windows-apps"></a>Универсальные приложения Windows

C++ поставляется как дополнительный компонент для рабочей нагрузки универсального приложения для Windows. В настоящее время проекты C++ необходимо обновлять вручную. В Visual Studio 2017 можно открыть проект универсальной платформы Windows, предназначенный для версии 140. Тем не менее, если у вас не установлена среда Visual Studio 2015, вам нужно выбрать набор инструментов платформы версии 141 на страницах свойств проекта.

## <a name="new-options-for-c-on-universal-windows-platform-uwp"></a>Новые возможности C++ на универсальной платформе Windows (UWP)

Доступны новые возможности написания и упаковки приложений C++ для универсальной платформы Windows и Microsoft Store. Инфраструктура моста для классических приложений позволяет упаковать имеющееся классическое приложение или COM-объект для развертывания через Microsoft Store. Также его можно подготовить для развертывания через существующие каналы с помощью загрузки неопубликованных компонентов. Благодаря новым возможностям в Windows 10 можно добавлять функции UWP в классическое приложение различными способами. Дополнительные сведения см. в статье [Мост для классических приложений](/windows/uwp/porting/desktop-to-uwp-root).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Добавлен шаблон **Проект упаковки приложений Windows**, который значительно упрощает упаковку классических приложений благодаря мосту для классических приложений. Он находится в разделе **Файл | Создать | Проект | Установленные | Visual C++ | Универсальная платформа Windows**. Дополнительные сведения см. в статье [Упаковка приложения с помощью Visual Studio (мост для классических приложений)](/windows/uwp/porting/desktop-to-uwp-packaging-dot-net).

При написании кода теперь можно использовать C++/WinRT — это проекция стандартного C++ для среды выполнения Windows, реализованная исключительно за счет файлов заголовков. Она позволяет как использовать, так и создавать API среды выполнения Windows с помощью любого соответствующего стандартам компилятора C++. C++/WinRT предоставляет разработчикам на C++ первоклассный доступ к современным API Windows. См. дополнительные сведения в статье [C++/WinRT. Modern C++ for the Windows Runtime](https://moderncpp.com/) (C++/WinRT. Современные средства C++ для среды выполнения Windows).

Начиная со сборки 17025 Insider Preview пакета SDK Windows, C++/WinRT входит в пакет Windows SDK. Дополнительные сведения см. в статье [C++/WinRT включен в состав пакета Windows SDK](https://devblogs.microsoft.com/cppblog/cppwinrt-is-now-included-the-windows-sdk/).

## <a name="the-clangc2-platform-toolset"></a>Набор инструментов платформы Clang/C2

Набор инструментов Clang/C2, который поставляется с Visual Studio 2017, теперь поддерживает параметр **`/bigobj`** , который крайне важен для сборки больших проектов. Он также включает несколько важных исправлений как во внешнем интерфейсе, так и в серверной части компилятора.

## <a name="c-code-analysis"></a>Анализ кода C++

Средства проверки на соответствие кода C++ [проверенным рекомендациям](https://github.com/isocpp/CppCoreGuidelines) (C++ Core Checker) теперь распространяются вместе с Visual Studio. Включите средства проверки на странице **Code Analysis Extensions** (Расширения анализа кода) на страницах свойств проекта. После этого расширения будут использоваться при анализе кода. Дополнительные сведения см. в статье [Using the C++ Core Guidelines checkers](/cpp/code-quality/using-the-cpp-core-guidelines-checkers) (Использование средств проверки на соответствие рекомендациям C++ Core).

![CppCoreCheck](media/CppCoreCheck.png "Страница свойств CppCoreCheck")

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- поддержка правил, связанных с управлением ресурсов.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- Новые проверки C++ Core Guidelines проверяют корректность интеллектуальных указателей, правильность использования глобальных инициализаторов и применение флагов конструкций, таких как **`goto`** и неправильные приведения.

- Некоторые номера предупреждений, которые можно встретить в версии 15.3, больше не доступны в версии 15.5. Эти предупреждения были заменены более конкретными проверками.

##### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- Добавлена поддержка анализа одиночного файла, а также улучшения в анализе производительности времени выполнения. Дополнительные сведения см. в статье [C++ Static Analysis Improvements for Visual Studio 2017 15.6 Preview 2](https://devblogs.microsoft.com/cppblog/c-static-analysis-improvements-for-visual-studio-2017-15-6-preview-2/) (Усовершенствования статического анализа C++ в Visual Studio 2017 15.6 Preview 2)

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Добавлена поддержка параметра [`/analyze:ruleset`](../build/reference/analyze-code-analysis.md), чтобы вы могли указать, какие нужно применять правила анализа кода.
- Добавлена поддержка дополнительных правил C++ Core Guidelines.  Дополнительные сведения см. в статье [Using the C++ Core Guidelines checkers](/cpp/code-quality/using-the-cpp-core-guidelines-checkers) (Использование средств проверки на соответствие рекомендациям C++ Core).

## <a name="unit-testing-in-visual-studio-2017"></a>Модульное тестирование в Visual Studio 2017

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Адаптеры для Google Test и Boost.Test теперь доступны как компоненты рабочей нагрузки **Разработка классических приложений на C++** . Они интегрированы с **обозревателем тестов**. Добавлена поддержка CTest для проектов CMake (с использованием функции "Открыть папку"), хотя полная интеграция с **обозревателем тестов** еще не доступна. Дополнительные сведения см. в разделе [Создание модульных тестов для C/C++](/visualstudio/test/writing-unit-tests-for-c-cpp).

##### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- Добавлена поддержка динамической библиотеки `Boost.Test`.
- В интегрированной среде разработки теперь доступен шаблон элемента `Boost.Test`.

Дополнительные сведения см. в статье [`Boost.Test` Unit Testing: Dynamic Library support and New Item Template](https://devblogs.microsoft.com/cppblog/boost-test-unit-testing-dynamic-library-support-and-new-item-template/) (Модульное тестирование Boost.Test: поддержка динамических библиотек и новый шаблон элемента).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

Добавлена поддержка [CodeLens](/visualstudio/ide/find-code-changes-and-other-history-with-codelens) для проектов модульного тестирования C++. Дополнительные сведения см. в записи блога [Announcing CodeLens for C++ Unit Testing](https://devblogs.microsoft.com/cppblog/announcing-codelens-for-c-unit-testing/) (Объявлена поддержка CodeLens для модульного тестирования C++).

## <a name="visual-studio-graphics-diagnostics"></a>Диагностика графики в Visual Studio

Инструменты для диагностики графики в Visual Studio можно использовать для записи и анализа проблем с рендерингом и производительностью в приложениях Direct3D. Используйте их для приложений, которые выполняются локально на компьютере под управлением Windows, в эмуляторе устройства Windows или на удаленном ПК или устройстве.

- **Ввод и вывод для шейдеров вершин и геометрии.** Возможность просмотра входных и выходных данных вершинных шейдеров и геометрических шейдеров была одной из наиболее часто запрашиваемых функций. Теперь она поддерживается в инструментах. Выберите этап вершинных или геометрических шейдеров в представлении "Этапы конвейера", чтобы запустить проверку входных и выходных данных, перечисленных в таблице ниже.

  ![Входные и выходные данные для шейдеров](media/io-shaders.png)

- **Поиск и фильтрация в таблице объектов.** Теперь доступен простой и быстрый поиск нужных ресурсов.

  ![Поиск](media/search.png)

- **Журнал ресурсов.** Новое упрощенное представление всей истории изменений ресурса по мере его использования в ходе отрисовки захваченного кадра. Чтобы открыть журнал для любого ресурса, щелкните значок часов рядом с гиперссылкой на ресурс.

  ![Журнал ресурсов](media/resource-history.png)

  Откроется новое окно инструментов **Журнал ресурсов**, в котором заполнены данные об изменении ресурса.

  ![Изменение журнала ресурсов](media/resource-history-change.png)

  Вы можете записать кадры при включенной записи полного стека вызовов. Это позволяет быстро определить контекст каждого события изменения и проверить его в проекте Visual Studio. Установите параметр записи полного стека в Visual Studio в разделе **Диагностика графики** диалогового окна **Средства > Параметры**.

- **Статистика API.** Обобщенная сводка по использованию API в вашем кадре. Это удобно для обнаружения вызовов, выполнение которых вы можете не замечать, или вызовов, которые выполняются слишком часто. Это окно можно открыть в анализаторе графики Visual Studio, выбрав **Вид > Статистика использования API**.

  ![Статистика использования API](media/api-stats.png)

- **Статистика памяти.** Просмотр объема памяти, выделяемого драйвером для создаваемых ресурсов в кадре. Это окно можно открыть в **анализаторе графики Visual Studio**, выбрав **Вид > Статистика использования памяти**. Чтобы скопировать данные в CSV-файл для просмотра в электронной таблице, щелкните правой кнопкой мыши и выберите **Копировать все**.

  ![Статистика использования памяти](media/memory-stats.png)

- **Проверка кадров.** Новый список ошибок и предупреждений позволяет легко просматривать события, где обнаружены потенциальные проблемы на уровне отладки Direct3D. Чтобы открыть окно, в анализаторе графики Visual Studio выберите **Вид > Проверка кадра**. Затем щелкните **Выполнить проверку**, чтобы начать анализ. В зависимости от сложности кадра процесс может занять несколько минут.

  ![Проверка кадра](media/frame-validation.png)

- **Анализ кадров для D3D12.** Используйте анализ кадров для оценки работы вызовов рисования с помощью контролируемых экспериментов. Перейдите на вкладку "Анализ кадров", чтобы просмотреть отчет. Дополнительные сведения см. в видеоролике [GoingNative 25: Visual Studio Graphics Frame Analysis](https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-25-Offline-Analysis-Graphics-Tool), посвященном анализу кадров графики Visual Studio.

  ![Анализ кадров](media/frame-analysis.png)

- **Усовершенствованный анализ использования GPU.** Открытые трассировки можно передать через профилировщик использования GPU в Visual Studio, используя представление GPU или инструмент Windows Performance Analyzer (WPA) для более подробного анализа. Если у вас установлен набор Windows Performance Toolkit, в правом нижнем углу экрана с общими сведениями о сеансе вы увидите две гиперссылки: одна для WPA, а другая — для режима GPU.

  ![Использование GPU](media/gpu-usage.png)

  Трассировки, открываемые в режиме GPU с помощью этой ссылки, поддерживают синхронизированное масштабирование и панорамирование временной шкалы в режимах VS и GPU. С помощью флажка в VS можно включать и отключать синхронизацию.

  ![Режим GPU](media/gpu-view.png)

::: moniker-end

::: moniker range="=vs-2015"

Полный список обновлений вплоть до версии Visual Studio 2015 с обновлением 3 см. в разделе [Visual C++ What's New 2003 through 2015](/cpp/porting/visual-cpp-what-s-new-2003-through-2015) (Новые возможности Visual C++ 2003–2015).

Дополнительные сведения о новых возможностях в Visual Studio 2015 см. в заметках о выпуске. На них приведена ссылка в [заметках о выпуске Visual Studio 2015](/visualstudio/releasenotes/vs2015-version-history).

Сведения о новых возможностях для C++ в Visual Studio 2019 см. в статье [What's New for C++ in Visual Studio](/cpp/overview/what-s-new-for-visual-cpp-in-visual-studio?view=vs-2019) (Новые возможности для C++ в Visual Studio).

Сведения о новых возможностях для C++ в Visual Studio 2017 см. в статье [What's New for C++ in Visual Studio 2017](/cpp/overview/what-s-new-for-visual-cpp-in-visual-studio?view=vs-2017) (Новые возможности для C++ в Visual Studio 2017).

::: moniker-end
