---
title: Класс Ккоменумимпл
ms.date: 11/04/2016
f1_keywords:
- CComEnumImpl
- ATLCOM/ATL::CComEnumImpl
- ATLCOM/ATL::CComEnumImpl::CComEnumImpl
- ATLCOM/ATL::CComEnumImpl::Clone
- ATLCOM/ATL::CComEnumImpl::Init
- ATLCOM/ATL::CComEnumImpl::Next
- ATLCOM/ATL::CComEnumImpl::Reset
- ATLCOM/ATL::CComEnumImpl::Skip
- ATLCOM/ATL::CComEnumImpl::m_begin
- ATLCOM/ATL::CComEnumImpl::m_dwFlags
- ATLCOM/ATL::CComEnumImpl::m_end
- ATLCOM/ATL::CComEnumImpl::m_iter
- ATLCOM/ATL::CComEnumImpl::m_spUnk
helpviewer_keywords:
- CComEnumImpl class
ms.assetid: cc0d8e76-e608-46db-87cd-4c7161fe32d2
ms.openlocfilehash: 517a4e90ca21e22dcf161aefcff61a40437eabe0
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87226611"
---
# <a name="ccomenumimpl-class"></a>Класс Ккоменумимпл

Этот класс предоставляет реализацию для интерфейса перечислителя COM, в котором перечисляемые элементы хранятся в массиве.

## <a name="syntax"></a>Синтаксис

```
template <class Base,
    const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
```

#### <a name="parameters"></a>Параметры

*Из*<br/>
Интерфейс перечислителя COM. Пример см. в разделе [иенумстринг](/windows/win32/api/objidl/nn-objidl-ienumstring) .

*пиид*<br/>
Указатель на идентификатор интерфейса интерфейса перечислителя.

*T*<br/>
Тип элемента, предоставляемого интерфейсом перечислителя.

*Копировать*<br/>
Однородный [класс политики копирования](../../atl/atl-copy-policy-classes.md).

## <a name="members"></a>Элементы

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание:|
|----------|-----------------|
|[Ккоменумимпл:: Ккоменумимпл](#ccomenumimpl)|Конструктор.|
|[Ккоменумимпл:: ~ Ккоменумимпл](#dtor)|Деструктор|

### <a name="public-methods"></a>Открытые методы

|name|Описание:|
|----------|-----------------|
|[Ккоменумимпл:: Clone](#clone)|Реализация метода интерфейса перечисления **клонов** .|
|[Ккоменумимпл:: init](#init)|Инициализирует перечислитель.|
|[Ккоменумимпл:: Next](#next)|Реализация **Next**.|
|[Ккоменумимпл:: Reset](#reset)|Реализация метода **Reset**.|
|[Ккоменумимпл:: Skip](#skip)|Реализация метода **Skip**.|

### <a name="public-data-members"></a>Открытые члены данных

|Имя|Описание:|
|----------|-----------------|
|[Ккоменумимпл:: m_begin](#m_begin)|Указатель на первый элемент в массиве.|
|[Ккоменумимпл:: m_dwFlags](#m_dwflags)|Копирование флагов, переданных через `Init` .|
|[Ккоменумимпл:: m_end](#m_end)|Указатель на расположение непосредственно за последним элементом в массиве.|
|[Ккоменумимпл:: m_iter](#m_iter)|Указатель на текущий элемент в массиве.|
|[Ккоменумимпл:: m_spUnk](#m_spunk)|`IUnknown`Указатель объекта, который предоставляет перечисление коллекции.|

## <a name="remarks"></a>Remarks

Пример реализации метода см. в разделе [иенумстринг](/windows/win32/api/objidl/nn-objidl-ienumstring) . `CComEnumImpl`предоставляет реализацию для интерфейса перечислителя COM, в котором перечисляемые элементы хранятся в массиве. Этот класс аналогичен `IEnumOnSTLImpl` классу, который предоставляет реализацию интерфейса перечислителя на основе контейнера стандартной библиотеки C++.

> [!NOTE]
> Дополнительные сведения о дальнейших различиях между `CComEnumImpl` и `IEnumOnSTLImpl` см. в разделе [Ккоменумимпл:: init](#init).

Как правило, *не* требуется создавать собственный класс перечислителя, производный от реализации этого интерфейса. Если вы хотите использовать перечислитель, предоставляемый библиотекой ATL, на основе массива, чаще всего создается экземпляр [ккоменум](../../atl/reference/ccomenum-class.md).

Однако, если необходимо предоставить пользовательский перечислитель (например, интерфейс, предоставляющий интерфейсы в дополнение к интерфейсу перечислителя), можно создать производный от этого класса. В этом случае, скорее всего, потребуется переопределить метод [ккоменумимпл:: Clone](#clone) , чтобы обеспечить собственную реализацию.

Дополнительные сведения см. в разделе [коллекции и перечислители ATL](../../atl/atl-collections-and-enumerators.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`Base`

`CComEnumImpl`

## <a name="requirements"></a>Требования

**Заголовок:** атлком. h

## <a name="ccomenumimplccomenumimpl"></a><a name="ccomenumimpl"></a>Ккоменумимпл:: Ккоменумимпл

Конструктор.

```
CComEnumImpl();
```

## <a name="ccomenumimplccomenumimpl"></a><a name="dtor"></a>Ккоменумимпл:: ~ Ккоменумимпл

Деструктор

```
~CComEnumImpl();
```

## <a name="ccomenumimplinit"></a><a name="init"></a>Ккоменумимпл:: init

Этот метод необходимо вызывать перед передачей указателя на интерфейс перечислителя обратно клиентам.

```
HRESULT Init(
    T* begin,
    T* end,
    IUnknown* pUnk,
    CComEnumFlags flags = AtlFlagNoCopy);
```

### <a name="parameters"></a>Параметры

*начале*<br/>
Указатель на первый элемент массива, содержащий элементы для перечисления.

*конце*<br/>
Указатель на расположение сразу за последним элементом массива, содержащего элементы для перечисления.

*pUnk*<br/>
окне `IUnknown`Указатель объекта, который должен храниться в активном состоянии в течение времени существования перечислителя. Если такой объект не существует, передается значение NULL.

*flags*<br/>
Флаги, указывающие, должен ли перечислитель перестать владельцем массива или создать его копию. Возможные значения описаны ниже.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Remarks

Вызывайте этот метод только один раз — инициализируйте перечислитель, используйте его, а затем отбрасывает.

Если передаются указатели на элементы массива, хранящегося в другом объекте (и вы не запрашиваете перечислитель для копирования данных), можно использовать параметр *Punk* , чтобы убедиться, что объект и содержащийся в нем массив доступны, пока они необходимы перечислителю. Перечислитель просто содержит ссылку COM на объект, чтобы поддерживать его в активном состоянии. Ссылка COM автоматически освобождается при уничтожении перечислителя.

Параметр *flags* позволяет указать, каким образом перечислитель должен обрабатывать переданные ему элементы массива. *Флаги* могут принимать одно из значений перечисления, как `CComEnumFlags` показано ниже.

```
enum CComEnumFlags
   {
   AtlFlagNoCopy = 0,
   AtlFlagTakeOwnership = 2, // BitOwn
   AtlFlagCopy = 3           // BitOwn | BitCopy
   };
```

`AtlFlagNoCopy`означает, что время существования массива не контролируется перечислителем. В этом случае либо массив будет статическим, либо объект, идентифицируемый *Punk* , будет отвечать за освобождение массива, когда он больше не нужен.

`AtlFlagTakeOwnership`означает, что уничтожение массива должно контролироваться перечислителем. В этом случае массив должен быть динамически выделен с помощью **`new`** . Перечислитель удалит массив в его деструкторе. Как правило, значение NULL передается для *Punk*, хотя можно передать допустимый указатель, если необходимо получать уведомления об уничтожении перечислителя по какой-либо причине.

`AtlFlagCopy`означает, что новый массив создается путем копирования массива, переданного в `Init` . Время существования нового массива должно контролироваться перечислителем. Перечислитель удалит массив в его деструкторе. Как правило, значение NULL передается для *Punk*, хотя можно передать допустимый указатель, если необходимо получать уведомления об уничтожении перечислителя по какой-либо причине.

> [!NOTE]
> Прототип этого метода задает элементы массива как тип `T` , где `T` был определен как параметр шаблона для класса. Это тот же тип, который предоставляется посредством метода COM-интерфейса [ккоменумимпл:: Next](#next). Следствием этого является то, что, в отличие от [иенумонстлимпл](../../atl/reference/ienumonstlimpl-class.md), этот класс не поддерживает различные хранилища и типы данных. Тип данных элементов в массиве должен совпадать с типом данных, предоставляемым средствами COM-интерфейса.

## <a name="ccomenumimplclone"></a><a name="clone"></a>Ккоменумимпл:: Clone

Этот метод обеспечивает реализацию метода **clone** , создавая объект типа `CComEnum` , инициализируя его с тем же массивом и итератором, который используется текущим объектом, и возвращая интерфейс для только что созданного объекта.

```
STDMETHOD(Clone)(Base** ppEnum);
```

### <a name="parameters"></a>Параметры

*ппенум*<br/>
заполняет Интерфейс перечислителя для вновь созданного объекта, клонированного из текущего перечислителя.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Remarks

Обратите внимание, что клонированные перечислители никогда не делают собственную копию данных, используемых исходным перечислителем (или стать владельцем). При необходимости клонированные перечислители сохраняют исходный перечислитель в активном состоянии (используя ссылку COM), чтобы обеспечить доступность данных до тех пор, пока они им нужны.

## <a name="ccomenumimplm_spunk"></a><a name="m_spunk"></a>Ккоменумимпл:: m_spUnk

Этот смарт-указатель поддерживает ссылку на объект, передаваемый в [ккоменумимпл:: init](#init), гарантируя, что он остается в активном состоянии в течение времени существования перечислителя.

```
CComPtr<IUnknown> m_spUnk;
```

## <a name="ccomenumimplm_begin"></a><a name="m_begin"></a>Ккоменумимпл:: m_begin

Указатель на расположение сразу за последним элементом массива, содержащего элементы для перечисления.

```
T* m_begin;
```

## <a name="ccomenumimplm_end"></a><a name="m_end"></a>Ккоменумимпл:: m_end

Указатель на первый элемент массива, содержащий элементы для перечисления.

```
T* m_end;
```

## <a name="ccomenumimplm_iter"></a><a name="m_iter"></a>Ккоменумимпл:: m_iter

Указатель на текущий элемент массива, содержащий элементы для перечисления.

```
T* m_iter;
```

## <a name="ccomenumimplm_dwflags"></a><a name="m_dwflags"></a>Ккоменумимпл:: m_dwFlags

Флаги, передаваемые в [ккоменумимпл:: init](#init).

```
DWORD m_dwFlags;
```

## <a name="ccomenumimplnext"></a><a name="next"></a>Ккоменумимпл:: Next

Этот метод предоставляет реализацию **следующего** метода.

```
STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
```

### <a name="parameters"></a>Параметры

*celt*<br/>
окне Количество запрошенных элементов.

*rgelt*<br/>
заполняет Массив, который должен быть заполнен элементами.

*pceltFetched*<br/>
заполняет Число элементов, фактически возвращаемых в *rgelt*. Это значение может быть меньше, чем значение *celt* , если в списке осталось менее *celt* элементов.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

## <a name="ccomenumimplreset"></a><a name="reset"></a>Ккоменумимпл:: Reset

Этот метод обеспечивает реализацию метода **Reset** .

```
STDMETHOD(Reset)(void);
```

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

## <a name="ccomenumimplskip"></a><a name="skip"></a>Ккоменумимпл:: Skip

Этот метод предоставляет реализацию метода **Skip** .

```
STDMETHOD(Skip)(ULONG celt);
```

### <a name="parameters"></a>Параметры

*celt*<br/>
окне Число пропускаемых элементов.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Remarks

Возвращает значение, E_INVALIDARG если значение *celt* равно нулю, функция возвращает значение, равное S_FALSE, если *возвращается меньшее число элементов* , а возвращает S_OK иначе.

## <a name="see-also"></a>См. также статью

[Класс Иенумонстлимпл](../../atl/reference/ienumonstlimpl-class.md)<br/>
[Класс Ккоменум](../../atl/reference/ccomenum-class.md)<br/>
[Общие сведения о классах](../../atl/atl-class-overview.md)
