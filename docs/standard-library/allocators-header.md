---
title: '&lt;Распределители&gt;'
ms.date: 11/04/2016
f1_keywords:
- <allocators>
helpviewer_keywords:
- allocators header
ms.assetid: 4393a607-4df8-4278-bbb2-c8ec52e60b83
ms.openlocfilehash: f981b86ed8f5d3b240d9f02380a603eb4f2605bc
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84623580"
---
# <a name="ltallocatorsgt"></a>&lt;Распределители&gt;

Определяются несколько шаблонов, упрощающих выделение и освобождение блоков памяти для контейнеров на основе узлов.

## <a name="syntax"></a>Синтаксис

```cpp
#include <allocators>
```

> [!NOTE]
> \<allocators>является устаревшим, начиная с Visual Studio 2019 версии 16,3.

## <a name="remarks"></a>Комментарии

\<allocators>Заголовок предоставляет шесть шаблонов распределителя, которые можно использовать для выбора стратегий управления памятью для контейнеров на основе узлов. Для использования с этими шаблонами он также предоставляет несколько разных фильтров синхронизации, позволяющих настроить стратегию управления памятью во множестве разных многопоточных схем (включая отсутствие). Вы можете ускорить работу приложения или уменьшить его требования к памяти, сопоставляя стратегию управления памятью с шаблонами использования памяти и требованиями к синхронизации.

Шаблоны распределителя реализуются с многократно используемыми компонентами, которые можно настраивать или заменять, чтобы обеспечить дополнительные стратегии управления памятью.

Контейнеры на основе узлов в стандартной библиотеке C++ (std:: List, std:: Set, std:: Мультинабор, std:: Map и std:: multimap) хранят свои элементы в отдельных узлах. Все узлы для конкретного типа контейнера имеют одинаковый размер, поэтому не требуется гибкость диспетчера памяти общего назначения. Так как размер каждого блока памяти становится известен во время компиляции, диспетчер памяти может быть гораздо проще и быстрее.

При использовании с контейнерами, которые не основаны на узлах (например, в контейнерах стандартной библиотеки C++ std:: Vector std::d екуе и std:: basic_string), шаблоны распределителя будут работать правильно, но, скорее всего, не будет предоставлять повышение производительности по умолчанию для распределителя.

Распределитель — это шаблон класса, описывающий объект, который управляет выделением и освобождением памяти для объектов и массивов объектов определенного типа. Объекты распределителя используются несколькими шаблонами классов контейнеров в стандартной библиотеке C++.

Распределители представляют собой шаблоны типа

```cpp
template<class Type>
class allocator;
```

где аргумент шаблона `Type` — это тип, управляемый экземпляром распределителя. Стандартная библиотека C++ предоставляет распределитель по умолчанию, [распределителя](allocator-class.md)шаблонов классов, который определен в [\<memory>](memory.md) . \<allocators>Заголовок предоставляет следующие распределителя:

- [allocator_newdel](allocator-newdel-class.md)

- [allocator_unbounded](allocator-unbounded-class.md)

- [allocator_fixed_size](allocator-fixed-size-class.md)

- [allocator_variable_size](allocator-variable-size-class.md)

- [allocator_suballoc](allocator-suballoc-class.md)

- [allocator_chunklist](allocator-chunklist-class.md)

При создании контейнера используйте соответствующий экземпляр распределителя как второй аргумент типа, как показано в следующем примере кода.

```cpp
#include <list>
#include <allocators>
std::list<int, stdext::allocators::allocator_chunklist<int> > _List0;
```

_List0 выделяет узлы с `allocator_chunklist` и фильтром синхронизации по умолчанию.

Используйте макрос [ALLOCATOR_DECL](allocators-functions.md#allocator_decl) для создания шаблонов распределителя с фильтрами синхронизации, отличными от установленных по умолчанию:

```cpp
#include <list>
#include <allocators>
ALLOCATOR_DECL(CACHE_CHUNKLIST, stdext::allocators::sync_per_thread, Alloc);
std::list<int, alloc<int> > _List1;
```

_Lst1 выделяет узлы с `allocator_chunklist` и фильтр синхронизации [sync_per_thread](sync-per-thread-class.md).

Распределитель блоков — это кэш или фильтр. Кэш — это шаблон класса, принимающий один аргумент типа std:: size_t. Он определяет распределитель блоков, который выделяет и освобождает блоки памяти одного размера. Он должен получить память с помощью оператора **New**, но не должен создавать отдельный вызов оператора **New** для каждого блока. Он может, например, дополнительно выделить память из блока большего размера или кэша освобожденных блоков для последующего перераспределения.

С помощью компилятора, который не может повторно привязать значение аргумента std:: size_t, используемого при создании экземпляра шаблона, не обязательно является значением аргумента, _Sz передается в функции-члены кэша для выделения и освобождения.

\<allocators>предоставляет следующие шаблоны кэша:

- [cache_freelist](cache-freelist-class.md)

- [cache_suballoc](cache-suballoc-class.md)

- [cache_chunklist](cache-chunklist-class.md)

Фильтр — это распределитель блоков, реализующий свои функции-члены с помощью другого распределителя блоков, который передается в него как аргумент шаблона. Наиболее распространенная форма фильтра — это фильтр синхронизации, который применяет политику синхронизации для управления доступом к функциям-членам экземпляра другого распределителя блоков. \<allocators>предоставляет следующие фильтры синхронизации:

- [sync_none](sync-none-class.md)

- [sync_per_container](sync-per-container-class.md)

- [sync_per_thread](sync-per-thread-class.md)

- [sync_shared](sync-shared-class.md)

\<allocators>также предоставляет фильтр [rts_alloc](rts-alloc-class.md), который содержит несколько экземпляров распределителя блоков и определяет, какой экземпляр следует использовать для выделения или освобождения в среде выполнения, а не во время компиляции. Он используется с компиляторами, которые не могут скомпилировать повторную привязку.

Политика синхронизации определяет, как экземпляр распределителя обрабатывает одновременные запросы на выделение и освобождение из нескольких потоков. Самая простая политика заключается в том, что все запросы передаются напрямую в базовый объект кэша, оставляя управление синхронизацией пользователю. Более сложная политика может заключаться в использовании мьютекса для сериализации доступа к базовому объекту кэша.

Если компилятор поддерживает компиляцию как однопоточных, так и многопоточных приложений, фильтр синхронизации по умолчанию для однопоточных приложений — `sync_none`; для всех остальных случаев — это `sync_shared`.

Шаблон кэша `cache_freelist` принимает аргумент Max Class, который определяет максимальное количество элементов, сохраняемых в свободном списке.

\<allocators>предоставляет следующие классы Max:

- [max_none](max-none-class.md)

- [max_unbounded](max-unbounded-class.md)

- [max_fixed_size](max-fixed-size-class.md)

- [max_variable_size](max-variable-size-class.md)

### <a name="macros"></a>Макросы

|Макрос|Описание|
|-|-|
|[ALLOCATOR_DECL](allocators-functions.md#allocator_decl)|Возвращает шаблон класса распределителя.|
|[CACHE_CHUNKLIST](allocators-functions.md#cache_chunklist)|Создает `stdext::allocators::cache_chunklist<sizeof(Type)>`.|
|[CACHE_FREELIST](allocators-functions.md#cache_freelist)|Создает `stdext::allocators::cache_freelist<sizeof(Type), max>`.|
|[CACHE_SUBALLOC](allocators-functions.md#cache_suballoc)|Создает `stdext::allocators::cache_suballoc<sizeof(Type)>`.|
|[SYNC_DEFAULT](allocators-functions.md#sync_default)|Создает фильтр синхронизации.|

### <a name="operators"></a>Операторы

|Оператор|Описание|
|-|-|
|[operator! = ( \<allocators> )](allocators-operators.md#op_neq)|Проверяет на неравенство между объектами распределителя указанного класса.|
|[оператор = = ( \<allocators> )](allocators-operators.md#op_eq_eq)|Проверяет на равенство объекты распределителя указанного класса.|

### <a name="classes"></a>Классы

|Класс|Описание|
|-|-|
|[allocator_base](allocator-base-class.md)|Определяет базовый класс и общие функции, необходимые для создания определяемого пользователем распределителя из фильтра синхронизации.|
|[allocator_chunklist](allocator-chunklist-class.md)|Описывает объект, который управляет выделением и освобождением памяти для объектов, использующих кэш типа [cache_chunklist](cache-chunklist-class.md).|
|[allocator_fixed_size](allocator-fixed-size-class.md)|Описывает объект, который управляет выделением и освобождением памяти для объектов типа `Type`, использующих кэш типа [cache_freelist](cache-freelist-class.md) с длиной, управляемой классом [max_fixed_size](max-fixed-size-class.md).|
|[allocator_newdel](allocator-newdel-class.md)|Реализует распределитель, использующий **оператор DELETE** для освобождения блока памяти и **оператора New** для выделения блока памяти.|
|[allocator_suballoc](allocator-suballoc-class.md)|Описывает объект, который управляет выделением и освобождением памяти для объектов типа `Type`, использующих кэш типа [cache_suballoc](cache-suballoc-class.md).|
|[allocator_unbounded](allocator-unbounded-class.md)|Описывает объект, который управляет выделением и освобождением памяти для объектов типа `Type`, использующих кэш типа [cache_freelist](cache-freelist-class.md) с длиной, управляемой классом [max_unbounded](max-unbounded-class.md).|
|[allocator_variable_size](allocator-variable-size-class.md)|Описывает объект, который управляет выделением и освобождением памяти для объектов типа `Type`, использующих кэш типа [cache_freelist](cache-freelist-class.md) с длиной, управляемой классом [max_variable_size](max-variable-size-class.md).|
|[cache_chunklist](cache-chunklist-class.md)|Задает распределитель блоков, который выделяет и освобождает блоки памяти одного размера.|
|[cache_freelist](cache-freelist-class.md)|Задает распределитель блоков, который выделяет и освобождает блоки памяти одного размера.|
|[cache_suballoc](cache-suballoc-class.md)|Задает распределитель блоков, который выделяет и освобождает блоки памяти одного размера.|
|[freelist](freelist-class.md)|Управляет списком блоков памяти.|
|[max_fixed_size](max-fixed-size-class.md)|Описывает объект max class, который ограничивает максимальную длину объекта [freelist](freelist-class.md) определенным значением.|
|[max_none](max-none-class.md)|Описывает объект max class, который ограничивает максимальную длину объекта [freelist](freelist-class.md) нулем.|
|[max_unbounded](max-unbounded-class.md)|Описывает объект max class, который не ограничивает максимальную длину объекта [freelist](freelist-class.md).|
|[max_variable_size](max-variable-size-class.md)|Описывает объект max class, который ограничивает максимальную длину объекта [freelist](freelist-class.md) до значения, приблизительно пропорционального количеству выделенных блоков памяти.|
|[rts_alloc](rts-alloc-class.md)|Шаблон класса rts_alloc описывает [Фильтр](allocators-header.md) , содержащий массив экземпляров кэша, и определяет, какой экземпляр следует использовать для выделения и освобождения во время выполнения, а не во времени компиляции.|
|[sync_none](sync-none-class.md)|Описывает фильтр синхронизации, который не предоставляет синхронизацию.|
|[sync_per_container](sync-per-container-class.md)|Описывает фильтр синхронизации, предоставляющий отдельный объект кэша для каждого объекта распределителя.|
|[sync_per_thread](sync-per-thread-class.md)|Описывает фильтр синхронизации, предоставляющий отдельный объект кэша для каждого потока.|
|[sync_shared](sync-shared-class.md)|Описывает фильтр синхронизации, использующий мьютекс для управления доступом к объекту кэша, который является общим для всех распределителей.|

## <a name="requirements"></a>Требования

**Заголовок:**\<allocators>

**Пространство имен:** stdext

## <a name="see-also"></a>См. также раздел

[Справочник по файлам заголовков](cpp-standard-library-header-files.md)
