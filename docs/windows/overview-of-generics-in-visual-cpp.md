---
title: Обзор универсальных типов в Visual C++ | Документы Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-windows
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- generics [C++], about generics
- default initializers [C++]
- type parameters [C++]
- constructed types
- type arguments [C++]
- constructed types, open [C++]
- open constructed types [C++]
- constructed types, closed [C++]
ms.assetid: 21f10637-0fce-4916-b925-6c86a126d3aa
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
- uwp
ms.openlocfilehash: 19200e3c3c4ed67960905b697187dbb6b37a65e9
ms.sourcegitcommit: d55ac596ba8f908f5d91d228dc070dad31cb8360
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2018
---
# <a name="overview-of-generics-in-visual-c"></a>Обзор универсальных типов в Visual C++
Универсальные шаблоны — это параметризованные типы, поддерживаемые средой CLR. Параметризованный тип — это тип, определяемый неизвестным параметром типа, который задается при использовании универсального шаблона.  
  
## <a name="why-generics"></a>Преимущества универсальных шаблонов  
 C++ поддерживает обычные шаблоны, которые наряду с универсальными поддерживают параметризованные типы для создания классов типизированных коллекций. Однако обычные шаблоны предусматривают параметризацию во время компиляции. Нельзя ссылаться на сборку, содержащую определение шаблона, и создавать его новые специализации. После компиляции специализированный шаблон выглядит подобно любому другому классу или методу. В отличие от обычных, универсальные шаблоны создаются в MSIL в виде параметризованного типа, известного среде выполнения как параметризованный тип; исходный код, ссылающийся на сборку, которая содержит универсальный тип, может создавать специализации этого универсального типа. Дополнительные сведения о сравнении шаблонов Visual C++ и универсальными шаблонами языка в разделе [шаблонами и универсальными шаблонами (Visual C++)](../windows/generics-and-templates-visual-cpp.md).  
  
## <a name="generic-functions-and-types"></a>Универсальные функции и типы  
 Типы классов могут быть универсальными, пока являются управляемыми. Примером может служить класс `List`. Типом объекта в этом списке является параметр типа. Если требуется `List` класс для различных типов объектов, то до универсальных шаблонов можно использовать `List` , который принимает **System::Object** как тип элемента. Однако при этом в списке могут использоваться любые объекты (в том числе неверного типа). Такой список называется классом нетипизированных коллекций. В лучшем случае можно проверять тип во время выполнения и создавать исключение. Можно также использовать шаблон, который при компиляции в сборку будет терять свою универсальность. Пользователи вашей сборки не смогут создавать собственные специализации шаблона. Универсальные шаблоны позволяют создавать классы типизированных коллекций, например `List<int>` (читается как «Список типа int») и `List<double>` («список типа double») которого вызовет ошибку компиляции, при попытке поместить тип, коллекция была не в предназначенную типизированный Коллекция. Кроме того, после компиляции этих типов они остаются универсальными.  
  
 Описание синтаксиса универсальных классов, которые можно найти в [универсальные классы (C + +/ CLI)](../windows/generic-classes-cpp-cli.md) `.` новое пространство имен <xref:System.Collections.Generic>, предоставляет набор типов параметризованные коллекций, включая <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.Generic.List%601>и <xref:System.Collections.Generic.LinkedList%601>.  
  
 Экземплярные и статические функции членов классов, делегаты и глобальные функции также могут быть универсальными. Универсальные функции могут потребоваться, если тип параметров функции неизвестен или сама функция должна работать с универсальными типами. Во многих случаях где **System::Object** использовался ранее в качестве параметра для неизвестного типа объекта, параметр универсального типа может использоваться вместо, что обеспечит более типобезопасный код. Любая попытка передать тип, который функция не поддерживает, во время компиляции отмечается как ошибка. С помощью **System::Object** как параметр функции случайная передача объекта, функция не была предусмотрена не будут обнаружены, и необходимо будет выполнить приведение неизвестного типа объекта к определенному типу в тело функции и учетная запись для возможность появления исключения InvalidCastException. При наличии универсального шаблона код, пытаясь передать объект в функцию, вызывает конфликт типов и поэтому тело функции будет гарантированно содержать правильный тип.  
  
 Те же преимущества относятся к классам коллекций, созданным в универсальных шаблонах. Использовать классы коллекций в прошлом **System::Object** для хранения элементов в коллекции. Вставка объектов типа, для которого коллекция не предназначена, во время компиляции не отмечалась и часто не отмечалась даже после вставки объектов. Обычно объект приводится к другому типу после обращения к нему в коллекции. Неизвестный тип обнаруживается только при сбое приведения. Универсальные шаблоны решают эту проблему во время компиляции, обнаруживая любой код, в котором вставляется тип, не соответствующий параметру типа универсальной коллекции (или неявно преобразованный в него).  
  
 Описание синтаксиса см. в разделе [универсальные функции (C + +/ CLI)](../windows/generic-functions-cpp-cli.md).  
  
## <a name="terminology-used-with-generics"></a>Терминология, используемая с универсальными шаблонами  
  
##### <a name="type-parameters"></a>Параметры типа  
 Универсальное объявление содержит один или несколько неизвестных типов, называемых *параметры типа*. Имя параметра типа представляет тип в теле универсального объявления. Параметр типа в теле универсального объявления используется в качестве типа. Универсальное объявление списка List < T\> содержит параметр типа T.  
  
##### <a name="type-arguments"></a>Аргументы типа  
 *Аргумент типа* — это фактический тип, используемый вместо параметра типа, когда универсальный шаблон определен для конкретного типа или типов. Например, `int` — аргумент типа в `List<int>`. В качестве аргумента универсального типа разрешается использовать только типы значений и типы дескрипторов.  
  
##### <a name="constructed-type"></a>Сконструированный тип  
 Тип, построенный на основе универсального типа называется *сконструированный тип*. Не полностью заданный тип, такие как `List<T>` — *открытый сконструированный тип*; полностью заданный, таких как `List<double>,` — *закрытый сконструированный тип* или *специализированным типом* . Открытые сконструированные типы могут использоваться в определении других универсальных типов или методов и не могут быть полностью заданы до тех пор, пока не задан сам включающий универсальный шаблон. Например, ниже показано использование открытого сконструированного типа в качестве базового класса для универсального шаблона.  
  
 `// generics_overview.cpp`  
  
 `// compile with: /clr /c`  
  
 `generic <typename T>`  
  
 `ref class List {};`  
  
 `generic <typename T>`  
  
 `ref class Queue : public List<T> {};`  
  
##### <a name="constraint"></a>Ограничение  
 Под ограничением понимается ограничение для типов, которые могут использоваться в качестве параметра типа. Например, заданный универсальный класс может принимать только классы, производные от указанного класса или реализующие указанный интерфейс. Дополнительные сведения см. в разделе [ограничений для параметров универсального типа (C + +/ CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md).  
  
## <a name="reference-types-and-value-types"></a>Ссылочные типы и типы значений  
 В качестве аргументов типа могут использоваться типы дескрипторов и типы значений. В универсальном определении, в котором может использоваться любой тип, применяется синтаксис ссылочных типов. Например **->** оператор используется для доступа к членам типа параметра типа, ли используемый в конечном счете тип ссылочным типом или типом значения. Если в качестве аргумента типа применяется тип значения, среда выполнения создает код, в котором типы значений используются непосредственно, без упаковки-преобразования.  
  
 При использовании ссылочного типа в качестве аргумента универсального типа необходимо применять синтаксис дескриптора. При использовании типа значения в качестве аргумента универсального типа следует непосредственно указывать имя типа.  
  
 `// generics_overview_2.cpp`  
  
 `// compile with: /clr`  
  
 `generic <typename T>`  
  
 `ref class GenericType {};`  
  
 `ref class ReferenceType {};`  
  
 `value struct ValueType {};`  
  
 `int main() {`  
  
 `GenericType<ReferenceType^> x;`  
  
 `GenericType<ValueType> y;`  
  
 `}`  
  
## <a name="type-parameters"></a>Параметры типа  
 Параметры типов в универсальном классе обрабатываются так же, как и другие идентификаторы. Однако поскольку тип неизвестен, существуют ограничения по их использованию. Например, нельзя использовать члены и методы класса параметра типа, если неизвестно, поддерживает ли параметр типа эти члены. То есть для доступа к члену через параметр типа необходимо добавить тип, содержащий этот член, в список ограничений параметра типа.  
  
 `// generics_overview_3.cpp`  
  
 `// compile with: /clr`  
  
```  
interface class I {  
   void f1();  
   void f2();  
};  
  
ref struct R : public I {  
   virtual void f1() {}  
   virtual void f2() {}   
   virtual void f3() {}   
};  
  
generic <typename T>  
where T : I  
void f(T t) {  
   t->f1();  
   t->f2();  
   safe_cast<R^>(t)->f3();  
}  
  
int main() {  
   f(gcnew R());  
}  
```  
  
 Эти ограничения также относятся к операторам. В произвольном параметре универсального типа нельзя использовать операторы `==` и `!=` для сравнения двух экземпляров параметра типа, если тип не поддерживает эти операторы. Эти проверки необходимы для универсальных шаблонов, но не требуются для обычных шаблонов, поскольку универсальные шаблоны могут быть конкретизированы во время выполнения любым другим классом, удовлетворяющим ограничениям, когда слишком поздно проверять использование недопустимых членов.  
  
 Экземпляр по умолчанию параметра типа можно создать с помощью оператора `()`. Пример:  
  
 `T t = T();`  
  
 где `T` — параметр типа в определении универсального класса или метода; инициализирует переменную со значением по умолчанию. Если параметр `T` является ссылочным классом, он будет пустым указателем; если `T` — класс значения, объект инициализируется с нулевым значением. Это называется *по умолчанию инициализатора*.  
  
## <a name="see-also"></a>См. также  
 [Универсальные шаблоны](../windows/generics-cpp-component-extensions.md)