---
title: Обзор соглашений ARM64 ABI | Документация Майкрософт
ms.custom: ''
ms.date: 07/11/2018
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 49d67f9a2e91e3a2e0a2731e61fc0e1c2ec55679
ms.sourcegitcommit: 76fd30ff3e0352e2206460503b61f45897e60e4f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/13/2018
ms.locfileid: "39028544"
---
# <a name="overview-of-arm64-abi-conventions"></a>Обзор соглашений ARM64 ABI

Простого ABI для Windows при компиляции и выполнения на процессорах ARM в 64-разрядном режиме (ARMv8 или более поздней версии архитектур), в большинстве случаев следует стандартный AArch64 EABI в ARM. В этой статье описаны некоторые ключевые допущения и изменения от описанных в EABI. Сведения об интерфейсе ABI 32-разрядной, см. в разделе [соглашений ABI ARM Обзор](overview-of-arm-abi-conventions.md). Дополнительные сведения о стандартных ARM EABI, см. в разделе [двоичным интерфейсом приложений (ABI) для архитектуры ARM](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) (внешняя ссылка).

## <a name="definitions"></a>Определения

С появлением поддержка 64-разрядных ARM определено несколько терминов:

- **AArch32** — набора устаревших инструкций 32-разрядной архитектуре (ISA) определяется ARM, включая выполнение в режиме Thumb.
- **AArch64** — новый 64-разрядных инструкций задать архитектуры (ISA) определяется ARM.
- **ARMv7** — спецификация «7» поколения оборудования ARM, который будет включать только поддержка AArch32. Это версия оборудование ARM, поддерживается первой версии Windows для ARM.
- **ARMv8** — спецификация «8-го поколения» оборудование ARM, которое включает в себя поддержку AArch32 и AArch64.

Помимо этих определений в Windows используются следующие термины.

- **ARM** — ссылается на 32-разрядной архитектуры ARM (AArch32). Иногда это называется WoA (Windows на ARM).
- **ARM32** — то же, что ARM, выше; используются в этом документе для ясности.
- **ARM64** — ссылается на 64-разрядной архитектуры ARM (AArch64). Нет такого понятия, как WoA64.

Наконец при ссылке на типы данных, указываются следующие определения из ARM:

- **Короткий вектор** — это тип данных, который можно непосредственно представить в SIMD, т. е., это совокупность элементов, выровненным по его размер (8 или 16 байт), где каждый элемент может быть 1, 2, 4 или 8 байт, накопленные 8 или 16 байт
- **(Агрегатом однородных с плавающей запятой) HFA** — это тип данных со 2-4 идентичные плавающей точкой (значения с плавающей запятой или тип Double)
- **(Агрегатом однородных короткого вектора) HVA** — это тип данных с помощью одинаковых элементов короткого вектора 2 – 4

## <a name="base-requirements"></a>Основные требования

ARM64 версию Windows предполагает, что он работает под управлением ARMv8 или более поздней версии архитектуры в любое время. Оба с плавающей запятой и поддержки NEON считаются должны присутствовать в оборудовании.

Несмотря на то, что спецификация ARMv8 позволяет полную поддержку AArch32 приложений, в настоящее время не планируем поддерживать используете уже существующие ARM32 на версию ARM64 с Windows (т. е. мы не планируем WOW64). Это зависит от повторной оценки в будущем, но текущий рабочий предположить.

В спецификации ARMv8 описывает новый необязательный шифрования и коды операций вспомогательный CRC для AArch32 и AArch64. Поддержку этих сейчас необязательно, но рекомендуется. Код, желающих воспользоваться преимуществами эти коды операций должен выполнить проверки времени выполнения для их существования.

## <a name="endianness"></a>Порядок байтов

Как и при работе с ARM32 в прямом режиме выполняет версии Windows на Windows ARM64. Переключение порядка следования байтов сложно добиться без поддержки режима ядра в AArch64, чтобы упростить для принудительного применения.

## <a name="alignment"></a>Выравнивание

На ARM64 с Windows позволяет оборудованию ЦП прозрачно обрабатывать невыровненные обращения к. В улучшение из AArch32 эта поддержка теперь также работает все при обращении к целым (включая доступ нескольких слов), а также для доступа с плавающей запятой.

Тем не менее доступ к памяти без кэширования (устройство) по-прежнему должны всегда быть выровнены. Это означает, что если имеется код, который может быть вызван для чтения и записи невыровненных данных из памяти без кэширования, он должен использовать безопасный вещей и убедитесь, что все доступы к выровнены.

## <a name="integer-registers"></a>Целочисленные регистры

Архитектура AArch64 поддерживает 32 целочисленные регистры, представлены ниже:

|Регистровое|Переменный?|Роль|
|-|-|-|
x0|Переменный|Параметр/нуля зарегистрировать 1, результат регистрация
x1 x7|Переменный|Параметр/нуля register 2 – 8
x8 x15|Переменный|Регистры
x16 x17|Переменный|Регистры INTRA вызов процедуры
x18|Неизменяемый|Регистрация платформы: в режиме ядра, указывающий KPCR для текущего процессора; в пользовательском режиме указывает на TEB
x19 x28|Неизменяемый|Регистры
x29/fp|Неизменяемый|Указатель фрейма
x30/lr|Неизменяемый|Регистрирует ссылку

Каждого из регистров может осуществляться как значение 64-разрядных (через x0-x30) или как 32-разрядное значение (с помощью w0-w30). 32-разрядных операций ноль расширить свои результаты до 64 бит.

См. в разделе Передача разделе Дополнительные сведения об использовании регистров параметра параметров.

Обратите внимание, что в отличие от AArch32, ПК и хранимой Процедуры не индексированное регистры и таким образом ограничены в том, как можно получить доступ. Также Обратите внимание, что не x31 зарегистрировать его (, кодировка, используемая для особых целей).

Использование указателя кадра (x29) является обязательным для совместимости с ускорения проверки стека, используемые трассировки событий Windows и других служб. Оно должно указывать на предыдущем {x29, x 30} пары в стеке.

## <a name="floating-pointsimd-registers"></a>Регистры с плавающей запятой/SIMD

Архитектура AArch64 также поддерживает 32 регистров с плавающей точкой запятой/SIMD, представлены ниже:

Регистровое|Переменный?|Роль
|-|-|-|
V0|Переменный|Параметр/нуля зарегистрировать 1, результат регистрация
версии v1-7|Переменный|Параметр/нуля регистрирует 2 – 8
версия 15 v8|Неизменяемый|Scratch регистров (Обратите внимание, что долговременного только младшие 64 разряда)
v16 v31|Переменный|Регистры

Каждого из регистров может осуществляться как полное значение 128-разрядный (через v0 v31 или q0 q31), 64-разрядное значение (с помощью d0-d31), как 32-разрядное значение (с помощью s0-s31), как 16-разрядное значение (с помощью h0-h31), или как 8-разрядное значение (через b0-b31). Доступ, меньше, чем 128 бит, доступ к только младшие битов 128-разрядного регистра и оставшиеся биты оставьте без изменений, если не указано иначе. (Обратите внимание, что значительно отличаются от AArch32, где были упакованы меньше регистров поверх регистры большего размера).

Помимо регистров данных регистр с плавающей точкой управления (FPCR) имеет определенные требования на различные битовые поля внутри него:

Bits|Значение|Переменный?|Роль
|-|-|-|-|
26|AHP|Неизменяемые|Альтернативное управление с половинной точностью
25|DN|Неизменяемые|Управление режимом по умолчанию NaN
24|FZ|Неизменяемый|Управление режимом обнуления
23—22|RMode|Неизменяемый|Управление режимом округления
15,12-8|IDE, IXE и т. д|Неизменяемые|Биты отслеживания исключения, должен всегда быть равен 0.

## <a name="system-registers"></a>Регистры системы

Как AArch32 спецификация AArch64 предоставляет три контролем системы «ИД потока» регистры, использовать и выделяются следующим образом:

Регистровое|Роль
|-|-|
TPIDR_EL0|Зарезервированное
TPIDRRO_EL0|Содержит число ЦП для текущего процессора
TPIDR_EL1|Указывает на структуру KPCR для текущего процессора

## <a name="floating-point-exceptions"></a>Исключения с плавающей запятой

Поддержка исключений с плавающей запятой IEEE является необязательным в системах AArch64. Для процессора вариантов, имеющих аппаратные исключения с плавающей запятой ядро Windows автоматически перехватывает эти исключения и неявно отключает их в регистре FPCR. Это позволяет обеспечить нормализованное поведение на вариантах процессоров (в противном случае кода, разработанного на платформе без поддержки исключений может оказаться самой принимая непредвиденные исключения при работе на платформе с поддержкой).

## <a name="parameter-passing"></a>Передача параметров

Для функции не с переменным числом аргументов Windows ABI соответствует правилам, определенным ARM для передачи параметров. Эти правила являются непосредственно выдержки из книги стандарту вызова процедур для архитектуры AArch64:

### <a name="stage-a--initialization"></a>Этап А — инициализация

Этот этап выполняется только один раз, прежде чем начнется обработка аргументов.

1. Далее общего назначения зарегистрировать номер (NGRN), равным нулю.

2. Далее SIMD и зарегистрировать число с плавающей запятой (NSRN), равным нулю.

3. Следующий адрес с накоплением аргумента (NSAA) устанавливается с текущим значением указателя стека (SP).

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>Этап Б — предварительного заполнения и расширение аргументов

Для каждого аргумента в списке применяется первое соответствующее правило из следующего списка. Если правило соответствия аргумента используется без изменений.

1. Если аргумент имеет тип, размер которого не удается определить статически, вызывающий и вызываемый объект составной тип, аргумент копируется в память и аргумент заменяется указатель для копирования. (Отсутствуют такие типы в C/C++, но они существуют на других языках или на расширения языка).

2. Если аргумент имеет тип HFA или HVA, то используется аргумент без изменений.

3. Если аргумент имеет тип составному типу, который больше, чем 16 байт, аргумент копируется в память, выделенную вызывающим объектом, и аргумент заменяется указатель для копирования.

4. Если аргумент имеет тип составной тип затем размер аргумента округляется до ближайшего кратного 8 байт.

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>Этап C — назначение аргументов регистрам и стеку

Для каждого аргумента в списке следующие правила применяются в свою очередь, пока не выделен аргумент. При назначении аргумента регистр всех неиспользуемых битов в регистре не указаны значения. При назначении аргумента слот стека байтов все неиспользуемые заполнения не указаны значения.

1. Если аргумент представляет половину-, одно-, двойной - или Quad одиночной точности с плавающей запятой или типа короткого вектора и NSRN имеет значение меньше, чем 8, то аргумент назначается для младших бит регистра v [NSRN]. NSRN увеличивается на единицу. Аргумент выделен.

2. Если аргумент является HFA или HVA и недостаточно нераспределенного SIMD и регистров с плавающей запятой (NSRN + число членов ≤ 8), аргумент назначается SIMD и регистрирует с плавающей запятой (с одной регистр на член HFA или HVA). NSRN увеличивается на число использованных регистров. Аргумент выделен.

3. Если аргумент является HFA или HVA NSRN установлено значение 8, и размер аргумента округляется вверх до ближайшего числа, кратного 8 байт.

4. Если аргумент является HFA HVA, Quad одиночной точности с плавающей запятой или короткий вектор тип, адрес NSAA округляется до большего размера, 8 или естественному выравниванию типа аргумента.

5. Если аргумент имеет тип половина - или одиночной точности с плавающей запятой, размер аргумента присваивается 8 байт. Эффект как если бы аргумент были скопированы младших разрядов 64-битным регистром и оставшиеся биты заполняются неуказанных значения.

6. Если аргумент является HFA, HVA, половина-, одно-, Double - или Quad одиночной точности с плавающей запятой или типа короткого вектора, то аргумент копируется в память по скорректированному NSAA. Адрес NSAA увеличивается на размер аргумента. Аргумент выделен.

7. Если аргумент имеет целочисленный тип или тип указателя, размер аргумента — меньше или равным 8 байт и NGRN имеет значение меньше, чем 8, аргумент копируется в младших бит в x [NGRN]. NGRN увеличивается на единицу. Аргумент выделен.

8. Если аргумент выравниванием 16 затем NGRN округляется до ближайшего четного числа.

9. Если аргумент — это целочисленный тип, размер аргумента равно 16 NGRN равно, меньше, чем 7 аргумент копируется в x [NGRN] и x [NGRN + 1]. x [NGRN] должен содержать известные проблемы двойной разряды представления памяти аргумента. NGRN увеличивается на два. Аргумент выделен.

10. Если аргумент имеет составной тип и размер словами двойной-аргумента не более чем 8 минус NGRN, то аргумент копируется в последовательных регистры общего назначения, начиная с x [NGRN]. Аргумент, передаваемый как будто он загружен в регистры с адреса double word выровнены с соответствующей последовательности инструкций LDR, загрузке последовательных регистров из памяти (содержимое все неиспользуемые части регистров не указаны Этот стандарт). NGRN увеличивается на число использованных регистров. Аргумент выделен.

11. NGRN установлено значение 8.

12. Адрес NSAA округляется до большего размера, 8 или естественному выравниванию типа аргумента... 

13. Если аргумент имеет составной тип, аргумент копируется в память по скорректированному NSAA. Адрес NSAA увеличивается на размер аргумента. Аргумент выделен.

14. Если размер аргумента меньше, чем 8 байт размер аргумента присваивается 8 байт. Действует как в том случае, если аргумент был скопирован в младших разрядов 64-битным регистром и оставшиеся биты заполняются неуказанных значения.

15. Аргумент копируется в память по скорректированному NSAA. Адрес NSAA увеличивается на размер аргумента. Аргумент выделен.

### <a name="addendum-variadic-functions"></a>Дополнения: Функции с переменным числом аргументов

Функций, принимающих переменное число аргументов обрабатываются иначе, чем выше, следующим образом:

1. Все сочетания обрабатываются alike; без специальной обработки HFAs или HVAs.

2. SIMD и регистры с плавающей запятой не используются.

Фактически это соответствует следующим правилам C.12–C.15 выделить аргументы мнимой стек, первые 64 байт стека будут загружены в x0 x7, куда обычно помещаются все остальные аргументы стека. 

## <a name="return-values"></a>Возвращаемые значения

Целочисленные значения возвращаются в x0. Значения с плавающей запятой возвращаются в s0/d0/v0 соответствующим образом.

Для возврата по значению, не может передаваться через регистры вызывающий объект должен оставляем за собой блок памяти, достаточный размер и выравнивание для хранения результата. Адрес блока памяти должны передаваться как дополнительный аргумент в функцию x8 для типа POD, или x0 (или x1 Если $, эти данные передаются в x0) для типа отличные от POD. Вызываемый объект может изменить результат блок памяти в любой момент во время выполнения подпрограммы (он не требуется для вызываемого метода сохранить значение, хранящееся в x8, но для отличных от POD, адрес буфера должен также быть, возвращаемые в x0 вызываемым объектом).

## <a name="stack"></a>Стек

После интерфейса ABI, изданным советом по ARM стек должен оставаться 16-байтовый выровненным по. AArch64 содержит аппаратная функция, которая создает выровнены ошибок всякий раз, когда выполняется относительно SP загрузки или хранения хранимой Процедуры не 16-байтовое выравнивание стека. Windows работает эта функция включена, все время.

Функции, которые выделяет 4 КБ или больше стоит стека необходимо убедиться, что каждая страница перед последней обрабатывается по порядку, обеспечивая код не может «рост по сравнению» страницы защиты, которые Windows использует для расширения стека. Обычно это делается `__chkstk` вспомогательного приложения, который имеет пользовательское соглашение об именовании, которое передает все выделение стека, деленное на 16 в x8.

## <a name="red-zone"></a>Красная зона

Область 16-байтовое сразу после текущего указателя стека, зарезервированные для использования в процессе анализа и динамического исправления сценариев. Это позволяет тщательно созданный код для вставки, который хранит 2 регистра в [sp, #-16] и временно использует их для произвольных целей. Ядро Windows гарантирует, что эти 16 байт не будут перезаписаны, при возникновении исключения или прерывания снимка в режиме ядра и пользователей.

## <a name="kernel-stack"></a>Стек ядра

Стек режима ядра по умолчанию в Windows — шесть страниц (24 КБ). Особое внимание на функции с большого буфера стека в режиме ядра. Прерывание несвоевременное может поступать с очень небольшой запас и создайте тот стека.

## <a name="stack-walking"></a>Проверка стека

Код Windows компилируется с включенными указателями фреймов ([/Oy-](../build/reference/oy-frame-pointer-omission.md)) для обеспечения быстрой проверки стека. Вывод этого – в общем x29 (fp) указывает на следующее звено в цепочке, который является {fp, lr} пары, указывающее, является указатель к предыдущему кадру в стеке, а обратный адрес. Сторонний код, стоит также включить указатели фреймов, чтобы можно было улучшенные профилирование и трассировка.

## <a name="exception-unwinding"></a>Очистка исключения

Очистка во время обработки исключений является телефоны службы при помощи кодов очистки. Коды очистки представляют собой последовательность байт, хранимых в разделе .xdata исполняемого файла, которые описывают работу пролога и эпилога отвлеченно, таким образом, чтобы воздействие пролога функции могут быть отменены в процессе подготовки к резервному копированию кадра стека вызывающего. Дополнительные сведения о кодах очистки, см. в разделе [обработки исключений ARM64](arm64-exception-handling.md).

Также ARM EABI задает модель очистки исключения, использует коды очистки. Тем не менее спецификации, представленный недостаточно для очистки в Windows, так как требуется обрабатывать случаи, когда компьютер находится в середине пролога или эпилога функции.

Должны быть описаны код, который создается динамически с помощью таблицы динамических функций через `RtlAddFunctionTable` и связанных функций, таким образом, чтобы созданный код может участвовать в обработке исключений.

## <a name="cycle-counter"></a>Счетчик циклов

Все ЦП ARMv8 необходимы для поддержки цикла счетчика регистра. Это 64-битным регистром, который настраивает Windows, чтобы их было читать на любом уровне исключения (включая режим). Он может осуществляться через специальный PMCCNTR_EL0 зарегистрировать, с помощью кода MSR операций в коде сборки или `_ReadStatusReg` встроенные в коде C/C++.

Обратите внимание, что значение счетчика цикла действительно счетчик, не определенное время и поэтому частота подсчета зависит от частоты процессора. Если вы считаете, что необходимо знать частоту счетчика циклов, вам не следует использовать счетчик циклов. Вместо этого необходимо измерить время по часам, для которого следует использовать `QueryPerformanceCounter`.

## <a name="see-also"></a>См. также

[Общие вопросы использования Visual C++ ARM](../build/common-visual-cpp-arm-migration-issues.md)  
[Обработка исключений ARM64](../build/arm64-exception-handling.md)  
