---
title: Библиотека DLL MFC, часто задаваемые вопросы | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- troubleshooting [C++], DLLs
- DLLs [C++], frequently asked questions
- FAQs [C++], DLLs
ms.assetid: 09dd068e-fc33-414e-82f7-289c70680256
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: bc42cd1eab4f19c8184ad500b4a4a1871747d6aa
ms.sourcegitcommit: 92f2fff4ce77387b57a4546de1bd4bd464fb51b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2018
ms.locfileid: "45713093"
---
# <a name="dll-frequently-asked-questions"></a>Вопросы и ответы по библиотекам DLL

Ниже представлены некоторые часто задаваемые вопросы (FAQ) о библиотеках DLL.

- [Создаются ли библиотеке DLL MFC нескольких потоков?](#mfc_multithreaded_1)

- [Можно многопоточного приложения доступ к библиотеке DLL MFC в различных потоках?](#mfc_multithreaded_2)

- [Существуют ли классы MFC или функции, которые не могут использоваться в библиотеке DLL MFC?](#mfc_prohibited_classes)

- [Способы оптимизации следует использовать для повышения производительности клиентского приложения при загрузке?](#mfc_optimization)

- [Имеется утечка памяти в в обычной библиотеке DLL MFC, но мой код выглядит хорошо. Как найти утечки памяти?](#memory_leak)

## <a name="mfc_multithreaded_1"></a> Создаются ли библиотеке DLL MFC нескольких потоков?

За исключением того, во время инициализации библиотеки DLL MFC допускается создание нескольких потоков до тех пор, пока он использует локальное хранилище (TLS) функции, такие как поток Win32 **TlsAlloc** выделить локальное хранилище потока. Тем не менее если в библиотеке DLL MFC используется **__declspec(thread)** для выделения локальной памяти потока, клиентское приложение должно быть неявно связано на библиотеку DLL. Если клиентское приложение явным образом связано с библиотекой DLL, вызов **LoadLibrary** не будет успешно загрузить библиотеку DLL. Дополнительные сведения о создании нескольких потоков в DLL-библиотеки MFC см. в статье базы знаний «PRB: вызов LoadLibrary() для загрузки библиотеки DLL, имеет статическая память TLS» (Q118816). Дополнительные сведения о локальные переменные потока в библиотеках DLL, см. в разделе [поток](../cpp/thread.md).

MFC DLL, которая создает новый поток MFC при запуске программа зависает при загрузке приложением. Сюда входят всякий раз, когда поток создается путем вызова `AfxBeginThread` или `CWinThread::CreateThread` внутри:

- `InitInstance` Из `CWinApp`-производный объект в обычной библиотеки DLL MFC.

- Указанный `DllMain` или **RawDllMain** функции в обычную библиотеку DLL MFC.

- Указанный `DllMain` или **RawDllMain** функции в библиотеки DLL расширения MFC.

Дополнительные сведения о создании потоков во время инициализации см. в статье базы знаний, «PRB: не удается создать MFC потоков во время DLL загрузка» (Q142243).

## <a name="mfc_multithreaded_2"></a> Можно многопоточного приложения доступ к библиотеке DLL MFC в различных потоках?

Многопоточные приложения могут обращаться к обычные библиотеки DLL MFC, который динамически связан с MFC и библиотеки DLL расширения MFC из разных потоков. И, начиная с Visual C++ версии 4.2, приложение может получить доступ к обычные библиотеки DLL MFC, статической компоновке с MFC из нескольких потоков, которые созданы в приложении.

До версии 4.2 только один внешний поток мог подключиться к обычной MFC DLL, статически компонуемые с MFC. Дополнительные сведения об ограничениях доступа к обычные библиотеки DLL MFC, статической компоновке с MFC из нескольких потоков (до версии Visual C++ версии 4.2) см. в статье базы знаний, «несколько потоков и MFC предшествовавших» (Q122676).

Обратите внимание, что термин USRDLL больше не используется в документации по Visual C++. Обычной MFC DLL, статически компонуемые с MFC имеет те же характеристики, как бывший USRDLL.

## <a name="mfc_prohibited_classes"></a> Существуют ли классы MFC или функции, которые не могут использоваться в библиотеке DLL MFC?

Использование библиотек DLL расширения `CWinApp`-производный класс клиентского приложения. Они не могут иметь свои собственные `CWinApp`-производного класса.

Обычные библиотеки DLL MFC должен иметь `CWinApp`-производный класс и один объект этого класса, как в приложении MFC. В отличие от `CWinApp` объект приложения, `CWinApp` объект библиотеки DLL не имеет цикла обработки сообщений.

Обратите внимание, что поскольку `CWinApp::Run` механизм не применяется в DLL-библиотеку, приложение имеет основной конвейер сообщений. Если библиотеки DLL открывает безрежимные диалоговые окна или фрейма главного окна свои собственные, приложения главный цикл обработки сообщений должен вызывать процедуру, экспортируемые библиотеки DLL, которая в свою очередь вызывает `CWinApp::PreTranslateMessage` функция-член объекта приложения библиотеки DLL.

## <a name="mfc_optimization"></a> Способы оптимизации следует использовать для улучшения клиентское приложение&#39;s производительности при загрузке?

Если ваш DLL – обычной MFC DLL, статически компонуемые с MFC, изменив ее на обычную библиотеку DLL MFC, динамически компонуемые с MFC уменьшает размер файла.

Если DLL имеет большое количество функций, используйте DEF-файл для экспорта функций (вместо использования **__declspec(dllexport)**) и использовать в DEF-файле [NONAME-атрибут](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md) на каждой экспортируемой функции. Атрибут NONAME приводит только порядковый номер и имя функции не должны храниться в таблице экспорта библиотеки DLL, которая уменьшает размер файла.

Библиотеки DLL, которые являются косвенным образом связывается с приложения загружаются при загрузке приложения. Для повышения производительности при загрузке, попробуйте разделить такую библиотеку DLL в разные библиотеки DLL. Поместите все функции, которые требуются вызывающему приложению сразу после загрузки в одну DLL и вызывающее приложение неявно ссылаются на эту Библиотеку. Поместите другие функции, которые вызывающему приложению не требуется сразу в другую библиотеку DLL, и у приложения явным образом связать с этой библиотекой DLL. Дополнительные сведения см. в разделе [Определение подходящего метода связывания использовать](../build/linking-an-executable-to-a-dll.md#determining-which-linking-method-to-use).

## <a name="memory_leak"></a> Существует&#39;s утечки памяти в в обычной библиотеке DLL MFC, но мой код выглядит хорошо. Как найти утечки памяти?

Одной из возможных причин утечки памяти является то, что MFC создает временные объекты, которые используются внутри функций обработчиков сообщений. В приложениях MFC, эти временные объекты автоматически очищаются в `CWinApp::OnIdle()` функция, вызываемая между обработки сообщений. Тем не менее, в MFC-библиотеки динамической компоновки (DLL) `OnIdle()` функция не вызывается автоматически. Таким образом временные объекты не удаляются автоматически. Чтобы очистить временные объекты, необходимо явно вызывать библиотеки DLL `OnIdle(1)` периодически.

## <a name="see-also"></a>См. также

[DLL в Visual C++](../build/dlls-in-visual-cpp.md)