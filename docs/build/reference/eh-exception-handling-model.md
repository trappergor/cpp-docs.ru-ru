---
title: /EH (модель обработки исключений)
description: Справочное руководство по параметрам компилятора Microsoft C++/EH (модель обработки исключений) в Visual Studio.
ms.date: 08/25/2020
f1_keywords:
- VC.Project.VCCLWCECompilerTool.ExceptionHandling
- /eh
- VC.Project.VCCLCompilerTool.ExceptionHandling
helpviewer_keywords:
- exception handling, compiler model
- cl.exe compiler, exception handling
- EH compiler option [C++]
- -EH compiler option [C++]
- /EH compiler option [C++]
no-loc:
- SEH
- try
- catch
- throw
- extern
- finally
- noexcept
ms.assetid: 754b916f-d206-4472-b55a-b6f1b0f2cb4d
ms.openlocfilehash: 0d18d0f1d73b1de46b12262deecb2436c34e6176
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898382"
---
# <a name="eh-exception-handling-model"></a>`/EH` (Модель обработки исключений)

Указывает поддержку модели обработки исключений, созданную компилятором. Аргументы указывают, следует ли применять `catch(...)` синтаксис к структурированным и стандартным исключениям C++, независимо от того, предполагается ли код ** extern "C"** throw исключениями и нужно ли оптимизировать определенные **`noexcept`** проверки.

## <a name="syntax"></a>Синтаксис

> **`/EHa`**[**`-`**]\
> **`/EHs`**[**`-`**]\
> **`/EHc`**[**`-`**]\
> **`/EHr`**[**`-`**]

## <a name="arguments"></a>Аргументы

**`a`**\
Включает стандартный сброс стека C++. При использовании синтаксиса перехватывает как структурированные (асинхронные), так и стандартные исключения C++ (синхронные) `catch(...)` . **`/EHa`** переопределяет **`/EHs`** оба **`/EHc`** аргумента и.

**`s`**\
Включает стандартный сброс стека C++. При использовании синтаксиса перехватывает только стандартные исключения C++ `catch(...)` . Если **`/EHc`** не указано иное, компилятор предполагает, что функции, объявленные как ** extern "C"** , могут иметь throw исключение C++.

**`c`**\
При использовании с **`/EHs`** компилятор предполагает, что функции, объявленные как ** extern "C"** , никогда не являются throw исключением C++. Он не действует при использовании с **`/EHa`** (то есть **`/EHca`** эквивалентно **`/EHa`** ). **`/EHc`** игнорируется, если не **`/EHs`** **`/EHa`** указан.

**`r`**\
Указывает компилятору всегда создавать проверки завершения среды выполнения для всех **`noexcept`** функций. По умолчанию проверка среды выполнения **`noexcept`** может быть оптимизирована, если компилятор определит, что функция вызывает только функции, не относящиеся к оператору throw . Этот параметр обеспечивает жесткое соответствие C++ затратам на некоторый дополнительный код. **`/EHr`** игнорируется, если не **`/EHs`** **`/EHa`** указан.

**`-`**\
Очищает предыдущий аргумент параметра. Например, **`/EHsc-`** интерпретируется как **`/EHs /EHc-`** , и эквивалентно **`/EHs`** .

**`/EH`** аргументы можно указывать отдельно или вместе в любом порядке. Если задано несколько экземпляров одного и того же аргумента, последний из них переопределяет все предыдущие.  Например, **`/EHr- /EHc /EHs`** имеет то же значение **`/EHscr-`** , что и, и **`/EHscr- /EHr`** имеет тот же результат, что и **`/EHscr`** .

## <a name="remarks"></a>Remarks

### <a name="default-exception-handling-behavior"></a>Поведение обработки исключений по умолчанию

Компилятор всегда создает код, поддерживающий асинхронную обработку исключений ( SEH ). По умолчанию (то есть если не **`/EHsc`** **`/EHs`** **`/EHa`** указан параметр, или) компилятор поддерживает SEH обработчики в собственном `catch(...)` предложении C++. Однако он также создает код, который лишь частично поддерживает исключения C++. Код очистки исключений по умолчанию не уничтожает автоматические объекты C++ за пределами [`try`](../../cpp/try-throw-and-catch-statements-cpp.md) блоков, которые выходят за пределы области действия из-за исключения. Утечки ресурсов и неопределенное поведение могут возникать, если исключение C++ равно throw n.

### <a name="standard-c-exception-handling"></a>Стандартная обработка исключений C++

Полная поддержка компилятора для стандартной модели обработки исключений C++, которая безопасно раскрутка объектов стека, требует **`/EHsc`** (рекомендуется), **`/EHs`** или **`/EHa`** .

Если используется **`/EHs`** или **`/EHsc`** , то `catch(...)` предложения не являются catch асинхронными структурированными исключениями. Все нарушения прав доступа и управляемые <xref:System.Exception?displayProperty=fullName> исключения переходят в неперехваченные. И объекты в области видимости, когда асинхронное исключение не уничтожается, даже если код обрабатывает асинхронное исключение. Это поведение является аргументом для необработанных структурированных исключений. Вместо этого рассмотрите эти исключения как неустранимые.

При использовании **`/EHs`** или **`/EHsc`** компилятор предполагает, что исключения могут происходить только в **`throw`** операторе или вызове функции. Это предположение позволяет компилятору исключать код для отслеживания времени существования множества объектов, не поддерживающих обмотку, что может значительно сократить размер кода. Если используется **`/EHa`** , исполняемый образ может быть больше и медленнее, так как компилятор не оптимизирует **`try`** блоки как агрессивно. Он также оставляет фильтры исключений, которые автоматически удаляют локальные объекты, даже если компилятор не увидит код, который может содержать throw исключение C++.

### <a name="structured-and-standard-c-exception-handling"></a>Структурированная и стандартная обработка исключений C++

**`/EHa`** Параметр компилятора обеспечивает безопасность очистки стека как для асинхронных исключений, так и для исключений C++. Он поддерживает обработку как стандартных C++, так и структурированных исключений с помощью собственного `catch(...)` предложения c++. Для реализации SEH без указания **`/EHa`** можно использовать **`__try`** **`__except`** синтаксис, и **`__finally`** . Дополнительные сведения см. в разделе [структурированная обработка исключений](../../cpp/structured-exception-handling-c-cpp.md).

> [!IMPORTANT]
> Указание **`/EHa`** и try использование для управления всеми исключениями с помощью `catch(...)` может быть опасно. В большинстве случаев восстановление после асинхронного исключения невозможно, и такие исключения следует считать неустранимыми. При их перехвате и продолжении работы возможно повреждение процесса и возникновение ошибок, которые трудно обнаружить и исправить.
>
> Несмотря на то что поддержка Windows и Visual C++ SEH , настоятельно рекомендуется использовать стандартную обработку исключений C++ ( **`/EHsc`** или) ISO **`/EHs`** . Это делает код более переносимым и гибким. По-прежнему может потребоваться использовать SEH в устаревшем коде или для определенных видов программ. Это необходимо, например, в коде, скомпилированном для поддержки среды CLR ( [`/clr`](clr-common-language-runtime-compilation.md) ). Дополнительные сведения см. в разделе [структурированная обработка исключений](../../cpp/structured-exception-handling-c-cpp.md).
>
> Рекомендуется никогда не привязать объектные файлы, скомпилированные с помощью **`/EHa`** , к объектам, скомпилированным с помощью **`/EHs`** или **`/EHsc`** в том же исполняемом модуле. Если необходимо реализовать асинхронное исключение с помощью **`/EHa`** любого места в модуле, используйте **`/EHa`** для компиляции всего кода в модуле. Синтаксис структурированной обработки исключений можно использовать в том же модуле, что и код, компилируемый с помощью **`/EHs`** . Однако нельзя смешивать SEH синтаксис с C++ **`try`** , **`throw`** и в одной и той **`catch`** же функции.

Используйте **`/EHa`** , если требуется catch исключение, вызванное не объектом **`throw`** . В этом примере создается и catch ES структурированного исключения:

```cpp
// compiler_options_EHA.cpp
// compile with: /EHa
#include <iostream>
#include <excpt.h>
using namespace std;

void fail()
{
    // generates SE and attempts to catch it using catch(...)
    try
    {
        int i = 0, j = 1;
        j /= i;   // This will throw a SE (divide by zero).
        printf("%d", j);
    }
    catch(...)
    {
        // catch block will only be executed under /EHa
        cout << "Caught an exception in catch(...)." << endl;
    }
}

int main()
{
    __try
    {
        fail();
    }

    // __except will only catch an exception here
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // if the exception was not caught by the catch(...) inside fail()
        cout << "An exception was caught in __except." << endl;
    }
}
```

### <a name="exception-handling-under-clr"></a>Обработка исключений в/CLR

**`/clr`** Параметр подразумевает (то есть **`/EHa`** **`/clr /EHa`** является избыточным). Компилятор выдает ошибку, если **`/EHs`** или **`/EHsc`** используется после **`/clr`** . Оптимизация не влияет на это поведение. При перехвате исключения компилятор вызывает деструкторы класса для всех объектов, наявляющихся в той же области, что и исключение. Если исключение не перехвачено, эти деструкторы не выполняются.

Дополнительные сведения об ограничениях обработки исключений в см **`/clr`** . в разделе [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md).

### <a name="runtime-exception-checks"></a>Проверки исключений времени выполнения

**`/EHr`** Параметр задает принудительную проверку завершения выполнения во всех функциях, имеющих **`noexcept`** атрибут. По умолчанию проверки среды выполнения могут быть оптимизированы, если серверная части компилятора определяет, что функция вызывает только функции, *не throw * применяясь. Несамостоятельные throw функции — это любые функции с атрибутом, который указывает, что исключения не могут быть throw n. К ним относятся функции, помеченные как **`noexcept`** , `throw()` , `__declspec(nothrow)` и, если **`/EHc`** заданы **`extern "C"`** функции. Функции, не применяющие throw к работе, также включают все, что компилятор определяет как несамостоятельный анализ throw . Поведение по умолчанию можно задать явным образом с помощью **`/EHr-`** .

Несамостоятельный throw атрибут не гарантирует, что в функции исключения не могут быть throw n. В отличие от поведения **`noexcept`** функции, КОМПИЛЯТОР компилятором MSVC считает исключение throw n функцией, объявленной с помощью `throw()` , `__declspec(nothrow)` или **`extern "C"`** как неопределенное поведение. Функции, использующие эти три атрибута объявления, не применяют проверки завершения среды выполнения для исключений. Можно использовать **`/EHr`** параметр, чтобы определить это неопределенное поведение, заставляя компилятор создавать проверки среды выполнения для необработанных исключений, которые обрабатывают **`noexcept`** функцию.

## <a name="set-the-option-in-visual-studio-or-programmatically"></a>Установка параметра в Visual Studio или программным способом

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите **Свойства конфигурации**  >  Создание кода**C/C++**  >  **Code Generation**.

1. Измените значение свойства **Включить C++ исключения** .

   Можно также задать для параметра **Включить C++ исключения** значение **Нет**, а затем на странице свойств **Командная строка** в поле **Дополнительные параметры** добавить параметр компилятора.

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A>.

## <a name="see-also"></a>См. также

[Параметры компилятора КОМПИЛЯТОРОМ MSVC](compiler-options.md)\
[Синтаксис командной строки компилятора КОМПИЛЯТОРОМ MSVC](compiler-command-line-syntax.md)\
[Ошибки и обработка исключений](../../cpp/errors-and-exception-handling-modern-cpp.md)\
[Спецификации исключений ( throw )](../../cpp/exception-specifications-throw-cpp.md)\
[Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)
