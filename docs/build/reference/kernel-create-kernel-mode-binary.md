---
title: /kernel (создание двоичного режима ядра)
ms.date: 11/04/2016
f1_keywords:
- /kernel
- /kernel-
ms.assetid: 6d7fdff0-c3d1-4b78-9367-4da588ce8b05
ms.openlocfilehash: bcef52144e4da932e9e1b6acbcd5f2170c4c7f86
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87211948"
---
# <a name="kernel-create-kernel-mode-binary"></a>/kernel (создание двоичного режима ядра)

Создает двоичный файл, который может быть выполнен в ядре Windows.

## <a name="syntax"></a>Синтаксис

```
/kernel[-]
```

## <a name="arguments"></a>Аргументы

**/Kernel**<br/>
Код в текущем проекте компилируется и связывается с помощью набора правил языка C++, характерных для кода, который будет выполняться в режиме ядра.

**/Kernel**<br/>
Код в текущем проекте компилируется и связывается без использования правил языка C++, характерных для кода, который будет выполняться в режиме ядра.

## <a name="remarks"></a>Remarks

`#pragma`Для управления этим параметром нет эквивалента.

Указание параметра **/kernel** предписывает компилятору и компоновщику определить, какие функции языка допустимы в режиме ядра, и убедиться, что у вас достаточно выразительные электроэнергию, чтобы избежать нестабильности среды выполнения, которая уникальна для режима ядра C++. Это достигается за счет запрета использования функций языка C++, которые нарушают работу в режиме ядра, и предупреждений для функций языка C++, которые могут быть нарушены, но не могут быть отключены.

Параметр **/kernel** применяется к этапам компилятора и компоновщика сборки и устанавливается на уровне проекта. Передайте параметр **/kernel** , чтобы указать компилятору, что полученный двоичный файл после компоновки следует загрузить в ядро Windows. Компилятор будет ограничивать спектр возможностей языка C++ до подмножества, совместимого с ядром.

В следующей таблице перечислены изменения в поведении компилятора при указании **/kernel** .

|Тип поведения|**/kernel** Неполадок|
|-------------------|---------------------------|
|Обработка исключений С++|Отключено. Все экземпляры **`throw`** **`try`** ключевых слов и выдают ошибку компилятора (за исключением спецификации исключения `throw()` ). Параметры **/EH** несовместимы с **/kernel**, за исключением **/ех-**.|
|RTTI|Отключено. Все экземпляры **`dynamic_cast`** **`typeid`** ключевых слов и выдают ошибку компилятора, если только **`dynamic_cast`** не используется статически.|
|`new` и `delete`|Необходимо явно определить `new()` `delete()` оператор OR; ни компилятор, ни среда выполнения не будут предоставлять определение по умолчанию.|

При использовании параметра **/kernel** разрешены пользовательские соглашения о вызовах, параметр сборки [/GS](gs-buffer-security-check.md) и все оптимизации. На встраивание в основном не влияет **/kernel**с той же семантикой, что и компилятор. Если необходимо убедиться в том, что **`__forceinline`** квалификатор встраивания учитывается, необходимо убедиться в том, что предупреждение [C4714](../../error-messages/compiler-warnings/compiler-warning-level-4-c4714.md) включено, и вы знаете, когда определенная **`__forceinline`** функция не встроена.

Когда компилятор передает параметр **/kernel** , он предварительно определяет макрос препроцессора с именем `_KERNEL_MODE` и имеет значение **1**. Его можно использовать для условной компиляции кода в зависимости от того, находится ли среда выполнения в пользовательском режиме или режиме ядра. Например, следующий код указывает, что класс должен находиться в сегменте памяти, не являющемся страничным, когда он компилируется для выполнения в режиме ядра.

```cpp
#ifdef _KERNEL_MODE
#define NONPAGESECTION __declspec(code_seg("$kerneltext$"))
#else
#define NONPAGESECTION
#endif

class NONPAGESECTION MyNonPagedClass
{
   // ...
};
```

Некоторые из приведенных ниже сочетаний целевой архитектуры и параметра **/Arch** выдают ошибку при использовании с **/kernel**:

- **/arch: {SSE&#124;SSE2&#124;AVX}** не поддерживаются на платформе x86. Для **/kernel** на платформе x86 поддерживается только **/arch: IA32** .

- **/arch: AVX** не поддерживается в **/kernel** на x64.

Сборка с помощью **/kernel** также передает **/kernel** компоновщику. Вот как это влияет на поведение компоновщика:

- Инкрементная компоновка отключена. При добавлении **/incremental** в командную строку компоновщик выдает эту неустранимую ошибку:

   **Ссылка: Неустранимая ошибка LNK1295: "/INCREMENTAL" несовместим с спецификацией "/KERNEL"; Ссылка без "/INCREMENTAL"**

- Компоновщик проверяет каждый объектный файл (или любой включенный элемент архива из статических библиотек), чтобы определить, может ли он быть скомпилирован с помощью параметра **/kernel** , но не был. Если какие-либо экземпляры соответствуют этому критерию, компоновщик все равно успешно ссылается, но может выдать предупреждение, как показано в следующей таблице.

   ||obj- **/kernel**|**/Кернел-** obj, MASM obj или квтресед|Сочетание **/kernel** и **/Кернел-** OBJ-файлы|
   |-|----------------------|-----------------------------------------------|-------------------------------------------------|
   |**/Kernel ссылок**|Да|Да|Да, с предупреждением LNK4257|
   |**ссылку**|Да|Да|Да|

   **Объект компоновки LNK4257 не компилируется с/KERNEL; образ не может быть запущен**

Параметр **/kernel** и параметр **/Driver** работают независимо друг от друга и никак не влияют на другой.

### <a name="to-set-the-kernel-compiler-option-in-visual-studio"></a>Установка параметра компилятора/kernel в Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойств сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите папку **C/C++** .

1. Выберите страницу свойств **Командная строка** .

1. В поле **Дополнительные параметры** добавьте `/kernel` или `/kernel-` .

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)<br/>
[Синтаксис командной строки компилятора КОМПИЛЯТОРОМ MSVC](compiler-command-line-syntax.md)
