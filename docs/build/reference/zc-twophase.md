---
title: /Zc:twoPhase- (отключение двухэтапного поиска имени)
description: 'Объясняет, как/Zc: twoPhase — отключает поиск по двум фазам имен при указании/permissive-.'
ms.date: 12/03/2019
f1_keywords:
- twoPhase
- /Zc:twoPhase
helpviewer_keywords:
- twoPhase
- disable two-phase name lookup
- /Zc:twoPhase
ms.openlocfilehash: 3464759793a2dd243024a9f3f52263f76514033a
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79438639"
---
# <a name="zctwophase--disable-two-phase-name-lookup"></a>/Zc:twoPhase- (отключение двухэтапного поиска имени)

Параметр **/Zc: twoPhase-** в разделе **/permissive-** указывает компилятору использовать исходное, не согласованное поведение компилятора Майкрософт C++ для анализа и создания экземпляров шаблонов классов и шаблонов функций.

## <a name="syntax"></a>Синтаксис

> **/Zc: twoPhase —**

## <a name="remarks"></a>Remarks

Visual Studio 2017 версии 15,3 и более поздних версий: в [/permissive-](permissive-standards-conformance.md)компилятор использует двухэтапный поиск по имени шаблона для разрешения имен. Если также указать **/Zc: twoPhase-** , компилятор вернется к предыдущему несоответствующему шаблону класса, а также разрешению и замене имени шаблона функции. Если **/permissive-** не указан, по умолчанию используется несоответствие.

Файлы заголовков Windows SDK в версии 10.0.15063.0 (создатели обновления или RS2) и более ранних версий не работают в режиме соответствия. **/Zc: twoPhase —** требуется для компиляции кода для этих версий пакета SDK при использовании **/permissive-** . Версии Windows SDK, начиная с версии 10.0.15254.0 (обновления или RS3), правильно работают в режиме соответствия. Они не нуждаются в параметре **/Zc: twoPhase-** Option.

Используйте **/Zc: twoPhase —** если в коде требуется правильно компилировать старое поведение. Настоятельно рекомендуем обновить код, чтобы он соответствовал стандарту.

### <a name="compiler-behavior-under-zctwophase-"></a>Поведение компилятора в разделе/Zc: twoPhase-

По умолчанию или в Visual Studio 2017 версии 15,3 и более поздних версиях при указании одновременно **/permissive-** и **/Zc: twoPhase-** , компилятор использует такое поведение:

- Он анализирует только объявление шаблона, заголовок класса и список базовых классов. Тело шаблона записывается в виде потока токенов. Не анализируются тела функций, инициализаторы, аргументы по умолчанию или аргументы, кроме аргументов. Шаблон класса создается на основе типа с предварительным созданием экземпляра для проверки правильности объявлений в шаблоне класса. Рассмотрим этот шаблон класса:

   ```cpp
   template <typename T> class Derived : public Base<T> { ... }
   ```

   Объявление шаблона, `template <typename T>`, `class Derived`заголовка класса и `public Base<T>` списка базовых классов анализируется, но тело шаблона записывается как поток маркера.

- При синтаксическом анализе шаблона функции компилятор анализирует только сигнатуру функции. Тело функции не анализируется. Вместо этого он фиксируется как поток маркера.

В результате, если тело шаблона содержит синтаксические ошибки, но шаблон никогда не создается, компилятор не выполняет диагностику ошибок.

Другим результатом этого поведения является разрешение перегрузки. Нестандартное поведение происходит из-за того, что поток токенов расширяется на сайте создания экземпляра. Символы, которые не были видны в объявлении шаблона, могут быть видимыми в момент создания экземпляра. Это означает, что они могут участвовать в разрешении перегрузки. Шаблоны могут изменяться в зависимости от кода, который не был виден в определении шаблона, в противоположность стандарту.

Рассмотрим для примера такой код:

```cpp
// zctwophase.cpp
// To test options, compile by using
// cl /EHsc /nologo /W4 zctwophase.cpp
// cl /EHsc /nologo /W4 /permissive- zctwophase.cpp
// cl /EHsc /nologo /W4 /permissive- /Zc:twoPhase- zctwophase.cpp

#include <cstdio>

void func(long) { std::puts("Standard two-phase") ;}

template<typename T> void g(T x)
{
    func(0);
}

void func(int) { std::puts("Microsoft one-phase"); }

int main()
{
    g(6174);
}
```

Ниже приведены выходные данные при использовании режима по умолчанию, режима соответствия и режима соответствия с параметрами **/Zc: twoPhase-** Compiler:

```cmd
C:\Temp>cl /EHsc /nologo /W4 zctwophase.cpp && zctwophase
zctwophase.cpp
Microsoft one-phase

C:\Temp>cl /EHsc /nologo /W4 /permissive- zctwophase.cpp && zctwophase
zctwophase.cpp
Standard two-phase

C:\Temp>cl /EHsc /nologo /W4 /permissive- /Zc:twoPhase- zctwophase.cpp && zctwophase
zctwophase.cpp
Microsoft one-phase
```

При компиляции в режиме соответствия в разделе **/permissive-** эта программа выводит "`Standard two-phase`", так как вторая перегрузка `func` не видна, когда компилятор достигает шаблона. При добавлении **/Zc: twoPhase-** программа выводит "`Microsoft one-phase`". Выходные данные те же, что и при отсутствии указания **/permissive-** .

*Зависимые имена* — это имена, которые зависят от параметра шаблона. Эти имена имеют поведение поиска, которое также отличается от параметра **/Zc: twoPhase-** . В режиме соответствия зависимые имена не связаны в точке определения шаблона. Вместо этого компилятор просматривает их при создании экземпляра шаблона. Для вызовов функций с именем зависимой функции имя привязывается к функциям, видимым в месте вызова в определении шаблона. Добавляются дополнительные перегрузки из поиска с зависимостью от аргументов, как в точке определения шаблона, так и в момент создания экземпляра шаблона.

Двухэтапный поиск состоит из двух частей: Поиск независимых имен в определении шаблона и поиск зависимых имен во время создания экземпляра шаблона. В разделе **/Zc: twoPhase-** компилятор не выполняет поиск с зависимостью от аргументов отдельно от неквалифицированного уточняющего запроса. То есть он не выполняет двухэтапный поиск, поэтому результаты разрешения перегрузки могут отличаться.

Вот еще один пример:

```cpp
// zctwophase1.cpp
// To test options, compile by using
// cl /EHsc /W4 zctwophase1.cpp
// cl /EHsc /W4 /permissive- zctwophase1.cpp
// cl /EHsc /W4 /permissive- /Zc:twoPhase- zctwophase1.cpp

#include <cstdio>

void func(long) { std::puts("func(long)"); }

template <typename T> void tfunc(T t) {
    func(t);
}

void func(int) { std::puts("func(int)"); }

namespace NS {
    struct S {};
    void func(S) { std::puts("NS::func(NS::S)"); }
}

int main() {
    tfunc(1729);
    NS::S s;
    tfunc(s);
}
```

При компиляции без **/permissive-** этот код выводит:

```Output
func(int)
NS::func(NS::S)
```

При компиляции с помощью **/permissive-** , но без **/Zc: twoPhase-** , этот код выводит:

```Output
func(long)
NS::func(NS::S)
```

При компиляции с **/permissive-** и **/Zc: twoPhase-** этот код выводит:

```Output
func(int)
NS::func(NS::S)
```

В режиме соответствия в разделе **/permissive-** вызов `tfunc(1729)` разрешается в перегрузку `void func(long)`. Он не разрешается в перегрузку `void func(int)`, как в разделе **/Zc: twoPhase-** . Это обусловлено тем, что неквалифицированные `func(int)` объявляются после определения шаблона и не обнаруживаются при поиске с зависимостью от аргументов. Но `void func(S)` участвует в поиске с зависимостью от аргументов, поэтому он добавляется в перегруженный набор для вызова `tfunc(s)`, даже если он объявлен после функции-шаблона.

### <a name="update-your-code-for-two-phase-conformance"></a>Обновление кода для двухфазной согласованности

В более старых версиях компилятора не требуются ключевые слова `template` и `typename` везде, C++ где они требуются. Эти ключевые слова необходимы в некоторых позициях, чтобы определить, как компиляторы должны анализировать зависимое имя во время первого этапа поиска. Пример:

`T::Foo<a || b>(c);`

Согласованный компилятор анализирует `Foo` как переменную в области `T`, что означает, что этот код является логическим выражением или с `T::foo < a` в качестве левого операнда и `b > (c)` в качестве правого операнда. Если вы хотите использовать `Foo` в качестве шаблона функции, необходимо указать, что это шаблон, добавив `template` ключевое слово:

`T::template Foo<a || b>(c);`

В версиях Visual Studio 2017 версии 15,3 и более поздних, когда указаны **/permissive-** и **/Zc: twoPhase-** , компилятор разрешает этот код без ключевого слова `template`. Он интерпретирует код как вызов шаблона функции с аргументом `a || b`, так как он только анализирует шаблоны ограниченным образом. Приведенный выше код не анализируется на первом этапе. На втором этапе достаточно контекста, чтобы сообщить, что `T::Foo` является шаблоном, а не переменной, поэтому компилятор не применяет использование ключевого слова.

Это поведение также можно увидеть, удалив ключевое слово `typename` перед именами в теле шаблона функции, инициализаторах, аргументах по умолчанию и параметрах, кроме аргументов. Пример:

```cpp
template<typename T>
typename T::TYPE func(typename T::TYPE*)
{
    /* typename */ T::TYPE i;
}
```

Если в теле функции не используется ключевое слово `typename`, этот код компилируется в разделе **/Permissive-/Zc: twoPhase-** , но не только в **/permissive-** . Ключевое слово `typename` требуется, чтобы указать, что `TYPE` является зависимым. Так как текст не анализируется в разделе **/Zc: twoPhase-** , компилятору не требуется ключевое слово. В режиме соответствия **/permissive-** код без ключевого слова `typename` создает ошибки. Чтобы перенести код на соответствие в Visual Studio 2017 версии 15,3 и более поздних версий, вставьте ключевое слово `typename` в том месте, где оно отсутствует.

Аналогичным образом рассмотрим следующий пример кода:

```cpp
template<typename T>
typename T::template X<T>::TYPE func(typename T::TYPE)
{
    typename T::/* template */ X<T>::TYPE i;
}
```

В разделе **/Permissive-/Zc: twoPhase-** and в более старых компиляторах для компилятора требуется только ключевое слово `template` в строке 2. В режиме соответствия компилятору теперь также требуется ключевое слово `template` в строке 4, чтобы указать, что `T::X<T>` является шаблоном. Найдите код, в котором отсутствует ключевое слово, и укажите его, чтобы сделать код соответствующим стандарту.

Дополнительные сведения о проблемах соответствия см. [ C++ в разделе улучшения соответствия в Visual Studio](../../overview/cpp-conformance-improvements.md) и [нестандартное поведение](../../cpp/nonstandard-behavior.md).

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Перейдите на страницу свойств **Свойства конфигурации** > **C/C++**  > **Командная строка**.

1. Измените свойство **Дополнительные параметры** , включив параметр **/Zc: twoPhase-** и нажмите кнопку **ОК**.

## <a name="see-also"></a>См. также раздел

[/Zc (соответствие)](zc-conformance.md)
