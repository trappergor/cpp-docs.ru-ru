---
title: Общие сведения о возможных проблемах, возникающих при обновлении (Visual C++)
ms.date: 05/03/2019
ms.assetid: 2c99a8cb-098f-4a9d-bf2c-b80fd06ace43
ms.openlocfilehash: e42762d4b47931f21536146cd0146b2749c52cf9
ms.sourcegitcommit: 6b3d793f0ef3bbb7eefaf9f372ba570fdfe61199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2020
ms.locfileid: "86404825"
---
# <a name="overview-of-potential-upgrade-issues-visual-c"></a>Общие сведения о возможных проблемах, возникающих при обновлении (Visual C++)

За прошедшие годы компилятор Microsoft C++ претерпел множество изменений, кроме того, изменения были внесены и в сам язык C++, стандартную библиотеку C++, среду выполнения C (CRT) и другие библиотеки, например MFC и ATL. В результате при обновлении приложения с более ранней версии Visual Studio могут возникнуть ошибки компилятора и компоновщика, а также появиться предупреждения в коде, который ранее компилировался без проблем. Чем старше исходная база кода, тем больше вероятность таких ошибок. Этот обзор охватывает наиболее распространенные виды проблем, с которыми вы можете столкнуться, а также содержит ссылки на более подробные сведения.

> [!NOTE]
> Раньше мы рекомендовали выполнять обновления, охватывающие несколько версий Visual Studio, последовательно, переходя от версии к версии. Однако теперь это не так. Мы обнаружили, что в подавляющем большинстве случаев проще выполнить обновление до самой новой версии Visual Studio независимо от возраста базы кода.

Вопросы и комментарии о процессе обновления можно отправить на адрес vcupgrade@microsoft.com.

## <a name="library-and-toolset-dependencies"></a>Зависимости библиотек и наборов средств

> [!NOTE]
> Этот раздел относится к приложениям и библиотекам, созданным с помощью Visual Studio 2013 и более ранних версий. Наборы средств, используемые в Visual Studio 2015, Visual Studio 2017 и Visual Studio 2019, совместимы на уровне двоичного кода. Дополнительные сведения см. в разделе [Совместимость двоичного кода C++ между Visual Studio 2015 и Visual Studio 2019](binary-compat-2015-2017.md).

При обновлении приложения до новой версии Visual Studio рекомендуется, а во многих случаях — необходимо, обновить также все библиотеки и библиотеки DLL, на которые ссылается приложение. Для этого вам требуется иметь доступ к исходному коду либо получить от поставщика библиотеки новые двоичные файлы, скомпилированные в компиляторе с таким же основным номером версии. Если одно из этих условий соблюдено, можете пропустить данный раздел со сведениями о совместимости двоичных данных. Если ни одно из условий не выполняется, возможно, что использовать библиотеки в обновленном приложении вы не сможете. Приведенные в этом разделе сведения помогут вам понять, можно ли продолжать обновление.

### <a name="toolset"></a>Набор инструментов

Форматы файлов OBJ и LIB четко определены и редко изменяются. Иногда в них вносятся дополнения, однако они обычно не препятствуют использованию объектных файлов и библиотек, созданных в более старых наборах инструментов. Одним важным исключением здесь является компиляция с помощью [/GL (оптимизация всей программы)](../build/reference/gl-whole-program-optimization.md). При компиляции с помощью `/GL` итоговый объектный файл может быть связан только с тем набором инструментов, который использовался для его создания. Таким образом, если вы создаете объектный файл, используя `/GL` и компилятор Visual Studio 2017 (версии 141), нужно скомпоновать его с помощью компоновщика Visual Studio 2017 (версии 141). Это вызвано тем, что внутренние структуры данных в объектных файлах не являются стабильными в разных основных номерах версий набора инструментов, поэтому более новые наборы инструментов не поддерживают старые форматы данных.

У C++ нет стабильного двоичного интерфейса приложений (ABI). Visual Studio предоставляет стабильный ABI C++ для всех дополнительных номеров версий выпуска. Visual Studio 2015 (v140), Visual Studio 2017 (v141) и Visual Studio 2019 (v142) отличаются только по дополнительным номерам версии. Все они имеют тот же номер основной версии — 14. Дополнительные сведения см. в разделе [Совместимость двоичного кода C++ между Visual Studio 2015 и Visual Studio 2019](binary-compat-2015-2017.md).

Объектный файл, содержащий внешние символы с компоновкой C++, может неправильно связываться с объектными файлами, созданными с помощью другого основного номера версии набора инструментов. Существует много возможных исходов: привязка может полностью завершиться ошибкой (например, при изменении декорирования имен). Привязка может завершиться успешно, но компоненты не будут работать во время выполнения (например, при изменении макета типа). Во многих случаях все будет работать правильно. Обратите внимание, что, хотя ABI C++ не является стабильным, ABI C и подмножество ABI C++, необходимые для модели COM, стабильны.

При компоновке с библиотекой импорта любые более поздние версии библиотек распространяемых компонентов Visual Studio, которые сохраняют совместимость с ABI, можно использовать во время выполнения. Например, если приложение скомпилировано и скомпоновано с помощью набора инструментов Visual Studio 2015 с обновлением 3, вы можете использовать любой распространяемый компонент Visual Studio 2017 или Visual Studio 2019, так как библиотеки 2015, 2017 и 2019 сохранили обратную совместимость двоичного кода. Обратная неверность: нельзя использовать распространяемый пакет для более ранней версии набора инструментов, чем вы использовали для построения кода, даже если у них есть совместимый интерфейс ABI.

### <a name="libraries"></a>Библиотеки

При компиляции исходного файла с помощью определенной версии файлов заголовков библиотек C++ Visual Studio (заголовки включаются посредством #including) полученный объектный файл должен быть скомпонован с использованием той же версии библиотек. Например, если исходный файл компилируется с обновлением 3 для Visual Studio 2015 \<immintrin.h> , необходимо установить связь с библиотекой vcruntime для Visual studio 2015 3. Аналогичным образом, если исходный файл компилируется с Visual Studio 2017 версии 15,5 \<iostream> , необходимо создать компоновку с помощью стандартной библиотеки C++ для Visual studio 2017 версии 15,5, msvcprt. Комбинирование по своему усмотрению не поддерживается.

Для стандартной библиотеки C++ комбинирование по своему усмотрению явно запрещено за счет применения `#pragma detect_mismatch` в стандартных заголовках со времени выпуска Visual Studio 2010. Если попытаться скомпоновать несовместимые объектные файлы либо выполнить компоновку с неподходящей стандартной библиотекой, такая компоновка завершается ошибкой.

Для CRT комбинирование по своему усмотрению никогда не поддерживалось, но часто работало, по крайней мере до появления Visual Studio 2015 и универсальной CRT, так как поверхность API изменялась не слишком сильно. В универсальной CRT такая обратная совместимость была нарушена, чтобы мы могли обеспечивать обратную совместимость в будущем. Другими словами, у нас пока нет планов для введения новых двоичных файлов с разными версиями для универсальной CRT. Вместо этого существующая универсальная CRT теперь обновляется на месте.

Чтобы обеспечить частичную совместимость компоновки с объектными файлами (и библиотеками), скомпилированными с использованием более старых версий заголовков среды выполнения Microsoft C, мы предоставляем библиотеку legacy_stdio_definitions.lib, входящую в состав Visual Studio 2015 и более поздних версий. Эта библиотека содержит символы совместимости для большинства функций и экспортов данных, которые были удалены из универсальной CRT. Предоставляемого legacy_stdio_definitions.lib набора символов совместимости достаточно для большинства зависимости, включая все зависимости в библиотеках, входящих в пакет Windows SDK. Однако для некоторых символов, удаленных из универсальной CRT, невозможно предоставить символы совместимости. В таким символам относятся некоторые функции (например, \_\_iob\_func) и экспорты данных (например, \_\_imp\_\_\_iob, \_\_imp\_\_\_pctype, \_\_imp\_\_\_mb\_cur\_max).

При наличии статической библиотеки, которая была создана с более старой версии заголовков библиотеки времени выполнения C, мы рекомендуем следующие действия в указанном порядке:

1. Перестройте статическую библиотеку с помощью новой версии Visual Studio и заголовков универсальной CRT, чтобы обеспечить поддержку компоновки с универсальной CRT. Это подход полностью поддерживается (и поэтому является наиболее оптимальным).

1. Если вы не можете (или не хотите) перестраивать статическую библиотеку, можно попробовать выполнить компоновку с legacy\_stdio\_definitions.lib. Если этот компонент удовлетворяет зависимостям времени компоновки для вашей статической библиотеки, потребуется тщательно протестировать использование статической библиотеки в двоичном коде, чтобы убедиться, что ее не затрагивают все те [поведенческие изменения, которые были внесены в универсальную CRT](visual-cpp-change-history-2003-2015.md#BK_CRT).

1. Если зависимости статической библиотеки не удовлетворяют устаревшим \_ \_ определениям stdio. lib или если библиотека не работает с УНИВЕРСАЛЬНой библиотекой CRT из-за вышеупомянутых изменений в поведении, мы рекомендуем инкапсулировать статическую библиотеку в библиотеку DLL, связываемую с правильной версией среды выполнения Microsoft C. Например, если статическая библиотека создана с помощью Visual Studio 2013, следует создать такую библиотеку DLL с помощью Visual Studio 2013 и библиотек C++ Visual Studio 2013. Встроив библиотеку в библиотеку DLL, вы инкапсулируете сведения о реализации, представляющие ее зависимость от определенной версии среды выполнения Microsoft C. Вам потребуется следить за тем, чтобы интерфейс DLL не вызывал "утечку" сведений об используемой среде выполнения C, например возвращая FILE* через границу библиотеки DLL либо возвращая выделенный указатель malloc и ожидая, что вызывающий объект освободит его.

Использование нескольких библиотек CRT в одном процессе само по себе не вызывает проблем (ведь большинство процессов вызывает загрузку нескольких библиотек DLL CRT; например, компоненты операционной системы Windows будут зависеть от msvcrt.dll, а среда CLR будет зависеть от собственной закрытой CRT). Проблемы возникают, когда вы смешиваете состояния из разных CRT. Например, не следует выделять память с помощью msvcr110.dll!malloc и попытаться освободить ее с помощью msvcr120.dll!free либо открывать файл с помощью msvcr110! fopen и пытаться считать его с помощью msvcr120! fread. Пока вы не смешиваете состояние из разных библиотек CRT, можно безопасно иметь несколько библиотек CRT, загруженных в один процесс.

Дополнительные сведения см. в разделе [Обновление кода для универсальной среды выполнения C](upgrade-your-code-to-the-universal-crt.md).

## <a name="errors-due-to-project-settings"></a>Ошибки, вызванные параметрами проекта

Чтобы начать процесс обновления, откройте старую версию проекта, решения или рабочей области в последней версии Visual Studio. Visual Studio создаст новый проект на основе старых параметров проекта. Если в старом проекте имеются библиотечные или включаемые пути, жестко запрограммированные для нестандартных расположений, файлы в этих путях не будут видны компилятору, если проект использует параметры по умолчанию. Дополнительные сведения см. в разделе [Параметр OutputFile компоновщика](porting-guide-spy-increment.md#linker_output_settings).

В общем случае сейчас уместно правильно упорядочить код проекта, чтобы упростить обслуживание проекта и ускорить компиляцию кода. Если исходный код уже хорошо структурирован, а старый проект скомпилирован с помощью Visual Studio 2010 или более поздней версии, можно вручную изменить файл проекта, чтобы обеспечить поддержку компиляции как в старом, так в новом компиляторе. Следующий пример демонстрирует компиляцию для Visual Studio 2015 и Visual Studio 2017:

```xml
<PlatformToolset Condition="'$(VisualStudioVersion)'=='14.0'">v140</PlatformToolset>
<PlatformToolset Condition="'$(VisualStudioVersion)'=='15.0'">v141</PlatformToolset>
```

### <a name="lnk2019-unresolved-external"></a>LNK2019: неразрешенные внешние элементы

Для неразрешенных символов вам может потребоваться исправить параметры проекта.

- Если исходный файл находится в расположении, отличном от расположения по умолчанию, можно ли добавить путь в каталоги включаемых файлов проекта?

- Если внешний элемент определен в LIB-файле, указали ли вы путь к этому файлу в свойствах проекта и находится ли там правильная версия LIB-файла?

- Вы пытаетесь выполнить компоновку с LIB-файлом, скомпилированным с помощью другой версии Visual Studio? Если это так, см. предыдущий раздел о зависимостях наборов инструментов и библиотек.

- Типы аргументов в месте вызова соответствуют существующей перегрузке функции? Проверьте базовые типы для любых определений типов в сигнатуре функции и в коде, вызывающем функцию, что вы ожидаете.

Для устранения неполадок с неразрешенным символом попробуйте использовать dumpbin.exe для изучения символов, определенных в двоичном файле. Попробуйте выполнить следующую команду для просмотра символов, определенных в библиотеке:

```cmd
dumpbin.exe /LINKERMEMBER somelibrary.lib
```

### <a name="zcwchar_t-wchar_t-is-native-type"></a>/Zc:wchar_t (wchar_t – это собственный тип)

(В Microsoft Visual C++ 6,0 и более ранних версиях **wchar_t** не был реализован как встроенный тип, но был объявлен в WCHAR. h как typedef для неподписанного короткого имени.) Стандарт C++ требует, чтобы **wchar_t** был встроенным типом. Использование версии определения типа может вызывать проблемы переносимости. Если при обновлении с более ранней версии Visual Studio возникает ошибка компилятора C2664 в связи с тем, что код пытается выполнить неявное преобразование типа **wchar_t** в тип **unsigned short**, рекомендуется изменить код, чтобы устранить ошибку, но не менять значение параметра `/Zc:wchar_t-`. Дополнительные сведения см. в разделе [/Zc:wchar_t (wchar_t — это собственный тип)](../build/reference/zc-wchar-t-wchar-t-is-native-type.md).

### <a name="upgrading-with-the-linker-options-nodefaultlib-entry-and-noentry"></a>Обновление при использовании параметров компоновщика /NODEFAULTLIB, /ENTRY и /NOENTRY

Параметр компоновщика `/NODEFAULTLIB` (или свойство компоновщика "Игнорировать все стандартные библиотеки") указывает компоновщику не выполнять автоматическую компоновку в библиотеках по умолчанию, таких как CRT. Это означает, что каждую библиотеку нужно отдельно указать в качестве входных данных. Этот список библиотек представлен в свойстве **Дополнительные зависимости** в разделе **Компоновщик** диалогового окна **Свойства проекта**.

Проекты, использующие этот параметр, вызывают проблемы при обновлении, связанные с рефакторингом содержимого некоторых библиотек по умолчанию. Так как требуется указать каждую библиотеку в свойстве **Дополнительные зависимости** или в командной строке компоновщика, нужно обновить список библиотек, чтобы использовать все актуальные имена.

В следующей таблице приведены библиотеки, содержимое которых было изменено начиная с Visual Studio 2015. Для обновления нужно добавить новые имена библиотек во второй столбец к библиотекам в первом столбце. Некоторые из этих библиотек являются библиотеками импорта, но они не должны иметь значения.

|||
|-|-|
|При использовании:|Вам потребуется использовать следующие библиотеки:|
|LIBCMT.lib|libcmt.lib, libucrt.lib, libvcruntime.lib|
|libcmtd.lib|libcmtd.lib, libucrtd.lib, libvcruntimed.lib|
|msvcrt.lib|msvcrt.lib, ucrt.lib, vcruntime.lib|
|msvcrtd.lib|msvcrtd.lib, ucrtd.lib, vcruntimed.lib|

Аналогичная проблема возникает и при использовании параметра `/ENTRY` или `/NOENTRY`, которые также позволяют обойти библиотеки по умолчанию.

## <a name="errors-due-to-improved-language-conformance"></a>Ошибки, вызванные улучшенным соответствием языку

Доработка компилятора Microsoft C++, призванная улучшить его соответствие стандарту C++, ведется уже много лет. Код, скомпилированный в предыдущих версиях, может не компилироваться в более поздних версиях Visual Studio, так как теперь компилятор корректно выдает ошибку, которую ранее игнорировал либо явно допускал.

Например, параметр `/Zc:forScope` появился в MSVC уже очень давно. Он разрешает несоответствующее поведение для переменных цикла. Теперь этот параметр является нерекомендуемым и может быть удален в будущих версиях. Настоятельно рекомендуется не использовать этот параметр при обновлении кода. Дополнительные сведения см. в разделе [/Zc:forScope использовать не рекомендуется](porting-guide-spy-increment.md#deprecated_forscope).

Одним из примеров распространенных ошибок компилятора, с которыми можно столкнуться при обновлении, является передача неконстантного аргумента в константный параметр. Более старые версии компилятора не всегда считали это ошибкой. Дополнительные сведения см. в разделе [Более строгие преобразования компилятора](porting-guide-spy-increment.md#stricter_conversions).

Дополнительные сведения о конкретных улучшениях соответствия см. в разделах [Журнал изменений Visual C++ 2003–2015](visual-cpp-change-history-2003-2015.md) и [Улучшения соответствия C++ в Visual Studio](../overview/cpp-conformance-improvements.md).

## <a name="errors-involving-stdinth-integral-types"></a>Ошибки, связанные с \<stdint.h> целочисленными типами

\<stdint.h>Заголовок определяет определения типов и макросов, которые, в отличие от встроенных целочисленных типов, гарантированно имеют определенную длину на всех платформах. Примеры: `uint32_t` и `int64_t`. \<stdint.h>Заголовок был добавлен в Visual Studio 2010. Код, написанный до 2010, мог предоставить закрытые определения для этих типов, и эти определения могут не всегда соответствовать \<stdint.h> определениям.

Если возникает ошибка C2371, связанная с типом `stdint`, это, скорее всего, означает, что тип определен в заголовке — либо в коде, либо в LIB-файле стороннего разработчика. При обновлении следует удалить все пользовательские определения \<stdint.h> типов, но сначала сравнить пользовательские определения с текущими стандартными определениями, чтобы убедиться в отсутствии новых проблем.

Можно нажать клавишу **F12** (**Переход к определению**), чтобы узнать, где определен тип вопроса.

При этом может пригодиться параметр компилятора [/showIncludes](../build/reference/showincludes-list-include-files.md). В диалоговом окне **Страницы свойств** проекта откройте страницу **C/C++** > **Дополнительно** и задайте для параметра **Показывать включаемые файлы** значение **Да**. Затем перестройте проект и просмотрите список `#include` в окне вывода. Каждый заголовок отображается с отступом под тем заголовком, который включает его.

## <a name="errors-involving-crt-functions"></a>Ошибки, связанные с функциями CRT

За прошедшие годы в среду выполнения C было внесено множество изменений. Были добавлены многие безопасные версии функций, а некоторые были удалены. Кроме того, как было сказано ранее в этой статье, реализация CRT в Visual Studio 2015 была оптимизирована в новых двоичных файлах и связанных lib-файлах.

Если ошибка связана с функцией CRT, обратитесь к разделу [Журнал изменений Visual C++ 2003–2015](visual-cpp-change-history-2003-2015.md) или [Улучшения соответствия C++ в Visual Studio](../overview/cpp-conformance-improvements.md) для поиска дополнительной информации. Если возникла ошибка LNK2019, связанная с неразрешенными внешними элементами, убедитесь, что соответствующая функция не была удалена. Если вы уверены, что функция по-прежнему существует, а вызывающий код является правильным, проверьте, использует ли проект параметр `/NODEFAULTLIB`. Если это так, нужно обновить список библиотек, чтобы проект использовал новые универсальные библиотеки (UCRT). Дополнительные сведения см. в разделе о библиотеках и зависимостях выше.

Если ошибка связана с `printf` или `scanf`, убедитесь, что не применяется частное определение любой из этих функций без включения stdio.h. Если оно имеет место, удалите все частные определения или связь с legacy\_stdio\_definitions.lib. Эту библиотеку можно указать в свойстве **Дополнительные зависимости**, находящемся в разделе **Свойства конфигурации** > **Компоновщик** > **Входные данные** диалогового окна **Страницы свойств**. Если вы выполняете компоновку с использованием пакета Windows SDK 8.1 или более ранней версии, добавьте legacy\_stdio\_definitions.lib.

Если ошибка связана с аргументами строки форматирования, вероятно, это вызвано тем, что компилятор строже соответствует стандарту. Дополнительные сведения см. в журнале изменений. Отнеситесь к указанным здесь ошибкам с особым вниманием, так как они могут представлять угрозу безопасности.

## <a name="errors-due-to-changes-in-the-c-standard"></a>Ошибки, вызванные изменениями в стандарте C++

Путь развития самого стандарта C++ не всегда подразумевает обратную совместимость. Введение семантики перемещения C++11, новых ключевых слов и других функций языка и стандартных библиотек потенциально может привести к ошибкам компилятора и даже иному поведению во время выполнения.

Например, старая программа C++ может включать заголовок iostream.h. Этот заголовок C++ был признан нерекомендуемым уже довольно давно и был полностью удален из Visual Studio. В этом случае необходимо будет использовать \<iostream> и переписать код. Дополнительные сведения см. в статье [Обновление старого кода iostream](porting-guide-spy-increment.md#updating_iostreams_code).

### <a name="c4838-narrowing-conversion-warning"></a>C4838: предупреждение о сужающих преобразованиях

Теперь стандарт языка C++ указывает, что преобразования целочисленных значений без знака в значения с знаком считаются сужающими преобразованиями. До Visual Studio 2015 компилятор не выдавал подобное предупреждение. Проверьте каждое вхождение, чтобы убедиться, что подобное сужение не влияет на правильность работы кода.

## <a name="warnings-to-use-secure-crt-functions"></a>Предупреждения об использовании безопасных функций CRT

Постепенно стали появляться безопасные версии функций для среды выполнения C. Хотя старые небезопасные версии по-прежнему доступны, рекомендуется изменить код, чтобы использовать безопасные версии. При наличии небезопасных версий компилятор выдает предупреждение. Вы можете отключить или игнорировать эти предупреждения. Чтобы отключить предупреждение для всех проектов в решении, откройте **представление**  >  **Диспетчер свойств**, выберите все проекты, для которых необходимо отключить предупреждение, затем щелкните правой кнопкой мыши выбранные элементы и выберите пункт **Свойства**. В разделе **Свойства конфигурации** > **C/C++** > **Дополнительно** диалогового окна **Страницы свойств** выберите **Отключить некоторые предупреждения**. Щелкните стрелку раскрывающегося списка и выберите пункт **изменить**. Введите 4996 в текстовом поле. (Не включайте префикс "C".) Дополнительные сведения см. в разделе [Перенос для использования безопасной CRT](porting-guide-spy-increment.md#porting_to_secure_crt).

## <a name="errors-due-to-changes-in-windows-apis-or-obsolete-sdks"></a>Ошибки, вызванные изменениями в API Windows или устаревших пакетах SDK

Со временем в среду добавлялись новые API Windows и типы данных, а также изменялись или удалялись уже существующие. Кроме того, добавлялись и удалялись другие пакеты SDK, не относящиеся к базовой операционной системе. Таким образом, старые программы могут содержать вызовы несуществующих API. Они также могут содержать вызовы API в других пакетах SDK корпорации Майкрософт, которые больше не поддерживаются. Если возникает ошибка, связанная с API Windows или API из старого пакета SDK корпорации Майкрософт, возможно, что эти API были удалены или заменены на новые, более безопасные функции.

Дополнительные сведения о текущем наборе API и минимально поддерживаемых операционных системах для конкретного API Windows см. в статье [индекс API для приложений Windows для настольных систем](/windows/win32/apiindex/api-index-portal) и перейдите к рассматриваемому API.

### <a name="windows-version"></a>Версия Windows

При обновлении программы, прямо или косвенно использующей API Windows, потребуется выбрать минимальную поддерживаемую версию Windows. В большинстве случаев оптимальным выбором является Windows 7. Дополнительные сведения см. в разделе [Проблемы с файлами заголовков](porting-guide-spy-increment.md#header_file_problems). Макрос `WINVER` определяет самую старую версию Windows, в которой ваша программа может выполняться. Если ваша программа MFC задает для WINVER значение 0x0501 (Windows XP), вы получите предупреждение, так как MFC больше не поддерживает выпуск XP, хотя сам компилятор и имеет режим XP.

Дополнительные сведения см. в разделах [Обновление целевой версии Windows](porting-guide-spy-increment.md#updating_winver) и [Более устаревшие файлы заголовков](porting-guide-spy-increment.md#outdated_header_files).

## <a name="atl--mfc"></a>ATL/MFC

ATL и MFC являются относительно стабильными API, однако и в них периодически вносятся изменения. Дополнительные сведения см. в разделе [Журнал изменений Visual C++ 2003–2015](visual-cpp-change-history-2003-2015.md), а также в разделах [Новые возможности Visual C++ в Visual Studio](../overview/what-s-new-for-visual-cpp-in-visual-studio.md) и [Улучшения соответствия C++ в Visual Studio](../overview/cpp-conformance-improvements.md).

### <a name="lnk-2005-_dllmain12-already-defined-in-msvcrtdlib"></a>LNK 2005 _DllMain@12 уже определен в MSVCRTD.lib

Эта ошибка может возникать в приложениях MFC. Она указывает на проблему очередности между библиотекой CRT и библиотеки MFC. Сначала нужно связывать MFC, чтобы она предоставляла операторы new и delete. Чтобы устранить ошибку, используйте параметр `/NODEFAULTLIB` для пропуска этих библиотек по умолчанию: MSVCRTD.lib и mfcs140d.lib. Затем добавьте эти библиотеки в качестве дополнительных зависимостей.

## <a name="32-vs-64-bit"></a>32-разрядные и 64-разрядные версии

Если исходный код скомпилирован для 32-разрядных систем, вы можете создать 64-разрядную версию приложения вместо 32-разрядной или в дополнение к ней. В общем случае следует сначала скомпилировать программу в 32-разрядном режиме, а затем попробовать 64-разрядный режим. Компиляция в 64-разрядном режиме не вызывает трудностей, однако в некоторых случаях может выявлять ошибки, скрытые в 32-разрядных сборках.

Кроме того, следует помнить о возможных проблемах во время компиляции и выполнения, связанных с размером указателя, значениями времени и размера, а также описателями формата в функциях printf и scanf. Дополнительные сведения см. в разделах [Настройка Visual C++ для 64-разрядных целевых объектов с архитектурой x64](../build/configuring-programs-for-64-bit-visual-cpp.md) и [Общие вопросы использования Visual C++ для 64-разрядных систем](../build/common-visual-cpp-64-bit-migration-issues.md). Дополнительные советы по миграции см. в [руководстве по программированию для 64-разрядных версий Windows](/windows/win32/WinProg64/programming-guide-for-64-bit-windows).

## <a name="unicode-vs-mbcsascii"></a>Юникод и MBCS/ASCII

До стандартизации Юникода для представления символов, не включенных в набор символов ASCII, многие программы использовали многобайтовую кодировку (MBCS). В старых проектах MFC кодировка MBCS использовалась по умолчанию, поэтому при обновлении такой программы выводятся предупреждения, где рекомендуется использовать Юникод. Вы можете отключить или проигнорировать такое предупреждение, если считаете переход на Юникод нецелесообразным. Чтобы отключить его для всех проектов в решении, откройте **представление**  >  **Диспетчер свойств**, выберите все проекты, для которых необходимо отключить предупреждение, затем щелкните правой кнопкой мыши выбранные элементы и выберите пункт **Свойства**. В диалоговом окне **Страницы свойств** выберите **Свойства конфигурации** > **C/C++** > **Дополнительно**. Откройте раскрывающийся список в свойстве **Отключить некоторые предупреждения** и выберите **Изменить**. Введите 4996 в текстовом поле. (Не включайте префикс "C".) Нажмите кнопку **ОК** , чтобы сохранить свойство, а затем нажмите кнопку **ОК** , чтобы сохранить изменения.

Дополнительные сведения см. в разделе [Перенос из MBCS в Юникод](porting-guide-spy-increment.md#porting_to_unicode). Общие сведения о MBCS и Unicode см. в разделе [текст и строки в Visual C++](../text/text-and-strings-in-visual-cpp.md) и [интернационализации](../c-runtime-library/internationalization.md) .

## <a name="see-also"></a>См. также раздел

[Обновление проектов с более ранних версий Visual C++](upgrading-projects-from-earlier-versions-of-visual-cpp.md)<br/>
[Улучшения соответствия C++ в Visual Studio](../overview/cpp-conformance-improvements.md)
