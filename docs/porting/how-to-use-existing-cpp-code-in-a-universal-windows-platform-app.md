---
title: Практическое руководство. Использование существующего кода C++ в приложении универсальной платформы Windows
ms.date: 04/08/2019
ms.assetid: 87e5818c-3081-42f3-a30d-3dca2cf0645c
ms.openlocfilehash: 5050a9773eea55549958195efa624743f44ed031
ms.sourcegitcommit: 9d4ffb8e6e0d70520a1e1a77805785878d445b8a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2019
ms.locfileid: "69630429"
---
# <a name="how-to-use-existing-c-code-in-a-universal-windows-platform-app"></a>Практическое руководство. Использование существующего кода C++ в приложении универсальной платформы Windows

Возможно, самым простым способом запуска классической программы в среде универсальной платформы Windows (UWP) является использование технологий "Мост для классических приложений". К ним относится Desktop App Converter, позволяющий преобразовывать имеющиеся классические приложения в приложения универсальной платформы Windows (UWP) без изменения кода. Дополнительные сведения см. в статье [Мост для классических приложений](/windows/uwp/porting/desktop-to-uwp-root).

В остальной части этого раздела описывается процедура переноса библиотек C++ (библиотек DLL и статических библиотек) на универсальную платформу Windows. Это можно сделать, чтобы использовать основную логику C++ в нескольких приложениях UWP.

Приложения UWP выполняются в защищенной среде, в результате чего многие вызовы Win32, COM и API CRT, которые могут нарушить безопасность платформы, запрещены. Компилятор может обнаруживать такие вызовы и формировать ошибки, если используется параметр `/ZW`. Для выявления кода, который вызывает запрещенные API, используется набор сертификации приложений. Дополнительные сведения см. в разделе [Тесты комплекта сертификации приложений для Windows](/windows/uwp/debug-test-perf/windows-app-certification-kit).

Если исходный код доступен для библиотеки, можно исключить запрещенные вызовы API. Дополнительные сведения, включая список разрешенных или запрещенных интерфейсов API, см. в статьях [API Win32 и COM для приложений UWP](/uwp/win32-and-com/win32-and-com-for-uwp-apps) и [Функции CRT, которые не поддерживаются в приложениях универсальной платформы Windows](../cppcx/crt-functions-not-supported-in-universal-windows-platform-apps.md). Некоторые альтернативные решения можно найти в статье [Альтернативы Windows API для приложений среды выполнения Windows](/uwp/win32-and-com/alternatives-to-windows-apis-uwp).

При попытке добавить ссылку из универсального проекта Windows в классическую библиотеку настольной системы появится сообщение об ошибке, информирующее о несовместимости библиотеки. При использовании статической библиотеки можно создать ссылку на библиотеку, просто добавив библиотеку (LIB-файл) во входные данные компоновщика так же, как в классическом приложении Win32. Это единственный вариант для библиотек, где доступен только двоичный файл. Статическая библиотека связана в исполняемом файле приложения, но библиотека DLL Win32, используемая в приложении UWP, должна быть упакована в приложение путем включения в проект и пометки как содержимого. Для загрузки DLL-библиотеки Win32 в приложении UWP необходимо также вызвать [LoadPackagedLibrary](/windows/win32/api/winbase/nf-winbase-loadpackagedlibrary) вместо `LoadLibrary` или `LoadLibraryEx`.

При наличии исходного кода для библиотеки DLL или статической библиотеки можно выполнить перекомпиляцию с параметром `/ZW` в виде проекта UWP. После этого можно добавить ссылку с помощью **обозревателя решений** и использовать ее в приложениях UWP на C++. В случае с DLL осуществляется связь с библиотекой экспорта.

Чтобы сделать функциональные возможности доступными вызывающим объектам на других языках, библиотеку можно преобразовать в компонент среды выполнения Windows. Компоненты среды выполнения Windows отличаются от обычных библиотек DLL тем, что они содержат метаданные в виде WINMD-файлов, которые описывают содержимое так, как это требуется потребителям .NET и JavaScript. Чтобы предоставить элементы API на других языках, можно добавить конструкции C++/CX, такие как ссылочные классы, и сделать их общедоступными либо использовать [библиотеку шаблонов C++ среды выполнения Windows (WRL)](../windows/windows-runtime-cpp-template-library-wrl.md).  В Windows 10 и более поздних версиях вместо C++/CX можно использовать [библиотеку C++/WinRT](https://github.com/microsoft/cppwinrt).

Вышесказанное не распространяется на использование COM-компонентов, которые должны обрабатываться другим образом. Если в EXE или DLL имеется COM-сервер, его можно использовать в универсальном проекте Windows до тех пор, пока он не будет упакован как [не требующий регистрации COM-компонент](/windows/win32/sbscs/creating-registration-free-com-objects). Его можно добавить в проект как файл содержимого и создать его с помощью [CoCreateInstanceFromApp](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstancefromapp). Дополнительные сведения см. в статье [Использование DLL без COM в проекте C++ для Магазина Windows](https://blogs.msdn.microsoft.com/win8devsupport/2013/05/19/using-free-com-dll-in-windows-store-c-project/).

Если необходимо портировать на UWP существующую библиотеку COM, вы можете попробовать преобразовать ее в компонент среды выполнения Windows с помощью [библиотеки шаблонов C++ среды выполнения Windows (WRL)](../windows/windows-runtime-cpp-template-library-wrl.md). WRL не поддерживает все возможности ATL и OLE, поэтому целесообразность такого переноса зависит от того, какому объему кода COM требуются определенные возможности COM, ATL и OLE.

Существуют различные способы использования существующего кода C++ в проектах UWP. В некоторых из них не требуется выполнять перекомпиляцию кода с включенными расширениями компонентов (C++/CX) (то есть с параметром `/ZW`), тогда как в других это является необходимостью. Поэтому, чтобы сохранить код на стандартном C++ или сохранить классическую среду компиляции Win32 для определенного кода, это можно сделать с выбором соответствующей архитектуры. Например, весь код, содержащий пользовательский интерфейс и типы UWP, которые будут предоставляться вызывающим объектам C#, Visual Basic и JavaScript, должен находиться в проектах приложений Windows и проектах компонентов среды выполнения Windows. Код, который должен использоваться только в коде на C++ (включая C++/CX), может быть либо в проекте, компилируемом с параметром `/WX`, либо в стандартном проекте C++. Код только для двоичного файла используется путем связывания в качестве статической библиотеки или упаковывается с приложением качестве содержимого и загружается в библиотеку DLL только при отсутствии запрещенных интерфейсов API.

Независимо от выбранного сценария разработки следует учитывать ряд определений макросов, которые можно использовать в коде для его последующей условной компиляции под классические приложения Win32 и UWP.

```cpp
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PC_APP)
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
```

Эти операторы могут применяться соответственно к приложениям UWP, приложениям Магазина Windows Phone, к обоим видам приложений или ни к одному из них (то есть, только к классическим приложениям Win32). Эти макросы доступны только в пакете SDK Windows 8.1 и более поздних версиях. Поэтому если код должен компилироваться в более ранних версиях пакета SDK Windows или для других платформ, помимо Windows, необходимо учитывать ситуацию, в которой не определена ни одна их этих возможностей.

В этом разделе описываются следующие процедуры.

- [Использование DLL-библиотеки Win32 в приложении UWP](#BK_Win32DLL)

- [Использование собственной статической библиотеки C++ в приложении UWP](#BK_StaticLib)

- [Перенос библиотеки C++ в компонент среды выполнения Windows](#BK_WinRTComponent)

##  <a name="BK_Win32DLL"></a> Использование DLL-библиотеки Win32 в приложении UWP

В целях повышения безопасности и надежности универсальные приложения Windows работают в среде выполнения с ограниченным доступом, поэтому здесь способ использования собственных библиотек DLL отличается от использования в классическом настольном приложении Windows. Исходный код для библиотеки DLL можно перенести для выполнения на платформе UWP. Сначала следует изменить несколько параметров проекта и метаданных файла проекта, чтобы определять проект как проект UWP. Необходимо скомпилировать код библиотеки с помощью параметра `/ZW` для активации C++/CX. В приложениях UWP запрещены некоторые вызовы API. Это связано с более строгим уровнем управления этой средой. См. раздел [API Win32 и COM для приложений UWP](/uwp/win32-and-com/win32-and-com-for-uwp-apps).

Следующая процедура применяется при наличии собственной библиотеки DLL, предоставляющей функции с использованием `__declspec(dllexport)`.

### <a name="to-port-a-native-dll-to-the-uwp-without-creating-a-new-project"></a>Перенос собственной библиотеки DLL на UWP без создания нового проекта

1. При наличии собственной библиотеки DLL, которая экспортирует функции с помощью `__declspec(dllexport)`, эти функции можно вызывать из приложения UWP путем повторной компиляции библиотеки DLL как проекта UWP. В качестве примера предположим, что у нас есть библиотека DLL, которая экспортирует несколько классов и их методов с кодом, похожим на следующий файл заголовка:

    ```cpp
    // giraffe.h
    #pragma once

    #ifdef _DLL
    #define GIRAFFE_API __declspec(dllexport)
    #else
    #define GIRAFFE_API
    #endif

    GIRAFFE_API int giraffeFunction();

    class Giraffe
    {
        int id;
            Giraffe(int id_in);
        friend class GiraffeFactory;

    public:
        GIRAFFE_API int GetID();
    };

    class GiraffeFactory
    {
        static int nextID;

    public:
        GIRAFFE_API GiraffeFactory();
        GIRAFFE_API static int GetNextID();
        GIRAFFE_API static Giraffe* Create();
    };
    ```

   И следующий файл кода:

    ```cpp
    // giraffe.cpp
    #include "stdafx.h"
    #include "giraffe.h"

    Giraffe::Giraffe(int id_in) : id(id_in)
    {
    }

    int Giraffe::GetID()
    {
      return id;
    }

    int GiraffeFactory::nextID = 0;

    GiraffeFactory::GiraffeFactory()
    {
        nextID = 0;
    }

    int GiraffeFactory::GetNextID()
    {
        return nextID;
    }

    Giraffe* GiraffeFactory::Create()
    {
        return new Giraffe(nextID++);
    }

    int giraffeFunction();
    ```

   Все остальное в проекте (stdafx.h, dllmain.cpp) является частью стандартного шаблона проекта Win32. Если вы хотите продолжать процедуру, но пока не хотите использовать собственные библиотеки DLL, создайте проект Win32, выберите DLL в мастере проектов, добавьте файл заголовка giraffe.h и файл кода giraffe.cpp и скопируйте содержимое из кода на этом шаге в соответствующие файлы.

   Код определяет макрос `GIRAFFE_API`, который разрешается в `__declspec(dllexport)`, когда определяется `_DLL` (то есть, когда сборка проекта осуществляется в виде DLL-библиотеки).

2. Откройте окно **свойств проекта** для проекта DLL и задайте свойству **Конфигурация** значение **Все конфигурации**.

3. В **свойствах проекта** на вкладке **C/C++**  > **Общие** установите значение **Да (/ZW)** для параметра **Использовать расширение среды выполнения Windows**. Будут включены расширения компонента (C++/CX).

4. В **обозревателе решений** выберите узел проекта, откройте контекстное меню и выберите **Выгрузить проект**. Затем откройте контекстное меню узла выгруженного проекта и выберите команду редактирования файла проекта. Найдите элемент `WindowsTargetPlatformVersion` и замените его на следующие элементы.

    ```xml
    <AppContainerApplication>true</AppContainerApplication>
    <ApplicationType>Windows Store</ApplicationType>
    <WindowsTargetPlatformVersion>10.0.10156.0</WindowsTargetPlatformVersion>
    <WindowsTargetPlatformMinVersion>10.0.10156.0</WindowsTargetPlatformMinVersion>
    <ApplicationTypeRevision>10.0</ApplicationTypeRevision>
    ```

   Закройте файл с расширением VCXPROJ, снова откройте контекстное меню и выберите **Перезагрузить проект**.

   Теперь **обозреватель решений** идентифицирует проект как универсальный проект Windows.

5. Убедитесь, что файл предкомпилированного заголовка имеет правильное имя. В разделе **Предварительно скомпилированные заголовки** измените **файл предварительно скомпилированного заголовка** с *pch.h* на *stdafx.h*. Если этого не сделать, может появиться следующее сообщение об ошибке.

   > Ошибка C2857: "Выражение "#include", заданное с помощью параметра командной строки /Ycpch.h, не найдено в исходном файле".

   Проблема заключается в том, что в универсальных проектах Windows используются другие правила именования для предкомпилированного файла заголовка.

6. Выполните построение проекта. Возможно, появятся сообщения об ошибках, связанных с несовместимыми параметрами командной строки. Например, нерекомендуемый сейчас, но часто используемый ранее параметр **Включить минимальное перестроение (/Gm)** задан по умолчанию во многих старых проектах C++ и не совместим с параметром `/ZW`.

   Во время компиляции для универсальной платформы Windows некоторые функции оказываются недоступны. Компилятор сообщит о любых проблемах. Их необходимо устранить. В результате вы получите чистую сборку.

7. Чтобы использовать библиотеку DLL в приложении UWP в том же решении, откройте контекстное меню узла проекта UWP и выберите **Добавить** > **Ссылка**.

   В разделе **Проекты** > **Решение** установите флажок для проекта DLL и нажмите кнопку **ОК**.

8. Включите файл(ы) заголовка библиотеки в файл *pch.h* приложения UWP.

    ```cpp
    #include "..\MyNativeDLL\giraffe.h"
    ```

9. Обычным способом добавьте код в проекте UWP, чтобы вызывать функции и создавать типы из библиотеки DLL.

    ```cpp
    MainPage::MainPage()
    {
        InitializeComponent();
        GiraffeFactory gf;
        Giraffe* g = gf.Create();
        int id = g->GetID();
    }
    ```

##  <a name="BK_StaticLib"></a> Использование собственной статической библиотеки C++ в приложении UWP

Собственную статическую библиотеку C++ можно использовать в проекте UWP, однако существуют некоторые ограничения, которые необходимо принимать во внимание. Начните с изучения раздела о [статических библиотеках C++/CX](../cppcx/static-libraries-c-cx.md). Доступ к машинному коду в статической библиотеке можно выполнить из приложения UWP, однако в такой библиотеке не рекомендуется создавать открытые ссылочные типы. При компиляции статической библиотеки с параметром `/ZW` библиотекарь (фактически скрытый компоновщик) выводит следующее предупреждение:

> LNK4264: архивирует объектный файл, скомпилированный с параметром /ZW, в статическую библиотеку; обратите внимание, что при создании типов среды выполнения Windows не рекомендуется привязка к статической библиотеке, содержащей метаданные среды выполнения Windows

Тем не менее статическую библиотеку можно использовать в UWP без повторной компиляции с параметром `/ZW`. Вы не сможете объявлять ссылочные типы или использовать конструкции C++/CX. Но если вашей целью является простое использование библиотеки машинного кода, это можно сделать, выполнив следующие действия.

### <a name="to-use-a-native-c-static-library-in-a-uwp-project"></a>Использование собственной статической библиотеки C++ в проекте UWP

1. В разделе свойств проекта UWP в области слева последовательно выберите **Свойства конфигурации** > **Компоновщик** > **Ввод**. В области справа добавьте путь к библиотеке в свойстве **Дополнительные зависимости**. Например, для библиотеки в проекте, которая помещает выходные данные в *папка_решения*\Debug\MyNativeLibrary\MyNativeLibrary.lib, добавьте относительный путь `Debug\MyNativeLibrary\MyNativeLibrary.lib`.

2. Добавьте выражение include для ссылки на файл заголовка в *pch.h* (при наличии) или в любой CPP-файл, если это требуется, и приступите к добавлению кода, использующего библиотеку.

   ```cpp
   #include "..\MyNativeLibrary\giraffe.h"
   ```

   Не добавляйте ссылки в узел **Ссылки** в **обозревателе решений**. Этот механизм работает только для компонентов среды выполнения Windows.

##  <a name="BK_WinRTComponent"></a> Перенос библиотеки C++ в компонент среды выполнения Windows

Если требуется использовать собственные интерфейсы API в статической библиотеке из приложения UWP и имеется исходный код для собственной библиотеки, можно перенести код в компонент среды выполнения Windows. Вместо статической библиотеки будет существовать библиотека DLL. Ее можно использовать в любом приложении UWP на C++, но в отличие от статической библиотеки появится возможность добавления ссылочных типов и других конструкций C ++/CX, которые доступны клиентам в любом коде приложения UWP независимо от языка. Таким образом, эти типы доступны из C#, Visual Basic или JavaScript.  Основная процедура заключается в создании проекта "Компонент среды выполнения Windows", копировании в него кода для статической библиотеки и исправлении ошибок, возникающих в связи с перемещением кода из стандартной компиляции C++ в компиляцию `/ZW`.

### <a name="to-port-a-c-library-to-a-windows-runtime-component"></a>Перенос библиотеки C++ в компонент среды выполнения Windows

1. Создайте проект "Компонент среды выполнения Windows".

2. Закройте проект.

3. В **проводнике Windows** найдите проект. По умолчанию Visual Studio использует папку Visual Studio 2017\Projects в папке "Документы". Найдите проект библиотеки C++, который содержит код, который нужно перенести. Скопируйте исходные файлы (файлы заголовков, файлы кода и другие ресурсы, включая находящиеся в подкаталогах) из проекта библиотеки C++ и вставьте их в папку проекта, сохранив структуру папок.

4. Повторно откройте проект "Компонент среды выполнения Windows", в **обозревателе решений** откройте контекстное меню для узла проекта и выберите **Добавить** > **Существующий элемент**.

5. Выберите все файлы, которые будут добавлены из исходного проекта, и нажмите кнопку **ОК**. При необходимости повторите эти действия для вложенных папок.

6. На этом этапе может появиться повторяющийся код. Если имеется несколько предварительно скомпилированных заголовков (например, *stdafx.h* и *pch.h*), выберите один, который будет сохранен. В него скопируйте необходимый код, например выражения include. Затем удалите другой и в окне свойств проекта в разделе **Предкомпилированные заголовки** проверьте правильность имени файла заголовка.

   Если файл был изменен для использования в качестве предкомпилированного заголовка, убедитесь в правильности параметров предкомпилированных заголовков для каждого файла. По очереди выберите каждый CPP-файл, откройте его окно свойств и убедитесь, что все параметры имеют значение **Использовать (/Yu)** . Нужному предкомпилированному заголовку должно быть задано значение **Создать (/Yc)** .

7. Постройте проект и устраните все ошибки. Причиной этих ошибок может быть использование параметра `/ZW`, они могут быть связаны с новой версией пакета SDK Windows, они могут отражать зависимости, такие как файлы заголовков, от которых зависит библиотека, или различия в параметрах нового и старого проектов.

8. Добавьте в проект открытые ссылочные типы или преобразуйте обычные типы в ссылочные, чтобы указать точки входа в функциональные возможности, которые требуется вызвать из приложений UWP.

9. Протестируйте компонент, добавив ссылку на него из проекта приложения UWP, и добавьте код для вызова созданных открытых API.

## <a name="see-also"></a>См. также

[Перенос на универсальную платформу Windows](../porting/porting-to-the-universal-windows-platform-cpp.md)
