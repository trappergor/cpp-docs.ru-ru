---
title: 'Tn026: процедуры DDX и DDV подпрограммы | Документы Microsoft'
ms.custom: ''
ms.date: 06/28/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- DDX
- DDV
dev_langs:
- C++
helpviewer_keywords:
- DDX (dialog data exchange), procedures
- TN026
- DDV (dialog data validation), procedures
ms.assetid: c2eba87a-4b47-4083-b28b-e2fa77dfb4c4
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 91b5d1a770dfd26db96b71179d3775003d7205c4
ms.sourcegitcommit: 208d445fd7ea202de1d372d3f468e784e77bd666
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/29/2018
ms.locfileid: "37122932"
---
# <a name="tn026-ddx-and-ddv-routines"></a>TN026. Процедуры DDX и DDV

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает архитектуру обмена данными (DDX) и проверки данных (DDV) диалоговых окон. Она также описывает, как создавать процедуры DDX_ или DDV_ и как можно расширить ClassWizard для использования ваших процедур.

## <a name="overview-of-dialog-data-exchange"></a>Общие сведения об обмене данными диалоговых окон

Все функции работы с данными диалогового окна выполняются в коде C++. Никаких специальных ресурсов или магических макросов не требуется. Основа механизма — это виртуальная функция, которая переопределяется в каждом классе диалогового окна, осуществляющего обмен данными и их проверку. Она всегда представлена в такой форме:

```cpp
void CMyDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);   // call base class

    //{{AFX_DATA_MAP(CMyDialog)
        <data_exchange_function_call>
        <data_validation_function_call>
    //}}AFX_DATA_MAP
}
```

Комментарии специального формата AFX позволяют мастеру ClassWizard искать и редактировать код в рамках данной функции. Код, который не совместим с ClassWizard, должен располагаться за пределами этих комментариев специального формата.

В приведенном выше примере < data_exchange_function_call > находится в форме:

```cpp
DDX_Custom(pDX, nIDC, field);
```

и < data_validation_function_call > является необязательным и находится в форме:

```cpp
DDV_Custom(pDX, field, ...);
```

Каждая функция `DoDataExchange` может включать несколько пар DDX_/DDV_.  

Список всех подпрограмм обмена данными и проверки данных диалоговых окон в MFC находится в файле "afxdd_.h".

Данные диалогового окна, является: данные-члены в `CMyDialog` класса. Они не хранятся в структуре или чем-то подобном.  

## <a name="notes"></a>Примечания

Несмотря на то, что мы называем это "данные диалогового окна", все функции доступны в любом классе, производном от `CWnd`, и не ограничиваются только диалоговыми окнами.

Начальные значения данных задаются в обычном конструкторе C++, обычно в блоке между комментариями `//{{AFX_DATA_INIT` и `//}}AFX_DATA_INIT`.

`CWnd::UpdateData` это операция, которая выполняет инициализацию и обработку ошибок вокруг вызова `DoDataExchange`.

Вы можете в любое время вызывать `CWnd::UpdateData` для выполнения обмена данными и их проверки. По умолчанию `UpdateData`(TRUE) вызывается в стандартной реализации обработчика `CDialog::OnOK`, а `UpdateData`(FALSE) вызывается в стандартной реализации `CDialog::OnInitDialog`.

Подпрограмма DDV_ должна следовать непосредственно за подпрограммой DDX_ для этого *поля*.

## <a name="how-does-it-work"></a>Как это работает

Чтобы использовать данные диалоговых окон, нет необходимости понимать то, что написано ниже. Однако понимание того, как это работает, поможет вам создавать собственные процедуры обмена и проверки.

Функция-член `DoDataExchange` очень похожа на функцию-член `Serialize` — она отвечает за получение и задание данных при взаимодействии между внешними формами (в данном случае элементами управления в диалоговом окне) и данными-членами в классе. *PDX* параметр контекст для выполнения обмена данными и похож на `CArchive` параметр `CObject::Serialize`. *PDX* ( `CDataExchange` объекта) имеет направление флаг подобно проводнику `CArchive` имеет флаг направления:

- Если `!m_bSaveAndValidate`, затем загрузить состояние данных в элементах управления.

- Если `m_bSaveAndValidate`, то необходимо задать состояние данных из элементов управления. 

Проверка происходит только когда `m_bSaveAndValidate` установлено. Значение `m_bSaveAndValidate` определяется параметром BOOL в `CWnd::UpdateData`.

Есть три других интересных элемента `CDataExchange`:

- `m_pDlgWnd`: окно (обычно диалоговое окно), содержащее элементы управления. Этот указатель необходим для того, чтобы объекты, вызывающие глобальные функции DDX_ и DDV_, не передавали "this" каждой подпрограмме DDX/DDV. 

- `PrepareCtrl`, и `PrepareEditCtrl`: подготавливают элементы управления диалогового окна для обмена данными. Сохраняют дескриптор элемента управления для фокусировки на нем, если проверка не пройдена. `PrepareCtrl` используется для элементов управления без редактирования и `PrepareEditCtrl` используется для редактирования.

- `Fail`: Вызывается после переноса выводится сообщение, информирующее пользователя ошибок на входе. Эта процедура приведет к восстановлению фокуса на последний элемент управления (последнего вызова `PrepareCtrl` или `PrepareEditCtrl`) и создает исключение. Эта функция-член может вызываться из подпрограмм DDX_ и DDV_. 

## <a name="user-extensions"></a>Пользовательские расширения

Существует несколько способов для расширения стандартного механизма DDX/DDV. Можно выполнить следующие действия: 

- Добавить новые типы данных. 

    ```cpp
    CTime
    ```

- Добавить новые процедуры обмена (DDX_). 

    ```cpp
    void PASCAL DDX_Time(CDataExchange* pDX, int nIDC, CTime& tm);
    ```

- Добавить новые процедуры проверки (DDV_). 

    ```cpp
    void PASCAL DDV_TimeFuture(CDataExchange* pDX, CTime tm, BOOL bFuture);
    // make sure time is in the future or past
    ```

- Передать произвольные выражения в процедуры проверки.

    ```cpp
    DDV_MinMax(pDX, age, 0, m_maxAge);
    ```

    > [!NOTE]
    > Такие произвольные выражения не могут быть отредактированы мастером ClassWizard, поэтому должны быть перемещены за пределы комментариев в специальном формате (// {{AFX_DATA_MAP(CMyClass)).

У `DoDialogExchange` функции-члена включают условные выражения или любые другие допустимые операторы C++ с смешанные вызовы функций обмена и проверки.

```cpp
//{{AFX_DATA_MAP(CMyClass)
DDX_Check(pDX, IDC_SEX, m_bFemale);
DDX_Text(pDX, IDC_EDIT1, m_age);
//}}AFX_DATA_MAP
if (m_bFemale)
    DDV_MinMax(pDX, age, 0, m_maxFemaleAge);
else
    DDV_MinMax(pDX, age, 0, m_maxMaleAge);
```

> [!NOTE]
> Как указано выше, такой код не может быть отредактирован мастером ClassWizard и должен указываться только за пределами комментариев в специальном формате.

## <a name="classwizard-support"></a>Мастер классов поддержки

Мастер классов (ClassWizard) поддерживает подмножество настроек DDX/DDV, позволяя интегрировать ваши собственные подпрограммы DDX_ и DDV_ в его пользовательский интерфейс. Это может быть полезным, только если планируется повторно использовать определенные процедуры DDX и DDV в текущем проекте или в других проектах.

Чтобы сделать это, необходимо добавить специальные записи в файл DDX.CLW (в предыдущих версиях Visual C++ эти данные хранились в APSTUDIO.INI) или в CLW-файл вашего проекта. Специальные записи могут быть введены в раздел [General Info] файла вашего проекта или в раздел [ExtraDDX] файла DDX.CLW, который находится в папке "\Program Files\Microsoft Visual Studio\Visual C++\bin". Если файл DDX.CLW еще не существует, может потребоваться создать его. Если вы планируете использовать особые подпрограммы DDX_/DDV_ только в определенном проекте, то добавьте записи в раздел [General Info] CLW-файла вашего проекта. Если вы планируете использовать подпрограммы в множестве проектов, добавьте записи в раздел [ExtraDDX] файла DDX.CLW.

Эти специальные записи общие выглядит следующим образом:

> ExtraDDXCount =*n*

где *n* число ExtraDDX? строкам, формы

> ExtraDDX? =*ключей*; *vb ключи*; *строки*; *тип*; *начального значения*; *DDX_Proc* [; *DDV_Proc*; *prompt1*; *arg1* [; *prompt2*; *fmt2*]]

где? Это число 1 - *n* , указывающее, какой тип DDX в списке, который определяется.

Каждое поле отделяется символом «;». Ниже приводится описание полей и их назначение.

- *Ключи*

  Список отдельных символов, указывающее, для которых элементов управления диалоговых окон разрешено переменных этого типа.

  |Знак|Допустимый элемент управления|
  |-|-|
  E | изменение;
  В | два состояния флажка
  c | флажок тремя состояниями
  R | первый переключатель в группе
  L | Возврат неупорядоченного списка
  l | отсортированный список
  M | поле со списком (с изменение элементов)
  в | Возврат неупорядоченного раскрывающийся список
  n | отсортированный раскрывающийся список
  1 | Если вставка DDX должны быть добавлены в заголовке списка (по умолчанию добавить заключительного) обычно используется для подпрограмм DDX, передающие свойство «Доступ».

- *ключи VB*

  Это поле используется только в 16-разрядной версии продукта для элементов управления VBX (элементы управления VBX не поддерживаются в 32-разрядной версии продукта)

- *prompt*

  Строка для размещения в поле со списком свойств (без кавычек)

- *type*

  Один идентификатор типа для передачи в заголовочный файл. В нашем примере выше для DDX_Time устанавливается CTime.

- *ключи VB*

  В этой версии не используется и всегда должно быть пустым.

- *начального значения*

  Начальное значение — 0 или пусто. Если поле пусто, строка инициализации не будет записана в разделе //{{AFX_DATA_INIT файла реализации. Пустую запись следует использовать для объектов C++ (таких как `CString`, `CTime`и так далее), имеющих конструкторы, которые гарантируют правильную инициализацию.

- *DDX_Proc*

  Единый идентификатор процедуры DDX_. Имя функции C++ должно начинаться с "DDX_", но не должно включать "DDX_" в идентификаторе <DDX_Proc>. В приведенном выше примере идентификатором <DDX_Proc> будет Time. Когда ClassWizard записывает вызов функции в файл реализации в раздел {{AFX_DATA_MAP, он добавляет к этому идентификатору префикс DDX_, таким образом получая DDX_Time.

- *comment*

  Комментарий для отображения в диалоговом окне для переменной с этой процедурой DDX. Введите здесь любой желаемый текст; обычно предоставляют текст, описывающий операцию, выполняемую парой DDX/DDV.

- *DDV_Proc*

  Часть записи DDV является необязательной. Не все подпрограммы DDX имеют соответствующие подпрограммы DDV. Часто более удобно включать этап проверки как неотъемлемую часть передачи. Это часто бывает, когда подпрограмма DDV не требует параметров, так как ClassWizard не поддерживает подпрограммы DDV без параметров.

- *arg*

  Единый идентификатор процедуры DDV_. Имя функции C++ должно начинаться с "DDV_", но не должно включать DDX_ в идентификаторе <DDX_Proc>. 

  *arg* следуют args DDV 1 или 2:

   - *promptN*

     Строка для размещения выше изменение элементов (с & для сочетаний клавиш).

   - *fmtN*

     Символ формата для типа arg, один из:

     |Знак|Тип|
     |-|-|
     d | int
     u | unsigned int
     D | Long int (то есть, long)
     U | Long без знака (то есть DWORD)
     f | float
     C | double
     s | string

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)  
[Технические примечания по категории](../mfc/technical-notes-by-category.md)  
