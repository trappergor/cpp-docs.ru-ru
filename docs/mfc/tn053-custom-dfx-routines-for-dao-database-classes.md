---
title: 'TN053: Пользовательские процедуры DFX для DAO базы данных классов | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.mfc.dfx
dev_langs:
- C++
helpviewer_keywords:
- MFC, DAO and
- database classes [MFC], DAO
- DAO [MFC], MFC
- DFX (DAO record field exchange) [MFC], custom routines
- TN053
- DAO [MFC], classes
- DFX (DAO record field exchange) [MFC]
- custom DFX routines [MFC]
ms.assetid: fdcf3c51-4fa8-4517-9222-58aaa4f25cac
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 054ff12e47d2a6bd38d1a51a7745e5b3916c90dc
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46445117"
---
# <a name="tn053-custom-dfx-routines-for-dao-database-classes"></a>TN053. Пользовательские процедуры DFX для классов баз данных DAO

> [!NOTE]
>  Среды Visual C++ и мастерах не поддерживают DAO (хотя классы DAO включены и их по-прежнему можно использовать). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-templates.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.

Это техническое Примечание описывает механизм обмена (DFX) полями записей DAO. Чтобы понять, что происходит в процедуры DFX, `DFX_Text` функции будут рассматриваться в детализации в качестве примера. Как источник дополнительных сведений в этом техническом примечании можно проверить код для других отдельных функций DFX. Возможно, не потребуется пользовательские процедуры DFX так часто, как может потребоваться настраиваемой RFX (используется с ODBC классы баз данных).

Это техническое Примечание содержит:

- Общие сведения о DFX

- [Примеры](#_mfcnotes_tn053_examples) с помощью обмен полями записей DAO и динамическая привязка

- [Как работает DFX](#_mfcnotes_tn053_how_dfx_works)

- [Что делает подпрограмма пользовательских DFX](#_mfcnotes_tn053_what_your_custom_dfx_routine_does)

- [Сведения о DFX_Text](#_mfcnotes_tn053_details_of_dfx_text)

**Общие сведения о DFX**

Механизм обмена полями записей DAO (DFX) используется для упрощения процедуры получения и обновления данных при использовании `CDaoRecordset` класса. Процесс упрощается с помощью данные-члены `CDaoRecordset` класса. Путем наследования от `CDaoRecordset`, данные-члены можно добавить в производный класс, представляющий каждое поле в таблице или запросе. Этот механизм «статической привязки» простой, но может оказаться метод выборки или обновления данных по выбору для всех приложений. DFX извлекает каждый связанному полю каждый раз при изменении текущей записи. Если вы разрабатываете приложение с учетом производительности, которого не требуется получение каждого поля при изменении валюты, «dynamic binding» через `CDaoRecordset::GetFieldValue` и `CDaoRecordset::SetFieldValue` может быть метод доступа к данным по выбору.

> [!NOTE]
>  DFX и динамической привязки не являются взаимоисключающими, чтобы можно было использовать комбинированное использование статической и динамической привязки.

## <a name="_mfcnotes_tn053_examples"></a> Пример 1 — Использование обмен полями записей DAO только

(предполагается, что `CDaoRecordset` — производный класс `CMySet` уже открыт)

```
// Add a new record to the customers table
myset.AddNew();

myset.m_strCustID = _T("MSFT");

myset.m_strCustName = _T("Microsoft");

myset.Update();
```

**Пример 2 — Использование только динамическое связывание**

(предполагается, что с помощью `CDaoRecordset` класс, `rs`, и он уже открыт)

```
// Add a new record to the customers table
COleVariant  varFieldValue1 (_T("MSFT"),
    VT_BSTRT);

//Note: VT_BSTRT flags string type as ANSI,
    instead of UNICODE default
COleVariant  varFieldValue2  (_T("Microsoft"),
    VT_BSTRT);

rs.AddNew();

rs.SetFieldValue(_T("Customer_ID"),
    varFieldValue1);

rs.SetFieldValue(_T("Customer_Name"),
    varFieldValue2);

rs.Update();
```

**Пример 3 — Использование поля записи DAO Exchange и динамическая привязка**

(предполагается, что просмотра данные о сотрудниках с `CDaoRecordset`-производный класс `emp`)

```
// Get the employee's data so that it can be displayed
emp.MoveNext();


// If user wants to see employee's photograph,
// fetch it
COleVariant varPhoto;
if (bSeePicture)
    emp.GetFieldValue(_T("photo"),
    varPhoto);


// Display the data
PopUpEmployeeData(emp.m_strFirstName,
    emp.m_strLastName,
    varPhoto);
```

## <a name="_mfcnotes_tn053_how_dfx_works"></a> Как работает DFX

Механизм DFX работает таким же образом полями записей (RFX) exchange механизм, используемый классами MFC ODBC. Принципы DFX и RFX одинаковы, но имеется множество различий внутренней. Архитектура функций DFX был таким образом, практически весь код является общим для отдельных процедуры DFX. В самый высокий уровень DFX только выполняет несколько задач.

- DFX конструкции SQL **ВЫБЕРИТЕ** предложения и SQL **параметры** предложение, при необходимости.

- DFX создает структуры привязки, используемые в DAO `GetRows` функция (Подробнее об этом чуть позже).

- DFX управляет буфером данных, используемый для определения полей "грязного" (если используется двойную буферизацию)

- Управляет DFX **NULL** и **DIRTY** состояние массивов и задает значения, при необходимости обновления.

В сердце DFX механизмом является `CDaoRecordset` класса, производного от `DoFieldExchange` функции. Эта функция отправляет вызовы отдельных функций DFX типа соответствующую операцию. Перед вызовом `DoFieldExchange` внутренней функции MFC задают тип операции. Ниже перечислены различные типы операций и краткое описание.

|Операция|Описание|
|---------------|-----------------|
|`AddToParameterList`|Предложение параметров сборки|
|`AddToSelectList`|Предложение SELECT сборок|
|`BindField`|Задает структуру привязки|
|`BindParam`|Задает значения параметров|
|`Fixup`|Задает допустимость значений NULL|
|`AllocCache`|Выделяет кэша для проверки "грязных"|
|`StoreField`|Сохраняет текущую запись в кэш|
|`LoadField`|Восстановление кэша для значений элементов|
|`FreeCache`|Освобождает кэш|
|`SetFieldNull`|Присваивает полю значение на NULL и состояние|
|`MarkForAddNew`|Метки полей "грязные", если не NULL ПСЕВДО|
|`MarkForEdit`|Метки полей "грязных" if не соответствуют кэша|
|`SetDirtyField`|Задает значения, которые отмечены как грязные полей|

В следующем разделе более подробно для будет описывается каждая операция `DFX_Text`.

Наиболее важной возможностью для понимания процесса обмена полями записей DAO является применение `GetRows` функции `CDaoRecordset` объекта. DAO `GetRows` функция может работать с несколькими способами. Это техническое примечание только кратко опишу `GetRows` не выходит за рамки этого техническое Примечание.

DAO `GetRows` можно работать с несколькими способами.

- Его можно получить несколько записей и нескольким полям данных за один раз. Это позволяет для ускорения доступа к данным с усложнение задач, связанных с большой структуры данных и соответствующие смещения для каждого поля и для каждой записи данных в структуре. MFC не воспользоваться преимуществами нескольких запись выборки механизм.

- Еще одним способом `GetRows` можно работы является предоставление программистам указывать адреса привязки для извлеченных данных каждого поля для одной записи данных.

- DAO будет также «выполнить обратный вызов» вызывающий объект для столбцов переменной длины позволит вызывающему объекту выделения памяти. Эта вторая функция имеет преимущество, сводя к минимуму количество копий данных, а также позволяет непосредственно хранилище данных в члены класса ( `CDaoRecordset` производного класса). Этот второй механизм — это метод, MFC использует выполнить привязку к элементам данных в `CDaoRecordset` производных классов.

##  <a name="_mfcnotes_tn053_what_your_custom_dfx_routine_does"></a> Что делает подпрограмма пользовательских DFX

Очевидно, из данного обсуждения, которая наиболее важные операции, реализуемой в любой функции DFX должна быть возможность настроить необходимые структуры данных, для успешного вызова `GetRows`. Существует ряд других операций, которые также должен поддерживать функции DFX, но не как важные или сложным, как правильно Подготовка `GetRows` вызова.

Использование DFX описывается в электронной документации. По сути существует два требования. Во-первых, необходимо добавить членов `CDaoRecordset` производный класс для каждого привязанного поля и параметра. Следуя инструкциям из этого `CDaoRecordset::DoFieldExchange` должен быть переопределен. Обратите внимание на то, что тип данных элемента важна. Он должен сопоставить данные из поля в базе данных или по крайней мере преобразовываться в этот тип. Например числовое поле в базе данных, например длинное целое число, всегда можно быть преобразованы в текст и привязан к `CString` члена, но текстовое поле в базе данных может не всегда преобразуются в числовое представление, такие как длинное целое число и привязан к long интеграция со средой ER члена. DAO и базы данных Microsoft Jet несут ответственность за преобразование (а не MFC).

##  <a name="_mfcnotes_tn053_details_of_dfx_text"></a> Сведения о DFX_Text

Как упоминалось ранее, чтобы объяснить, как работает DFX рекомендуется для работы с примером. Для этой цели, через внутренних `DFX_Text` должны хорошо работать для предоставления по крайней мере основные DFX.

- `AddToParameterList`

   Эта операция создает SQL **параметры** предложение (»`Parameters <param name>, <param type> ... ;`«) требуется Jet. Каждый параметр с именем и типом (как указано в вызове RFX). См. в разделе функция `CDaoFieldExchange::AppendParamType` функции, чтобы просмотреть имена отдельных типов. В случае использования `DFX_Text`, используется тип — **текст**.

- `AddToSelectList`

   Сборки SQL **ВЫБЕРИТЕ** предложение. Это довольно проста, так как имя столбца, указанного при вызове DFX просто добавляется (»`SELECT <column name>, ...`«).

- `BindField`

   Самый сложный из операций. Как упоминалось ранее, это, где используется в структуре привязки DAO `GetRows` настройки. Как видно из кода в `DFX_Text` типов данных в структуре включают тип DAO, используемый (**DAO_CHAR** или **DAO_WCHAR** в случае использования `DFX_Text`). Кроме того, тип используемой привязки также настраивается. В предыдущем разделе `GetRows` был описано только на короткое время, но его достаточно объяснить, тип привязки, используемые MFC, всегда привязки непосредственно обращаться (**DAOBINDING_DIRECT**). Кроме того для привязки столбца переменной длины (например `DFX_Text`) привязки обратного вызова используется, чтобы MFC можно контролировать распределение памяти и укажите адрес нужной длины. Это означает, что MFC могу сказать, DAO «where» поместить данные, позволяя привязку непосредственно к переменных-членов. Остальная часть структуры привязки заполняется таких вещей, как адрес функции обратного вызова выделения памяти и тип используемой привязки столбцов (привязки по имени столбца).

- `BindParam`

   Это простые операции, которая вызывает `SetParamValue` со значением параметра, указанного в параметре-члене.

- `Fixup`

   Заполняет **NULL** состояния для каждого поля.

- `SetFieldNull`

   Эта операция только помечает статус каждого поля как **NULL** и задает значение переменной члена **PSEUDO_NULL**.

- `SetDirtyField`

   Вызовы `SetFieldValue` для каждого поля, как "грязные".

Все остальные операции работать только с помощью кэш данных. Кэш данных — дополнительный буфер данных в текущей записи, которая позволяет упростить определенные. Например «грязный» полей можно автоматически обнаружить. Как описано в электронной документации его можно отключить полностью, или на уровне поля. Реализация буфера использует карту. Эта карта используется для сопоставления с адресом «привязанного» поля динамически выделяемый копии данных (или `CDaoRecordset` производный элемент данных).

- `AllocCache`

   Динамически выделяет значение кэшированного поля и добавляет его к схеме.

- `FreeCache`

   Удаляет значение кэшированного поля и удаляет его из сопоставления.

- `StoreField`

   Копирует текущее значение поля в кэш данных.

- `LoadField`

   Копирует кэшированное значение в поле элемента.

- `MarkForAddNew`

   Проверяет, текущее значение поля является отличным от**NULL** и помечает его "грязные" при необходимости.

- `MarkForEdit`

   Сравнивает текущее значение поля с кэшем данных и помечает "грязные", при необходимости.

> [!TIP]
> Модель, ваши пользовательские процедуры DFX в существующие процедуры DFX для стандартных типов данных.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)

