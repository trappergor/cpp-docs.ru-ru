---
title: 'TN053: Пользовательские подпрограммы DFX для классов баз данных DAO'
ms.date: 09/17/2019
helpviewer_keywords:
- MFC, DAO and
- database classes [MFC], DAO
- DAO [MFC], MFC
- DFX (DAO record field exchange) [MFC], custom routines
- TN053
- DAO [MFC], classes
- DFX (DAO record field exchange) [MFC]
- custom DFX routines [MFC]
ms.assetid: fdcf3c51-4fa8-4517-9222-58aaa4f25cac
ms.openlocfilehash: 949e1a07b2b45b01b08efb368046e0c65b1264e1
ms.sourcegitcommit: 2f96e2fda591d7b1b28842b2ea24e6297bcc3622
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2019
ms.locfileid: "71095989"
---
# <a name="tn053-custom-dfx-routines-for-dao-database-classes"></a>TN053: Пользовательские подпрограммы DFX для классов баз данных DAO

> [!NOTE]
>  DAO используется с базами данных Access и поддерживается в Office 2013. 3,6 является окончательной версией и считается устаревшей. Визуальная C++ среда и мастера не поддерживают DAO (хотя классы DAO включены и их все еще можно использовать). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-templates.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.

В этом техническом примечании описывается механизм обмена полями записей DAO (DFX). Чтобы понять, что происходит в процедурах DFX, `DFX_Text` функция будет подробно объяснена в качестве примера. В качестве дополнительного источника информации для этой технической заметки можно изучить код для других отдельных функций DFX. Вам, вероятно, не придется использовать настраиваемую подпрограммы DFX, как часто, так как может потребоваться пользовательская подпрограммы RFX (используется с классами базы данных ODBC).

Это техническое примечание содержит:

- Общие сведения о DFX

- [Примеры](#_mfcnotes_tn053_examples) использования обмена ПОЛЯМИ записей DAO и динамической привязки

- [Как работает DFX](#_mfcnotes_tn053_how_dfx_works)

- [Что делает настраиваемый метод DFX](#_mfcnotes_tn053_what_your_custom_dfx_routine_does)

- [Сведения о DFX_Text](#_mfcnotes_tn053_details_of_dfx_text)

**Общие сведения о DFX**

Механизм обмена полями записей DAO (DFX) используется для упрощения процедуры извлечения и обновления данных при использовании `CDaoRecordset` класса. Процесс упрощен с помощью элементов `CDaoRecordset` данных класса. Производным от `CDaoRecordset`можно добавить члены данных в производный класс, представляющий каждое поле в таблице или запросе. Этот механизм "статической привязки" прост, но он может не быть выбранным методом выборки и обновления данных для всех приложений. DFX извлекает каждое привязанное поле при каждом изменении текущей записи. При разработке приложения с учетом производительности, которое не требует выборки каждого поля при изменении валюты, «динамическая привязка» через `CDaoRecordset::GetFieldValue` и `CDaoRecordset::SetFieldValue` может быть выбранным методом доступа к данным.

> [!NOTE]
>  DFX и динамическая привязка не являются взаимоисключающими, поэтому можно использовать гибридное использование статической и динамической привязки.

## <a name="_mfcnotes_tn053_examples"></a>Пример 1. использование только обмена полями записей DAO

(предполагается, `CDaoRecordset` что `CMySet` производный класс уже открыт)

```
// Add a new record to the customers table
myset.AddNew();

myset.m_strCustID = _T("MSFT");

myset.m_strCustName = _T("Microsoft");

myset.Update();
```

**Пример 2 — Использование динамической привязки**

(предполагается `CDaoRecordset` использование класса `rs`, и он уже открыт)

```
// Add a new record to the customers table
COleVariant  varFieldValue1 (_T("MSFT"),
    VT_BSTRT);

//Note: VT_BSTRT flags string type as ANSI,
    instead of UNICODE default
COleVariant  varFieldValue2  (_T("Microsoft"),
    VT_BSTRT);

rs.AddNew();

rs.SetFieldValue(_T("Customer_ID"),
    varFieldValue1);

rs.SetFieldValue(_T("Customer_Name"),
    varFieldValue2);

rs.Update();
```

**Пример 3. использование обмена полями записей DAO и динамической привязки**

(предполагает Просмотр данных о сотрудниках с `CDaoRecordset`помощью `emp`производного класса.)

```
// Get the employee's data so that it can be displayed
emp.MoveNext();

// If user wants to see employee's photograph,
// fetch it
COleVariant varPhoto;
if (bSeePicture)
    emp.GetFieldValue(_T("photo"),
    varPhoto);

// Display the data
PopUpEmployeeData(emp.m_strFirstName,
    emp.m_strLastName,
    varPhoto);
```

## <a name="_mfcnotes_tn053_how_dfx_works"></a>Как работает DFX

Механизм DFX работает аналогично механизму обмена полями записей (RFX), используемому классами ODBC MFC. Принципы DFX и RFX одинаковы, но существует множество внутренних различий. Структура функций DFX была таким, что практически весь код совместно используется отдельными подпрограммами DFX. На самом верхнем уровне DFX всего лишь несколько вещей.

- DFX при необходимости конструирует предложение SQL **SELECT** и предложение **Parameters** SQL.

- DFX конструирует структуру привязки, используемую `GetRows` функцией DAO (Подробнее об этом чуть позже).

- DFX управляет буфером данных, используемым для обнаружения «грязных» полей (если используется двойная буферизация).

- DFX управляет массивами состояния **null** и **Dirty** и задает значения при необходимости в обновлениях.

В сердце механизма DFX лежит `CDaoRecordset` `DoFieldExchange` функция производного класса. Эта функция передает вызовы отдельным функциям DFX соответствующего типа операции. Перед вызовом `DoFieldExchange` внутренних функций MFC задайте тип операции. В следующем списке приведены различные типы операций и краткое описание.

|Операция|Описание|
|---------------|-----------------|
|`AddToParameterList`|Предложение параметров сборки|
|`AddToSelectList`|Предложение SELECT для сборок|
|`BindField`|Настройка структуры привязки|
|`BindParam`|Задает значения параметров|
|`Fixup`|Задает состояние NULL|
|`AllocCache`|Выделяет кэш для проверки "грязных"|
|`StoreField`|Сохраняет текущую запись в кэш|
|`LoadField`|Восстанавливает значения элементов кэша|
|`FreeCache`|Освобождение кэша|
|`SetFieldNull`|Задает для поля состояние & значение NULL|
|`MarkForAddNew`|Помечает поля как "грязные", если не является псевдо|
|`MarkForEdit`|Помечает поля как "грязные", если не учитывать кэш|
|`SetDirtyField`|Задает значения полей, помеченные как "грязные"|

В следующем разделе каждая операция будет более подробно `DFX_Text`описана в статье.

Самая важная особенность процесса обмена полями записей DAO заключается в том, что он использует `GetRows` функцию `CDaoRecordset` объекта. Функция DAO `GetRows` может работать несколькими способами. Это техническое примечание кратко описано `GetRows` , так как оно выходит за рамки этой технической заметки.
Версия DAO 3,6 является окончательной и считается устаревшей. `GetRows`может работать несколькими способами.

- Он может одновременно получить несколько записей и несколько полей данных. Это обеспечивает более быстрый доступ к данным с усложнением работы с большой структурой данных и соответствующими смещениями для каждого поля и для каждой записи данных в структуре. MFC не использует этот механизм выборки нескольких записей.

- Другой способ `GetRows` — разрешить программистам указывать адреса привязки для извлеченных данных каждого поля для одной записи данных.

- DAO также будет "вызывать обратную передачу" в вызывающий столбец для столбцов переменной длины, чтобы позволить вызывающему объекту выделить память. Эта вторая функция имеет преимущество свести к минимуму количество копий данных, а также возможность прямого хранения данных в членах класса ( `CDaoRecordset` производного класса). Второй механизм — это метод, используемый MFC для привязки к элементам данных в `CDaoRecordset` производных классах.

##  <a name="_mfcnotes_tn053_what_your_custom_dfx_routine_does"></a>Что делает настраиваемый метод DFX

Это очевидно из этого рассказа о том, что наиболее важной операцией, реализованной в любой функции DFX, должна быть возможность настройки необходимых структур данных для `GetRows`успешного вызова. Существует ряд других операций, которые функция DFX должна поддерживать, но не менее важной или сложной, как правильная подготовка для `GetRows` вызова.

Использование параметра DFX описано в интерактивной документации. По сути, существует два требования. Во – первых, члены должны быть добавлены `CDaoRecordset` в производный класс для каждого привязанного поля и параметра. После этого `CDaoRecordset::DoFieldExchange` следует переопределить. Обратите внимание, что тип данных элемента важен. Он должен соответствовать данным из поля базы данных или как минимум преобразованным в этот тип. Например, числовое поле в базе данных, например длинное целое число, всегда может быть преобразовано в текст и `CString` привязано к элементу, но текстовое поле в базе данных может быть необязательно преобразовано в числовое представление, например длинное целое и которое должно быть привязано к длинному интег. элемент ER. DAO и ядро СУБД Microsoft Jet отвечают за преобразование (а не MFC).

##  <a name="_mfcnotes_tn053_details_of_dfx_text"></a>Сведения о DFX_Text

Как упоминалось ранее, лучшим способом объяснить, как работает DFX, является работа с примером. Для этой цели необходимо хорошо работать с внутренними `DFX_Text` аспектами, чтобы обеспечить как минимум базовое понимание DFX.

- `AddToParameterList`

   Эта операция создает предложение **параметров** SQL ("`Parameters <param name>, <param type> ... ;`"), необходимое для Jet. Каждый параметр назван и типизирован (как указано в вызове RFX). Для просмотра имен `CDaoFieldExchange::AppendParamType` отдельных типов см. функцию функции. В случае `DFX_Text`используется тип **Text**.

- `AddToSelectList`

   Создает предложение SQL **SELECT** . Это довольно просто, так как имя столбца, указанное с помощью метода DFX, является простым добавлением (`SELECT <column name>, ...`"").

- `BindField`

   Наиболее сложная операция. Как упоминалось ранее, здесь настраивается структура привязки DAO `GetRows` , используемая. Как видно из кода `DFX_Text` в типах информации в структуре, включает используемый тип DAO (**DAO_CHAR** или `DFX_Text`DAO_WCHAR в случае). Кроме того, также настраивается используемый тип привязки. В предыдущем разделе `GetRows` была описана только вкратце, но было достаточно объяснить, что тип привязки, используемый MFC, всегда является прямой привязкой адресов (**DAOBINDING_DIRECT**). В дополнение к привязке столбцов переменной длины (например `DFX_Text`,) используется привязка обратного вызова, чтобы MFC мог управлять выделением памяти и указать адрес правильной длины. Это означает, что MFC всегда может сообщить DAO "Where", чтобы разместить данные, таким образом допуская привязку непосредственно к переменным-членам. Остальная часть структуры привязки заполняется такими же, как адрес функции обратного вызова выделения памяти и типа привязки столбца (привязка по имени столбца).

- `BindParam`

   Это простая операция, которая вызывает `SetParamValue` со значением параметра, указанным в члене параметра.

- `Fixup`

   Заполняет состояние **null** для каждого поля.

- `SetFieldNull`

   Эта операция помечает состояние каждого поля как **null** и устанавливает значение **PSEUDO_NULL**для переменной члена.

- `SetDirtyField`

   Вызывает `SetFieldValue` для каждого поля, помеченного как "грязное".

Все остальные операции работают только с использованием кэша данных. Кэш данных — это дополнительный буфер данных в текущей записи, который используется для упрощения определенных задач. Например, поля "грязные" могут быть автоматически обнаружены. Как описано в интерактивной документации, ее можно полностью отключить или на уровне полей. Реализация буфера использует карту. Эта схема используется для сопоставления динамически выделяемых копий данных с адресом "привязанного" поля (или `CDaoRecordset` производного члена данных).

- `AllocCache`

   Динамически выделяет значение кэшированного поля и добавляет его в карту.

- `FreeCache`

   Удаляет значение кэшированного поля и удаляет его из схемы.

- `StoreField`

   Копирует текущее значение поля в кэш данных.

- `LoadField`

   Копирует кэшированное значение в элемент Field.

- `MarkForAddNew`

   Проверяет, имеет ли текущее значение поля, отличное от**null** , и помечает его как "грязное" при необходимости.

- `MarkForEdit`

   Сравнивает значение текущего поля с кэшем данных и помечает «грязный» при необходимости.

> [!TIP]
> Моделирование пользовательских подпрограмм DFX для существующих подпрограмм с DFX для стандартных типов данных.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
