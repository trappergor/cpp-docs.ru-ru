---
title: TN017. Уничтожение объектов окон
ms.date: 11/04/2016
f1_keywords:
- vc.objects
helpviewer_keywords:
- destroying windows
- TN017
- PostNcDestroy method [MFC]
ms.assetid: 5bf208a5-5683-439b-92a1-547c5ded26cd
ms.openlocfilehash: 2448a2661851f14fc6fe8747ca19495925442436
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87226819"
---
# <a name="tn017-destroying-window-objects"></a>TN017. Уничтожение объектов окон

В этом заметке описывается использование метода [CWnd::P остнкдестрой](../mfc/reference/cwnd-class.md#postncdestroy) . Используйте этот метод, если необходимо настроить выделение `CWnd` объектов, производных от. В этом примечании также объясняется, почему следует использовать [CWnd::D естройвиндов](../mfc/reference/cwnd-class.md#destroywindow) для уничтожения объекта C++ Windows вместо **`delete`** оператора.

Если следовать инструкциям в этом разделе, у вас будет несколько проблем с очисткой. Эти проблемы могут возникать из-за таких проблем, как невозможность удаления или освобождения памяти C++, не позволяя освободить системные ресурсы `HWND` , например s, или слишком много раз освобождать объекты.

## <a name="the-problem"></a>Проблема

Каждый объект Windows (объект класса, производного от `CWnd` ) представляет как объект C++, так и `HWND` . Объекты C++ выделяются в куче приложения и `HWND` выделяются в системных ресурсах диспетчером окон. Поскольку существует несколько способов уничтожения объекта Window, необходимо предоставить набор правил, предотвращающих утечку системных ресурсов или памяти. Эти правила также должны препятствовать уничтожению объектов и дескрипторов Windows более одного раза.

## <a name="destroying-windows"></a>Уничтожение окон

Ниже приведены два разрешенных способа уничтожения объекта Windows.

- Вызов `CWnd::DestroyWindow` или Windows API `DestroyWindow` .

- Явное удаление с помощью **`delete`** оператора.

Первый вариант — гораздо чаще. Этот вариант применяется, даже если код не вызывает `DestroyWindow` напрямую. Когда пользователь непосредственно закрывает окно фрейма, это действие создает WM_CLOSE сообщение, и ответ по умолчанию на это сообщение будет вызываться `DestroyWindow.` при уничтожении родительского окна, Windows вызывает `DestroyWindow` для всех его дочерних окон.

Во втором случае использование **`delete`** оператора в объектах Windows должно быть редким. Ниже приведены некоторые случаи, когда используется **`delete`** правильный вариант.

## <a name="auto-cleanup-with-cwndpostncdestroy"></a>Автоматическая очистка с помощью CWnd::P Остнкдестрой

Когда система уничтожает окно Windows, Последнее сообщение Windows, отправленное в окно, будет WM_NCDESTROY. Обработчиком по умолчанию `CWnd` для этого сообщения является [CWnd:: OnNcDestroy](../mfc/reference/cwnd-class.md#onncdestroy). `OnNcDestroy`Отсоединяет `HWND` объект от объекта C++ и вызывает виртуальную функцию `PostNcDestroy` . Некоторые классы переопределяют эту функцию для удаления объекта C++.

Реализация по умолчанию `CWnd::PostNcDestroy` не выполняет никаких действий, что подходит для объектов Window, выделенных в кадре стека или внедренных в другие объекты. Это не подходит для объектов Window, предназначенных для выделения в куче без каких-либо других объектов. Иными словами, это не подходит для объектов Window, которые не внедряются в другие объекты C++.

Эти классы, предназначенные для выделения отдельно в куче, переопределяют `PostNcDestroy` метод для выполнения **удаления**. Эта инструкция освобождает память, связанную с объектом C++. Несмотря на то, что деструктор по умолчанию `CWnd` вызывает `DestroyWindow` , если *M_HWND* не равно null, это не приводит к бесконечной рекурсии, так как этот обработчик ОТСОЕДИНЯЕТСЯ и принимает значение NULL на этапе очистки.

> [!NOTE]
> Система обычно вызывается `CWnd::PostNcDestroy` после обработки сообщения Windows WM_NCDESTROY, а `HWND` объект окна C++ больше не подключен. Система также будет вызывать метод `CWnd::PostNcDestroy` в реализации большинства методов [CWnd:: Create](../mfc/reference/cwnd-class.md#create) , если происходит сбой. Правила автоматической очистки описаны далее в этом разделе.

## <a name="auto-cleanup-classes"></a>Классы автоматической очистки

Следующие классы не предназначены для автоматической очистки. Они обычно внедряются в другие объекты C++ или в стек:

- Все стандартные элементы управления Windows ( `CStatic` , `CEdit` , `CListBox` и т. д.).

- Любые дочерние окна, производные непосредственно от `CWnd` (например, пользовательские элементы управления).

- Окна разделителей ( `CSplitterWnd` ).

- Панели элементов управления по умолчанию (классы, производные от `CControlBar` , см. [техническое заметка 31](../mfc/tn031-control-bars.md) для включения автоматического удаления для объектов панели управления).

- Диалоговые окна ( `CDialog` ) предназначены для модальных диалоговых окон в кадре стека.

- Все стандартные диалоги, кроме `CFindReplaceDialog` .

- Диалоговые окна по умолчанию, созданные ClassWizard.

Следующие классы предназначены для автоматической очистки. Они обычно выделяются самим по себе в куче:

- Окна главного фрейма (напрямую или косвенно `CFrameWnd` ).

- Просмотр окон (напрямую или косвенно `CView` ).

Если вы хотите прервать эти правила, необходимо переопределить `PostNcDestroy` метод в производном классе. Чтобы добавить автоматическую очистку в класс, вызовите базовый класс, а затем выполните **Удаление**. Чтобы удалить автоматическую очистку из класса, вызовите `CWnd::PostNcDestroy` непосредственно вместо `PostNcDestroy` метода непосредственного базового класса.

Наиболее распространенным применением режима автоматической очистки является создание немодального диалогового окна, которое может быть выделено в куче.

## <a name="when-to-call-delete"></a>Когда следует вызывать delete

Рекомендуется вызвать `DestroyWindow` метод для уничтожения объекта Windows, либо метода C++, либо глобального `DestroyWindow` API.

Не вызывайте глобальный `DestroyWindow` API для уничтожения дочернего окна MDI. Вместо этого следует использовать виртуальный метод `CWnd::DestroyWindow` .

Для объектов окна C++, которые не выполняют автоматическую очистку, использование **`delete`** оператора может привести к утечке памяти при попытке вызвать `DestroyWindow` в `CWnd::~CWnd` деструкторе, если VTBL не указывает на правильный производный класс. Это происходит из-за того, что системе не удается найти соответствующий метод destroy для вызова. Использование `DestroyWindow` вместо этого **`delete`** позволяет избежать этих проблем. Поскольку это может быть незаметной ошибкой, при компиляции в режиме отладки при возникновении риска будет выдано следующее предупреждение.

```
Warning: calling DestroyWindow in CWnd::~CWnd
    OnDestroy or PostNcDestroy in derived class will not be called
```

В случае с объектами Windows в C++, которые выполняют автоматическую очистку, необходимо вызвать `DestroyWindow` . Если **`delete`** оператор используется напрямую, распределитель памяти диагностики MFC сообщит вам о том, что память освобождается два раза. Два вхождения являются первым явным вызовом и косвенным вызовом для **удаления этого** объекта в реализации автоматической очистки `PostNcDestroy` .

После вызова `DestroyWindow` для объекта, не являющегося автоматической очисткой, объект C++ будет по-прежнему состоять, но *m_hWnd* будет иметь значение null. После вызова `DestroyWindow` для объекта автоматической очистки объект c++ будет освобожден с помощью оператора delete c++ в реализации автоматической очистки `PostNcDestroy` .

## <a name="see-also"></a>См. также статью

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
