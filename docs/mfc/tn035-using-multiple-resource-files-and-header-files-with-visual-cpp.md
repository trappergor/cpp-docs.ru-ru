---
title: "TN035: Использование нескольких файлов ресурсов и файлов заголовка в Visual C++ | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: vc.resources
dev_langs: C++
helpviewer_keywords:
- resource files, multiple
- TN035
ms.assetid: 1f08ce5e-a912-44cc-ac56-7dd93ad73fb6
caps.latest.revision: "13"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: 9c03c642dfc3524f69f4aa8d1a397f750b42db27
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2017
---
# <a name="tn035-using-multiple-resource-files-and-header-files-with-visual-c"></a>TN035. Использование нескольких файлов ресурсов и файлов заголовков в Visual C++
> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.  
  
 Эта заметка описывает поддержку редактором ресурсов Visual C++ нескольких файлов ресурсов и файлов заголовков, совместно используемых в одном или нескольких проектах, а также рассказывает о том, как с выгодой для себя воспользоваться этой поддержкой. Эта заметка содержит ответы на следующие вопросы:  
  
-   Если возможно требуется разделить проект на несколько файлов ресурсов и(или) файлов заголовка, и как это сделать  
  
-   Как поделиться общих заголовков. H-файла между двумя. RC-файлы  
  
-   Как разделить ресурсы проекта на несколько. RC-файлы  
  
-   Как вы (и инструменты) управлять зависимостями сборок между. ВЕРСИИ-КАНДИДАТА. CPP, и. H-файлы  
  
 Следует иметь в виду, что при добавлении дополнительного файла ресурсов в проект ClassWizard не распознает ресурсы в добавленном файле.  
  
 Эта заметка предоставляет ответы на вопросы выше в следующей последовательности:  
  
- **Общие сведения о том, как Visual C++ управляет файлы ресурсов и файлы заголовков** предоставляет общие сведения о том, как команда Включение наборов в Visual C++ позволяет использовать несколько файлов ресурсов и файлов заголовка в том же проекте.  
  
- **Анализ, созданное мастером. Версия-Кандидат и. Файлы H** просматривает несколько файлов ресурсов и заголовков, которые используются в приложение, созданное мастером. Эти файлы служат в качестве хорошей модели для создания дополнительных файлов ресурсов и файлов заголовка, которые может потребоваться добавить в проект.  
  
- **Включение дополнительных файлов заголовков** описывает, где можно разместить несколько файлов заголовков и предоставляет сведения о том, как удалить.  
  
- **Совместное использование файла заголовка между двумя. Версия-Кандидат файлы** показано, как можно использовать один файл заголовка между несколькими. RC-файлы в разных проектах или, возможно в том же проекте.  
  
- **Использование нескольких файлов ресурсов в том же проекте** описывает место разделить проект на несколько. Версия-Кандидат файлы и предоставляет сведения, как сделать это.  
  
- **Применение нередактируемые файлов Visual C++** описывает, каким образом можно гарантировать Visual C++ не редактирование и случайное переформатирование пользовательского ресурса.  
  
- **Управление символами, которые совместно используется несколькими Visual C++ редактировать. Версия-Кандидат файлы** описывает, как использовать же символы в нескольких. RC-файлы и как избежать назначения дублирующихся числовых идентификаторов.  
  
- **Управление зависимостями между. ВЕРСИИ-КАНДИДАТА. CPP, и. Файлы H** описывает, каким образом Visual C++ позволяет избежать ненужных перекомпиляции. CPP-файлов, зависимые от файлов с символами ресурсов.  
  
- **Как Visual C++ управляет включает сведения о наборе** технические сведения о том, как Visual C++ сохраняет отслеживания о нескольких (вложенных). RC-файлы и множество файлов заголовка # посредством команды #include. RC-файле.  
  
 **Общие сведения о том, как Visual C++ управляет файлами ресурсов и файлами заголовков**  
  
 Visual C++ управляет одним RC-файлом ресурсов и соответствующим H-файлом заголовка в тесной связи друг с другом. При редактировании и сохранении ресурсов в RC-файле косвенно вносятся изменения и сохраняются символы в соответствующем H-файле. Хотя можно открыть и отредактировать несколько RC-файлов за раз (с помощью пользовательского интерфейса MDI Visual C++), для любого заданного RC-файла косвенно редактируется ровно один соответствующий файл заголовка.  
  
 **Файл символов заголовка**  
  
 По умолчанию Visual C++ всегда называет соответствующий файл заголовка RESOURCE.H независимо от имени файла ресурсов (например, MYAPP.RC). С помощью **включения ресурсов** из **представление** меню в Visual C++, можно изменить имя этого файла заголовка, обновив файл символов заголовка в **набор включает**диалоговое окно.  
  
 **Директивы символов только для чтения**  
  
 Хотя Visual C++ изменяет только один файл заголовка для любого заданного RC-файла, Visual C++ поддерживает ссылки на символы, определенные в дополнительных файлах заголовка только для чтения. С помощью **включения ресурсов** из **представление** меню в Visual C++, можно указать любое количество дополнительных заголовка только для чтения файлов, как директивы символов только для чтения. Ограничение "только для чтения" означает, что при добавлении нового ресурса в RC-файл можно использовать символ, определенный в файле заголовка только для чтения; но при удалении ресурса символ по-прежнему останется определенным в файле заголовка только для чтения. Невозможно изменить числовое значение, присвоенное символу только для чтения.  
  
 **Директивы времени компиляции**  
  
 Visual C++ также поддерживает вложение файлов ресурсов, где один RC-файл включается в другой посредством команды #include. При редактировании заданного RC-файла с помощью Visual C++ все ресурсы в файлах #include не видны. Однако при компиляции RC-файла включенные с помощью команды #include файлы также компилируются. С помощью **включения ресурсов** из **представление** меню в Visual C++, можно указать любое количество # посредством оператора #include. RC-файлы в качестве директивы времени компиляции.  
  
 Обратите внимание, что происходит при чтении в Visual C++. RC-файл, #include в другой. RC-файле, *не* определенный как директива времени компиляции. Такая ситуация может возникнуть при добавлении в Visual C++ RC-файла, который ранее обслуживался вручную с использованием текстового редактора. Когда Visual C++ считывает включенный с помощью команды #include RC-файл, он выполняет слияние включенных командой #include ресурсов в родительский RC-файл. При сохранении родительского RC-файла оператор #include, по сути, будет заменен включенными посредством команды #include ресурсами. Если это слияние не нужно, следует удалить #include инструкции от родительского. RC-файле *предыдущих* он будет считан в Visual C++; затем с помощью Visual C++ добавить тот же # оператор include в качестве директивы времени компиляции.  
  
 Visual C++ сохраняет в. RC-файле три типа вышеперечисленных набор содержит сведения (файл символов заголовка, директивы символов только для чтения и директивы времени компиляции) в #include *и* ресурсах TEXTINCLUDE. Ресурсы TEXTINCLUDE, реализации не должны нормально работать с, приведены в [как Visual C++ управляет набор содержит сведения о](#_mfcnotes_tn035_set_includes).  
  
 **Анализ, созданное мастером. Версия-Кандидат и. H-файлы**  
  
 Анализ кода приложения, созданного мастером приложений AppWizard, дает представление о том, как осуществляется управление несколькими файлами ресурсов и файлами заголовков в Visual C++. Рассматриваемые ниже отрывки кода взяты из приложения MYAPP, созданного в мастере приложений с использованием параметров по умолчанию.  
  
 Как показано на схеме ниже, приложение, созданное мастером приложений, использует несколько файлов ресурсов и файлов заголовков.  
  
```  
RESOURCE.H     AFXRES.H      
 \       /                
 \     /  
    MYAPP.RC 
 |  
 |                
    RES\MYAPP.RC2 
    AFXRES.RC 
    AFXPRINT.RC 
```  
  
 Просмотреть связи между этими файлами можно с помощью команды "Включение файлов/наборов" Visual C++.  
  
 MYAPP.RC  
 Файл ресурсов приложения, редактируемый с помощью Visual C++.  
  
 RESOURCE.H — это зависящий от приложения файл заголовка. Мастером создания приложений ему всегда присваивается имя RESOURCE.H, что соответствует именованию файла заголовка по умолчанию в Visual C++. Оператор #include для этого файла заголовка — это первый оператор в файле ресурсов (MYAPP.RC).  
  
```  
//Microsoft Visual C++ generated resource script  
//  
#include "resource.h"  
```  
  
 RES\MYAPP.RC2  
 Содержит ресурсы, которые не будут изменены Visual C++, однако будут включены в окончательный скомпилированный EXE-файл. Мастер приложений не создает таких ресурсов по умолчанию, поскольку Visual C++ может изменить все стандартные ресурсы, в том числе ресурс версии (новая функция в этом выпуске). Пустой файл создается мастером приложений AppWizard, если требуется добавить в этот файл собственные пользовательские форматированные ресурсы.  
  
 При использовании пользовательских форматированных ресурсов их можно добавить в файл RES\MYAPP.RC2 и редактировать их с помощью текстового редактора Visual C++.  
  
 AFXRES.RC и AFXPRINT.RC содержат стандартные ресурсы, требуемые некоторыми компонентами платформы. Подобно RES\MYAPP.RC2, эти два файла ресурсов, предоставленные платформой, включены посредством оператора #include в конец файла MYAPP.RC, они заданы в разделе "Директивы времени компиляции" диалогового окна "Включение наборов". Таким образом, при редактировании MYAPP.RC в Visual C++ не выполняется непосредственный просмотр или правка этих ресурсов платформы, однако они компилируются в двоичный RES-файл и окончательный EXE-файл приложения. Дополнительные сведения о стандартных ресурсах платформы, включая процедуры их изменения, в разделе [техническое Примечание 23](../mfc/tn023-standard-mfc-resources.md).  
  
 AFXRES.H определяет стандартные символы, такие как `ID_FILE_NEW`, которые используются платформой и, в частности, файлом AFXRES.RC. AFXRES.H также включает посредством оператора #include файл WINRES.H, содержащий подмножество файлов WINDOWS.H, которые требуются созданным Visual C++ RC-файлам и файлу AFXRES.RC. Символы, определенные в файле AFXRES.H, доступны при редактировании файла ресурсов приложения (MYAPP.RC). Например, `ID_FILE_NEW` используется для пункта меню "Создать файл" в ресурсе меню файла MYAPP.RC. Невозможно изменить или удалить определенные платформой символы.  
  
## <a name="_mfcnotes_tn035_including"></a>Включение дополнительных файлов заголовков  
  
 Приложение, созданное мастером приложений AppWizard, включает только два файла заголовков: RESOURCE.H и AFXRES.H. Только файл RESOURCE.H зависит от приложения. Может потребоваться включить дополнительные, доступные только для чтения файлы заголовка в следующих случаях:  
  
 Файл заголовка предоставляется внешним источником, либо требуется предоставить общий доступ к файлу заголовка из нескольких проектов или нескольких частей одного и того же проекта.  
  
 Файл заголовка имеет форматирование и комментарии, которые не нужно менять или отфильтровывать при сохранении файла в Visual C++. Возможно, к примеру, требуется сохранить оператор #define, использующий арифметические операции с символами:  
  
```  
#define RED 0  
#define BLUE 1  
#define GREEN 2  
#define ID_COLOR_BUTTON 1001  
#define ID_RED_BUTTON (ID_COLOR_BUTTON + RED)  
#define ID_BLUE_BUTTON (ID_COLOR_BUTTON + BLUE)  
#define ID_GREEN_BUTTON (ID_COLOR_BUTTON + GREEN)  
```  
  
 Можно включить дополнительные доступные только для чтения файлы заголовка с помощью **включения ресурсов** команду, чтобы указать # оператор include в качестве второй директивы символов только для чтения, как в:  
  
```  
#include "afxres.h"  
#include "second.h"  
```  
  
 Новая схема связей файлов теперь выглядит следующим образом:  
  
```  
    AFXRES.H 
RESOURCE.H     SECOND.H      
 \       /                
 \     /  
    MYAPP.RC 
 |  
 |                
    RES\MYAPP.RC2 
    AFXRES.RC 
    AFXPRINT.RC 
```  
  
 **Совместное использование файла заголовка между двумя. RC-файлы**  
  
 Может потребоваться совместно использовать файл заголовка в двух RC-файлах разных проектов (или в масштабах одного проекта). Для этого необходимо применить технику директив только для чтения, описанную выше, к обоим RC-файлам. В случае, когда 2 RC-файла предназначены для разных приложений (разных проектов), результат показан на следующей схеме:  
  
```  
    RESOURCE.H AFXRES.H   RESOURCE.H    
 (for MYAPP1) SECOND.H   (for MYAPP2)               
 \       /     \       /             
 \     /       \     /               
    MYAPP1.RC MYAPP2.RC */    \        /     \ */      \      /       \              
RES\MYAPP1.RC2  AFXRES.RC     RES\MYAPP2.RC2                
    AFXPRINT.RC 
```  
  
 Ниже описывается случай, когда второй файл заголовка совместно используется двумя RC-файлами одного и того же приложения (проекта).  
  
 **Использование нескольких файлов ресурсов в одном проекте**  
  
 Visual C++ и компилятор ресурсов поддерживают несколько RC-файлов в том же проекте посредством включения одного RC-файла в другой с помощью оператора #include. Допускается множественное вложение. Разделить ресурсы проекта на несколько RC-файлов имеет смысл по нескольким причинам.  
  
-   Управлять большим количеством ресурсов, распределенных между многочисленными членами проектной команды, легче, если разделить ресурсы на несколько RC-файлов. Если для извлечения файлов и возврата изменений используется пакет управления системы управления версиями, разделение ресурсов на несколько RC-файлов обеспечит более полный контроль над управлением изменениями в ресурсах.  
  
-   Если требуется использовать директивы препроцессора, например #ifdef, #endif и #define, для частей ресурсов, необходимо изолировать их в доступных только для чтения ресурсах, которые будут компилироваться компилятором ресурсов.  
  
-   Компонентные RC-файлы загружаются и сохраняются в Visual C++ быстрее, чем один составной RC-файл.  
  
-   Если требуется поддержать ресурс с текстовым редактором в удобном для чтения формате, необходимо сохранить его в RC-файле отдельно от редактируемого Visual C++ файла.  
  
-   Если необходимо оставить определенный пользователем ресурс в двоичном или текстовом формате, который может быть интерпретирован другим специализированным редактором данных, необходимо оставить его в отдельном RC-файле, чтобы Visual C++ не меняла его формат на шестнадцатеричные данные. . WAV-файла (звук) файловых ресурсов в образце Дополнительные понятия MFC [SPEAKN](../visual-cpp-samples.md) — хороший пример.  
  
 Можно включить посредством оператора #include файл SECOND.RC в директивы времени компиляции в диалоговом окне "Включение наборов".  
  
```  
#include "res\myapp.rc2"  // non-Visual C++ edited resources  
#include "second.rc"  // THE SECOND .RC FILE  
  
#include "afxres.rc"  // Standard components  
#include "afxprint.rc"  // printing/print preview resources  
```  
  
 Результат показан на следующей схеме.  
  
```  
RESOURCE.H     AFXRES.H      
 \       /                
 \     /  
    MYAPP.RC 
 |  
 |                
    RES\MYAPP.RC2 
    SECOND.RC 
    AFXRES.RC 
    AFXPRINT.RC 
```  
  
 С помощью директив времени выполнения можно организовать редактируемые и нередактируемые в Visual C++ ресурсы в несколько RC-файлов, где "главный" файл MYAPP.RC не делает ничего, кроме включения других RC-файлов посредством оператора #include. При использовании MAK-файла проекта Visual C++ необходимо включить в проект "главный" RC-файл, чтобы все включенные посредством оператора #include ресурсы компилировались с приложением.  
  
 **Применение файлов реализация нередактируемых в Visual C++**  
  
 RES\MYAPP созданный мастером приложений. Файл версии-кандидата 2 приведен пример файла, содержащего ресурсы, которые *не* требуется случайно считывать в Visual C++, а затем записывать их обратно с потерей информации о форматировании. Чтобы избежать этого, поместите следующие строки в начало файла RES\MYAPP.RC2:  
  
```  
#ifdef APSTUDIO_INVOKED  
 #error this file is not editable by Visual C++  
#endif //APSTUDIO_INVOKED  
```  
  
 При компиляции Visual C++. RC-файле, он определяет **APSTUDIO_INVOKED** и **RC_INVOKED**. Если структура созданного мастером приложений файла повреждена и Visual C++ считывает строку #error выше, он сообщает о неустранимой ошибке и прерывает чтение RC-файла.  
  
 **Управление символами, которые совместно используется несколькими Visual C++ редактировать. RC-файлы**  
  
 При разделении ресурсов на несколько RC-файлов, которые требуется редактировать в Visual C++ по отдельности, возникает две проблемы:  
  
-   Может потребоваться использовать одни и те же символы в нескольких RC-файлах.  
  
-   Необходимо сделать так, чтобы Visual C++ не назначала одни и те же числовые идентификаторы разным ресурсам (символам).  
  
 На следующей схеме показана организация RC- и H-файлов, в которых решается первая проблема.  
  
```  
    MYAPP.RC */         \ */           \  
MYSTRS.H   / MYSHARED.H  \  MYMENUS.H  
 \    /    /      \   \    \  
 \  /    /        \   \    \  
    MYSTRS.RC MYMENUS.RC  
```  
  
 В этом примере строковые ресурсы хранятся в одном файле ресурсов, MYSTRS.RC, а меню хранятся в другом — MYMENUS.RC. Некоторые символы, например, команды, нужно будет совместно использовать в обоих файлах. Например, ID_TOOLS_SPELL может являться идентификатором команды меню элемента "Правописание" в меню "Сервис" и одновременно строковым идентификатором командной строки, отображаемой платформой в строке статуса главного окна приложения.  
  
 Символ ID_TOOLS_SPELL хранится в общем файле заголовка, MYSHARED.H. Обслуживание этого общего файла заголовка осуществляется вручную в текстовом редакторе; Visual C++ не поддерживает его прямое редактирование. Два ресурса файлы MYSTRS. Версия-Кандидат и MYMENUS. Версия-КАНДИДАТ, укажите #include MYSHARED. H в только для чтения директивы для MYAPP. Версия-КАНДИДАТ, с помощью **включения ресурсов** команды, как описано выше.  
  
 Удобнее предугадать, какой символ будет использоваться совместно, прежде чем предпринимать попытки использовать его для идентификации ресурсов. Добавьте символ в общий файл заголовка и если общий файл заголовков еще не включен в доступные только для чтения директивы для RC-файла посредством оператора #include, сделайте это до начала использования символа. Если совместное использование символа подобным образом не предусматривалось, необходимо вручную (с помощью текстового редактора) переместить оператор #define для этого символа из файла MYMENUS.H в файл MYSHARED.H, прежде чем приступать к использованию символа в файле MYSTRS.RC.  
  
 При управлении символами в нескольких RC-файлах необходимо также запретить Visual C++ назначать одни и те же значения числового идентификатора разным ресурсам (символам). Для любого заданного RC-файла Visual C++ последовательно присваивает идентификаторы в каждом из четырех доменов ИД. Между сеансами редактирования Visual C++ отслеживает последний присвоенный идентификатор в каждом домене файла символов заголовков для RC-файла. Вот как выглядят значения APS_NEXT для пустого (нового) RC-файла:  
  
```  
#define _APS_NEXT_RESOURCE_VALUE  101  
#define _APS_NEXT_COMMAND_VALUE   40001  
#define _APS_NEXT_CONTROL_VALUE   1000  
#define _APS_NEXT_SYMED_VALUE     101  
```  
  
 **_APS_NEXT_RESOURCE_VALUE** — это следующее значение символа, который будет использоваться для ресурса диалогового окна, ресурс меню и т. д. Допустимый диапазон значений символов ресурсов — от 1 до 0x6FFF.  
  
 **_APS_NEXT_COMMAND_VALUE** — это следующее значение символа, который будет использоваться для идентификации команды. Допустимый диапазон значений символов команд — от 0x8000 до 0xDFFF.  
  
 **_APS_NEXT_CONTROL_VALUE** — это следующее значение символа, который будет использоваться для элемента управления диалогового окна. Допустимый диапазон значений символов элемента управления "диалоговое окно" — от 8 до 0xDFFF.  
  
 **_APS_NEXT_SYMED_VALUE** — это следующее значение символа, который будет выполнен при присвоении значения символа, с помощью новой команды в обозревателе символов вручную.  
  
 При создании нового RC-файла Visual C++ начинает с немного более высоких значений, чем наинизшее допустимое значение. AppWizard также инициализирует эти значения с использованием чего-либо более подходящего для приложений MFC. Дополнительные сведения о диапазонах значений Идентификаторов см. в разделе [техническое Примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md).  
  
 Теперь каждый раз при создании нового файла ресурсов, даже в том же проекте, Visual C++ определяется же **_APS_NEXT\_**  значения. Это означает, что при добавлении, допустим, нескольких диалоговых окон в два разных RC-файла очень вероятно, что одно и то же значение #define будет назначено разным диалоговым окнам. Например, параметру IDD_MY_DLG1 в первом RC-файле может быть присвоено то же число (101), что и параметру IDD_MY_DLG2 во втором RC-файле.  
  
 Чтобы избежать этого, необходимо зарезервировать отдельный числовой диапазон для каждого из четырех доменов идентификаторов в соответствующих RC-файлах. Этого можно вручную обновить **_APS_NEXT** значений в каждом из. RC-файлы `before` начать добавлять ресурсы. Например если первый. RC-файле используется значение по умолчанию **_APS_NEXT** значения, то может потребоваться назначить следующие **_APS_NEXT** значений на второй. RC-файле:  
  
```  
#define _APS_NEXT_RESOURCE_VALUE  2000  
#define _APS_NEXT_COMMAND_VALUE   42000  
#define _APS_NEXT_CONTROL_VALUE   2000  
#define _APS_NEXT_SYMED_VALUE     2000  
```  
  
 Конечно, все еще возможно, что Visual C++ присвоит в первом RC-файле столько идентификаторов, что числовые значения начнут перекрывать зарезервированные для второго RC-файла. Необходимо зарезервировать достаточно крупные диапазоны, чтобы этого не произошло.  
  
 **Управление зависимостями между. ВЕРСИИ-КАНДИДАТА. CPP, и. H-файлы**  
  
 Если Visual C++ сохраняет RC-файл, он также сохраняет изменения символов в соответствующем файле RESOURCE.H. Любой из CPP-файлов, ссылающихся на ресурсы в RC-файле, должен включать посредством оператора #include файл RESOURCE.H, обычно из главного файла заголовка проекта. Это приводит к нежелательному побочному эффекту: внутренняя система управления проектами среды разработки сканирует исходные файлы на наличие зависимостей заголовков. Каждый раз при добавлении нового символа в Visual C++ придется перекомпилировать весь CPP-файл, включающий файл RESOURCE.H с помощью директивы #include.  
  
 Visual C++ обходит зависимость от RESOURCE.H, включая следующий комментарий в качестве первой строки файла RESOURCE.H:  
  
```  
//{{NO_DEPENDENCIES}}  
```  
  
 Среда разработки интерпретирует этот комментарий, игнорируя изменения файла RESOURCE.H таким образом, что CPP-файлам не потребуется повторная компиляция.  
  
 Visual C++ всегда добавляет строку комментариев //{{NO_DEPENDENCIES}} в RC-файл при сохранении. В некоторых случаях обход зависимости сборки от файла RESOURCE.H может вызвать ошибки во время выполнения, которые невозможно обнаружить во время компоновки. Например, если браузер символов используется для изменения числового значения, присвоенного символу для ресурса, ресурс не будет правильно найден и загружен во время выполнения приложения, если ссылающийся на этот ресурс CPP-файл не перекомпилирован. В таких случаях следует явно перекомпилировать все. CPP-файлов, которые зависят от изменения символов в РЕСУРСЕ. H или выберите **перестроить все**. Если требуется часто менять значения символов для определенной группы ресурсов, возможно, обнаружится его удобнее и безопаснее разделить эти символы в файле отдельные заголовка только для чтения, как описано в предыдущем разделе [включая Дополнительные файлы заголовка](#_mfcnotes_tn035_including).  
  
## <a name="_mfcnotes_tn035_set_includes"></a>Как Visual C++ управляет набор включает сведения **  
  
 Как сказано выше, команда "Включение наборов" меню "Файл" позволяет задать три типа сведений.  
  
-   Файл символов заголовка  
  
-   Директивы символов только для чтения  
  
-   Директивы времени компиляции  
  
 Далее описывается обслуживание этой информации Visual C++ в RC-файле. Для работы с Visual C++ эта информация не является обязательной, однако она обеспечивает дополнительное понимание вопроса и позволяет использовать функцию "Включение наборов" более уверенно.  
  
 Каждый из описанных выше трех типов сведений "Включение наборов" хранится в RC-файле в двух формах: (1) как оператор #include или другие директивы, интерпретируемые компилятором ресурсов, и как (2) специальные ресурсы TEXTINCLUDE, интерпретируемые только Visual C++.  
  
 Цель ресурсов TEXTINCLUDE — безопасно хранить сведения включают набор в виде, готовой к представлению в Visual C++ **Включение наборов** диалоговое окно. TEXTINCLUDE — *тип ресурса* определенный Visual C++. Visual C++ распознает три определенных ресурса TEXTINCLUDE с идентификационными номерами 1, 2 и 3.  
  
|Идентификатор ресурса TEXTINCLUDE|Тип сведений "Включение наборов"|  
|-----------------------------|--------------------------------------|  
|1|Файл символов заголовка|  
|2|Директивы символов только для чтения|  
|3|Директивы времени компиляции|  
  
 Каждый из трех типов сведений "Включение наборов" иллюстрируется файлами по умолчанию MYAPP.RC и RESOURCE.H, созданными мастером приложений, как описано ниже. Дополнительные токены \0 и "" между блоками BEGIN и END требуются синтаксису RC для задания завершаемых нулем строк и символа двойных кавычек соответственно.  
  
## <a name="symbol-header-file"></a>Файл символов заголовка  
 Форма данных файла символов заголовков, интерпретируемая компилятором ресурсов, — это просто оператор #include:  
  
```  
#include "resource.h"  
```  
  
 Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:  
  
```  
1 TEXTINCLUDE DISCARDABLE  
BEGIN  
 "resource.h\0"  
END  
```  
  
## <a name="read-only-symbol-directives"></a>Директивы символов только для чтения  
 Доступные только для чтения директивы включены в начало файла MYAPP.RC в следующей форме, доступной для интерпретации компилятором ресурсов:  
  
```  
#include "afxres.h"  
```  
  
 Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:  
  
```  
2 TEXTINCLUDE DISCARDABLE  
BEGIN  
   "#include ""afxres.h""\r\n"  
   "\0"  
END  
```  
  
## <a name="compile-time-directives"></a>Директивы времени компиляции  
 Директивы времени выполнения включены в конец файла MYAPP.RC в следующей форме, доступной для интерпретации компилятором ресурсов:  
  
```  
#ifndef APSTUDIO_INVOKED  
///////////////////////  
//  
// From TEXTINCLUDE 3  
//  
#include "res\myapp.rc2"  // non-Visual C++ edited resources  
  
#include "afxres.rc"  // Standard components  
#include "afxprint.rc"  // printing/print preview resources  
#endif  // not APSTUDIO_INVOKED  
```  
  
 Директива #ifndef APSTUDIO_INVOKED отправляет Visual C++ инструкцию о необходимости пропустить директивы времени выполнения.  
  
 Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:  
  
```  
3 TEXTINCLUDE DISCARDABLE  
BEGIN  
"#include ""res\myapp.rc2""  // non-Visual C++ edited resources\r\n"  
"\r\n"  
"#include ""afxres.rc""  // Standard components\r\n"  
"#include ""afxprint.rc""  // printing/print preview resources\r\n"  
"\0"  
END  
```  
  
## <a name="see-also"></a>См. также  
 [Технические примечания по номеру](../mfc/technical-notes-by-number.md)   
 [Технические примечания по категории](../mfc/technical-notes-by-category.md)

