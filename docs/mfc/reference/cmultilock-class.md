---
title: Класс CMultiLock | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
f1_keywords:
- CMultiLock
- AFXMT/CMultiLock
- AFXMT/CMultiLock::CMultiLock
- AFXMT/CMultiLock::IsLocked
- AFXMT/CMultiLock::Lock
- AFXMT/CMultiLock::Unlock
dev_langs:
- C++
helpviewer_keywords:
- CMultiLock [MFC], CMultiLock
- CMultiLock [MFC], IsLocked
- CMultiLock [MFC], Lock
- CMultiLock [MFC], Unlock
ms.assetid: c5b7c78b-1f81-4387-b7dd-2c813c5b6b61
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: ebcfda85c82d10f2493234bb340a68129f779a28
ms.sourcegitcommit: 9a0905c03a73c904014ec9fd3d6e59e4fa7813cd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/29/2018
ms.locfileid: "43198116"
---
# <a name="cmultilock-class"></a>Класс CMultiLock
Класс представляет механизм контроля доступа к ресурсам в многопоточных программах.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
class CMultiLock  
```  
  
## <a name="members"></a>Участники  
  
### <a name="public-constructors"></a>Открытые конструкторы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[CMultiLock::CMultiLock](#cmultilock)|Создает объект `CMultiLock`.|  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание:|  
|----------|-----------------|  
|[CMultiLock::IsLocked](#islocked)|Определяет, если объект определенного синхронизации в массиве блокируется.|  
|[CMultiLock::Lock](#lock)|Ожиданий в массиве объектов синхронизации.|  
|[CMultiLock::Unlock](#unlock)|Освобождает все объекты принадлежащий синхронизации.|  
  
## <a name="remarks"></a>Примечания  
 `CMultiLock` не имеет базового класса.  
  
 Использование классов синхронизации [CSemaphore](../../mfc/reference/csemaphore-class.md), [CMutex](../../mfc/reference/cmutex-class.md), и [CEvent](../../mfc/reference/cevent-class.md), можно создать либо `CMultiLock` или [CSingleLock](../../mfc/reference/csinglelock-class.md)объект для ожидания и освободить объект синхронизации. Использовать `CMultiLock` при наличии нескольких объектов, которые можно использовать в определенное время. Используйте `CSingleLock` при только необходимо подождать на один объект за раз.  
  
 Чтобы использовать `CMultiLock` следует сначала создать массив объектов синхронизации, которые вы хотите ожидания. Затем вызовите `CMultiLock` конструктор объекта внутри функции-члена в классе управляемой ресурса. Затем вызовите [блокировки](#lock) функцию-член для определения доступности ресурса (сигнал). Если он, по-прежнему дальнейшим функции-члена. Если ресурс не доступен, подождите в течение определенного времени для освобождения ресурса либо сбой запроса. После завершения использования ресурса, либо вызвать [Unlock](#unlock) работать, если `CMultiLock` объекта будет использоваться повторно, или разрешение `CMultiLock` уничтожаемого объекта.  
  
 `CMultiLock` объектов наиболее полезны, когда потоку большое количество `CEvent` может реагировать на объекты. Создайте массив, содержащий все `CEvent` указатели и вызов `Lock`. В результате поток ждать, пока одно из событий переводится в сигнальное состояние.  
  
 Дополнительные сведения об использовании `CMultiLock` объектов, см. в статье [Многопоточность: Практическое использование классов синхронизации](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `CMultiLock`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** afxmt.h  
  
##  <a name="cmultilock"></a>  CMultiLock::CMultiLock  
 Создает объект `CMultiLock`.  
  
```  
CMultiLock(
    CSyncObject* ppObjects [ ],  
    DWORD dwCount,  
    BOOL bInitialLock = FALSE);
```  
  
### <a name="parameters"></a>Параметры  
 *ppObjects*  
 Массив указателей на объекты синхронизации, чтобы использовать для ожидания. Не может принимать значение NULL.  
  
 *dwCount*  
 Число объектов в *ppObjects*. Должно быть больше 0.  
  
 *bInitialLock*  
 Указывает необходимость изначально пытаются получить доступ к любому из предоставленных объектов.  
  
### <a name="remarks"></a>Примечания  
 Эта функция вызывается после создания массива объектов синхронизации, чтобы использовать для ожидания. Она обычно вызывается из потока, который необходимо дождаться завершения одного объектов синхронизации, которые становятся доступными.  
  
##  <a name="islocked"></a>  CMultiLock::IsLocked  
 Определяет, является ли указанный объект несигнальное (недоступна).  
  
```  
BOOL IsLocked(DWORD dwItem);
```  
  
### <a name="parameters"></a>Параметры  
 *dwItem*  
 Индекс в массиве объектов, соответствующий объекту, состояние которого выполняется запрос.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если указанный объект заблокирован; в противном случае 0.  
  
##  <a name="lock"></a>  CMultiLock::Lock  
 Вызывайте эту функцию для получения доступа к одному или нескольким из ресурсы, управляемые объекты синхронизации, передаваемые `CMultiLock` конструктор.  
  
```  
DWORD Lock(
    DWORD dwTimeOut = INFINITE,  
    BOOL bWaitForAll = TRUE,  
    DWORD dwWakeMask = 0);
```  
  
### <a name="parameters"></a>Параметры  
 *dwTimeOut*  
 Указывает время ожидания объекта синхронизации доступен (сигнал). Если БЕСКОНЕЧНЫЙ, `Lock` будет ждать объект переводится в сигнальное состояние перед возвратом.  
  
 *bWaitForAll*  
 Указывает, должны принять сигнал для ожидания всех объектов, в то же время перед возвратом. Если значение равно FALSE, `Lock` возвращает, если один из объектов, для ожидания переводится в сигнальное состояние.  
  
 *dwWakeMask*  
 Указывает другие условия, которые могут прервать ожидание. Полный список доступных параметров для этого параметра, см. в разделе [MsgWaitForMultipleObjects](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) в пакете Windows SDK.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если `Lock` завершается ошибкой, возвращается - 1. В случае успешного выполнения возвращает одно из следующих значений:  
  
-   Между WAIT_OBJECT_0 и WAIT_OBJECT_0 + (число объектов - 1)  
  
     Если *bWaitForAll* имеет значение TRUE, все объекты получают сигнал (доступно). Если *bWaitForAll* имеет значение FALSE, возвращаемое значение — WAIT_OBJECT_0, — это индекс в массиве объектов объекта, который получает сигналы (доступно).  
  
- WAIT_OBJECT_0 + (число объектов)  
  
     Событие, указанное в *dwWakeMask* доступна во входной очереди для потока.  
  
-   Между WAIT_ABANDONED_0 и WAIT_ABANDONED_0 + (число объектов - 1)  
  
     Если *bWaitForAll* имеет значение TRUE, все объекты получают сигнал и по крайней мере один из объектов — это объект Брошенный мьютекс. Если *bWaitForAll* имеет значение FALSE, возвращаемое значение — WAIT_ABANDONED_0 — это индекс в массиве объектов Брошенный мьютекс объекта, удовлетворившего операцию ожидания.  
  
- WAIT_TIMEOUT  
  
     Интервал времени ожидания, указанный в *dwTimeOut* истек срок действия без ожидания успешного.  
  
### <a name="remarks"></a>Примечания  
 Если *bWaitForAll* имеет значение TRUE, `Lock` вернет успешно, как только все объекты синхронизации сигнальное одновременно. Если *bWaitForAll* имеет значение FALSE, `Lock` вернет сразу же оповещенным, один или несколько объектов синхронизации.  
  
 Если `Lock` не сможет выполнять возврат немедленно, он будет ожидать не более указанного числа миллисекунд в *dwTimeOut* параметра перед возвратом. Если *dwTimeOut* является бесконечность, `Lock` не вернет, пока не получили доступ к объекту или условие, заданное в *dwWakeMask* было выполнено. В противном случае, если `Lock` было нельзя получить объект синхронизации, будет возвращена успешно; в противном случае возвращается ошибка.  
  
##  <a name="unlock"></a>  CMultiLock::Unlock  
 Освобождает объект синхронизации, принадлежащий `CMultiLock`.  
  
```  
BOOL Unlock();

 
BOOL Unlock(
    LONG lCount,  
    LPLONG lPrevCount = NULL);
```  
  
### <a name="parameters"></a>Параметры  
 *lCount*  
 Номер ссылки счетчики для выпуска. Должно быть больше 0. Если указанного, приводит к превышению допустимого объекта счетчиком, счетчик не изменяется, и функция возвращает значение FALSE.  
  
 *lPrevCount*  
 Указывает переменную для получения счетчика для объекта синхронизации. Если значение равно NULL, возвращаются счетчика.  
  
### <a name="return-value"></a>Возвращаемое значение  
 Ненулевое значение, если функция выполнена успешно; в противном случае 0.  
  
### <a name="remarks"></a>Примечания  
 Эта функция вызывается `CMultiLock`в деструктор.  
  
 В первой форме `Unlock` пытается разблокировать объект синхронизации, управляемый `CMultiLock`. Вторая форма `Unlock` пытается разблокировать `CSemaphore` объекты, принадлежащие `CMultiLock`. Если `CMultiLock` не владеет заблокированные `CSemaphore` объект, функция возвращает FALSE; в противном случае возвращает значение TRUE. *lCount* и *lpPrevCount* точно совпадают с параметрами [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#unlock). Вторая форма `Unlock` редко применяется к multilock ситуациях.  
  
## <a name="see-also"></a>См. также  
 [Диаграмма иерархии](../../mfc/hierarchy-chart.md)



