---
title: Класс CWinAppEx
ms.date: 11/04/2016
f1_keywords:
- CWinAppEx
- AFXWINAPPEX/CWinAppEx
- AFXWINAPPEX/CWinAppEx::CWinAppEx
- AFXWINAPPEX/CWinAppEx::CleanState
- AFXWINAPPEX/CWinAppEx::EnableLoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::EnableTearOffMenus
- AFXWINAPPEX/CWinAppEx::EnableUserTools
- AFXWINAPPEX/CWinAppEx::ExitInstance
- AFXWINAPPEX/CWinAppEx::GetBinary
- AFXWINAPPEX/CWinAppEx::GetContextMenuManager
- AFXWINAPPEX/CWinAppEx::GetDataVersion
- AFXWINAPPEX/CWinAppEx::GetDataVersionMajor
- AFXWINAPPEX/CWinAppEx::GetDataVersionMinor
- AFXWINAPPEX/CWinAppEx::GetInt
- AFXWINAPPEX/CWinAppEx::GetKeyboardManager
- AFXWINAPPEX/CWinAppEx::GetMouseManager
- AFXWINAPPEX/CWinAppEx::GetObject
- AFXWINAPPEX/CWinAppEx::GetRegSectionPath
- AFXWINAPPEX/CWinAppEx::GetRegistryBase
- AFXWINAPPEX/CWinAppEx::GetSectionBinary
- AFXWINAPPEX/CWinAppEx::GetSectionInt
- AFXWINAPPEX/CWinAppEx::GetSectionObject
- AFXWINAPPEX/CWinAppEx::GetSectionString
- AFXWINAPPEX/CWinAppEx::GetShellManager
- AFXWINAPPEX/CWinAppEx::GetString
- AFXWINAPPEX/CWinAppEx::GetTooltipManager
- AFXWINAPPEX/CWinAppEx::GetUserToolsManager
- AFXWINAPPEX/CWinAppEx::InitContextMenuManager
- AFXWINAPPEX/CWinAppEx::InitKeyboardManager
- AFXWINAPPEX/CWinAppEx::InitMouseManager
- AFXWINAPPEX/CWinAppEx::InitShellManager
- AFXWINAPPEX/CWinAppEx::InitTooltipManager
- AFXWINAPPEX/CWinAppEx::IsResourceSmartUpdate
- AFXWINAPPEX/CWinAppEx::IsStateExists
- AFXWINAPPEX/CWinAppEx::LoadState
- AFXWINAPPEX/CWinAppEx::OnAppContextHelp
- AFXWINAPPEX/CWinAppEx::OnViewDoubleClick
- AFXWINAPPEX/CWinAppEx::OnWorkspaceIdle
- AFXWINAPPEX/CWinAppEx::SaveState
- AFXWINAPPEX/CWinAppEx::SetRegistryBase
- AFXWINAPPEX/CWinAppEx::ShowPopupMenu
- AFXWINAPPEX/CWinAppEx::WriteBinary
- AFXWINAPPEX/CWinAppEx::WriteInt
- AFXWINAPPEX/CWinAppEx::WriteObject
- AFXWINAPPEX/CWinAppEx::WriteSectionBinary
- AFXWINAPPEX/CWinAppEx::WriteSectionInt
- AFXWINAPPEX/CWinAppEx::WriteSectionObject
- AFXWINAPPEX/CWinAppEx::WriteSectionString
- AFXWINAPPEX/CWinAppEx::WriteString
- AFXWINAPPEX/CWinAppEx::LoadCustomState
- AFXWINAPPEX/CWinAppEx::LoadWindowPlacement
- AFXWINAPPEX/CWinAppEx::OnClosingMainFrame
- AFXWINAPPEX/CWinAppEx::PreLoadState
- AFXWINAPPEX/CWinAppEx::PreSaveState
- AFXWINAPPEX/CWinAppEx::ReloadWindowPlacement
- AFXWINAPPEX/CWinAppEx::SaveCustomState
- AFXWINAPPEX/CWinAppEx::StoreWindowPlacement
- AFXWINAPPEX/CWinAppEx::m_bForceImageReset
helpviewer_keywords:
- CWinAppEx [MFC], CWinAppEx
- CWinAppEx [MFC], CleanState
- CWinAppEx [MFC], EnableLoadWindowPlacement
- CWinAppEx [MFC], EnableTearOffMenus
- CWinAppEx [MFC], EnableUserTools
- CWinAppEx [MFC], ExitInstance
- CWinAppEx [MFC], GetBinary
- CWinAppEx [MFC], GetContextMenuManager
- CWinAppEx [MFC], GetDataVersion
- CWinAppEx [MFC], GetDataVersionMajor
- CWinAppEx [MFC], GetDataVersionMinor
- CWinAppEx [MFC], GetInt
- CWinAppEx [MFC], GetKeyboardManager
- CWinAppEx [MFC], GetMouseManager
- CWinAppEx [MFC], GetObject
- CWinAppEx [MFC], GetRegSectionPath
- CWinAppEx [MFC], GetRegistryBase
- CWinAppEx [MFC], GetSectionBinary
- CWinAppEx [MFC], GetSectionInt
- CWinAppEx [MFC], GetSectionObject
- CWinAppEx [MFC], GetSectionString
- CWinAppEx [MFC], GetShellManager
- CWinAppEx [MFC], GetString
- CWinAppEx [MFC], GetTooltipManager
- CWinAppEx [MFC], GetUserToolsManager
- CWinAppEx [MFC], InitContextMenuManager
- CWinAppEx [MFC], InitKeyboardManager
- CWinAppEx [MFC], InitMouseManager
- CWinAppEx [MFC], InitShellManager
- CWinAppEx [MFC], InitTooltipManager
- CWinAppEx [MFC], IsResourceSmartUpdate
- CWinAppEx [MFC], IsStateExists
- CWinAppEx [MFC], LoadState
- CWinAppEx [MFC], OnAppContextHelp
- CWinAppEx [MFC], OnViewDoubleClick
- CWinAppEx [MFC], OnWorkspaceIdle
- CWinAppEx [MFC], SaveState
- CWinAppEx [MFC], SetRegistryBase
- CWinAppEx [MFC], ShowPopupMenu
- CWinAppEx [MFC], WriteBinary
- CWinAppEx [MFC], WriteInt
- CWinAppEx [MFC], WriteObject
- CWinAppEx [MFC], WriteSectionBinary
- CWinAppEx [MFC], WriteSectionInt
- CWinAppEx [MFC], WriteSectionObject
- CWinAppEx [MFC], WriteSectionString
- CWinAppEx [MFC], WriteString
- CWinAppEx [MFC], LoadCustomState
- CWinAppEx [MFC], LoadWindowPlacement
- CWinAppEx [MFC], OnClosingMainFrame
- CWinAppEx [MFC], PreLoadState
- CWinAppEx [MFC], PreSaveState
- CWinAppEx [MFC], ReloadWindowPlacement
- CWinAppEx [MFC], SaveCustomState
- CWinAppEx [MFC], StoreWindowPlacement
- CWinAppEx [MFC], m_bForceImageReset
ms.assetid: a3d3e053-3e22-463f-9444-c73abb1bb9d7
ms.openlocfilehash: b630a588d6c7ec81a22a9665deb0fa7517f90dc8
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81750651"
---
# <a name="cwinappex-class"></a>Класс CWinAppEx

`CWinAppEx`обрабатывает состояние приложения, сохраняет состояние в реестре, загружает государство из реестра, инициализирует менеджеров приложений и предоставляет ссылки на тех же менеджеров приложений.

Для получения более подробной информации смотрите исходный код, расположенный в папке **VC\\atlmfc\\src\\mfc** установки Visual Studio.

## <a name="syntax"></a>Синтаксис

```
class CWinAppEx : public CWinApp
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CWinAppEx::CWinAppEx](#cwinappex)|Формирует объект `CWinAppEx`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CWinAppEx::Чистое государство](#cleanstate)|Удаляет информацию о приложении из реестра Windows.|
|[CWinAppEx::EnableLoadWindowPlacement](#enableloadwindowplacement)|Уточняется, будет ли приложение загружать первоначальный размер и расположение окна основного кадра из реестра.|
|[CWinAppEx::EnableTearOffMenus](#enabletearoffmenus)|Включает в себя отрывать меню для приложения.|
|[CWinAppEx:EnableUserTools](#enableusertools)|Позволяет пользователю создавать пользовательские команды меню в приложении.|
|[CWinAppEx::ExitInstance](#exitinstance)|Вызывается по системе `Run` из функции члена, чтобы выйти из этого экземпляра приложения. (Переопределяет [CWinApp::ExitInstance](../../mfc/reference/cwinapp-class.md#exitinstance).)|
|[CWinAppEx::GetBinary](#getbinary)|Читает двоичные данные, связанные с указанным значением реестра.|
|[CWinAppEx::GetContextMenuManager](#getcontextmenumanager)|Возвращает указатель на глобальный объект [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md)|
|[CWinAppEx::GetDataVersion](#getdataversion)||
|[CWinAppEx::GetDataVersionMajor](#getdataversionmajor)|Возвращает основную версию приложения, сохраненную в реестре Windows.|
|[CWinAppEx::GetDataVersionМин](#getdataversionminor)|Возвращает незначительную версию приложения, сохраненную в реестре Windows.|
|[CWinAppEx::GetInt](#getint)|Читает числовые данные, связанные с указанным значением из реестра.|
|[CWinAppEx::GetKeyboardManager](#getkeyboardmanager)|Возвращает указатель на глобальный объект [CKeyboardManager.](../../mfc/reference/ckeyboardmanager-class.md)|
|[CWinAppEx::GetMouseManager](#getmousemanager)|Возвращает указатель на глобальный объект [CMouseManager.](../../mfc/reference/cmousemanager-class.md)|
|[CWinAppEx::GetObject](#getobject)|Читает `CObject`-полученные данные, связанные с указанным значением из реестра.|
|[CWinAppEx::GetRegSectionPath](#getregsectionpath)|Возвращает строку, которая является траекторией ключа реестра. Этот путь совмещеет поставляемый относительный путь с траекторией приложения.|
|[CWinAppEx:GetRegistryBase](#getregistrybase)|Возвращает путь реестра для приложения.|
|[CWinAppEx::GetSectionBinary](#getsectionbinary)|Читает двоичные данные, связанные с указанным ключом и значением из реестра.|
|[CWinAppEx::GetSectionInt](#getsectionint)|Читает числовые данные из реестра, связанные с указанным ключом и значением.|
|[CWinAppEx::GetSectionObject](#getsectionobject)|Читает `CObject` данные, связанные с указанным ключом и значением из реестра.|
|[CWinAppEx::GetSectionString](#getsectionstring)|Читает строки данных, связанных с указанным ключом и значением из реестра.|
|[CWinAppEx::GetShellManager](#getshellmanager)|Возвращает указатель на глобальный объект [CShellManager.](../../mfc/reference/cshellmanager-class.md)|
|[CWinAppEx::GetString](#getstring)|Читает строки данных, связанных с указанным значением из реестра.|
|[CWinAppEx::GetTooltipManager](#gettooltipmanager)|Возвращает указатель на глобальный объект [CTooltipManager.](../../mfc/reference/ctooltipmanager-class.md)|
|[CWinAppEx::GetUserToolsManager](#getusertoolsmanager)|Возвращает указатель на глобальный объект [CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)|
|[CWinAppEx::InitContextMenuManager](#initcontextmenumanager)|Инициализирует объект `CContextMenuManager`.|
|[CWinAppEx::InitKeyboardManager](#initkeyboardmanager)|Инициализирует объект `CKeyboardManager`.|
|[CWinAppEx::InitMouseManager](#initmousemanager)|Инициализирует объект `CMouseManager`.|
|[CWinAppEx::InitShellManager](#initshellmanager)|Инициализация `CShellManager` класса|
|[CWinAppEx::InitTooltipManager](#inittooltipmanager)|Инициализирует класс `CTooltipManager`.|
|[CWinAppEx::IsResourceSmartUpdate](#isresourcesmartupdate)||
|[CWinAppEx::IsstateExists](#isstateexists)|Указывает, находится ли указанный ключ в реестре.|
|[CWinAppEx::LoadState](#loadstate)|Загружает состояние приложения из реестра.|
|[CWinAppEx::OnAppContextHelp](#onappcontexthelp)|Вызывается в рамках, когда пользователь запрашивает контекст помощь для **настройки** диалогового окна.|
|[CWinAppEx::OnViewDoubleClick](#onviewdoubleclick)|Вызывает команду, определяемую пользователем, когда пользователь дважды щелкает в любом месте приложения.|
|[CWinAppEx::OnWorkspaceidle](#onworkspaceidle)||
|[CWinAppEx::SaveState](#savestate)|Записывает состояние платформы приложения в реестр Windows.|
|[CWinAppEx::SetRegistryBase](#setregistrybase)|Устанавливает путь ключа реестра по умолчанию. Этот ключ будет служить корнем для всех последующих вызовов реестра.|
|[CWinAppEx::ShowPopupMenu](#showpopupmenu)|Отображает всплывающее меню.|
|[CWinAppEx::WriteBinary](#writebinary)|Записывает двоичные данные в указанное значение реестра.|
|[CWinAppEx::WriteInt](#writeint)|Записывает числовые данные в указанное значение реестра.|
|[CWinAppEx::WriteObject](#writeobject)|Записывает данные, полученные из [класса CObject,](../../mfc/reference/cobject-class.md) в указанное значение реестра.|
|[CWinAppEx::WriteSectionBinary](#writesectionbinary)|Записывает двоичные данные на значение указанного ключа реестра.|
|[CWinAppEx::WriteSectionInt](#writesectionint)|Записывает числовые данные на значение указанного ключа реестра.|
|[CWinAppEx::WriteSectionObject](#writesectionobject)|Записывает данные, `CObject` полученные из класса, на значение указанного ключа реестра.|
|[CWinAppEx::WriteSectionString](#writesectionstring)|Записывает данные строки на значение указанного ключа реестра.|
|[CWinAppEx::WriteString](#writestring)|Записывает данные строки в указанное значение реестра.|

### <a name="protected-methods"></a>Защищенные методы

|Имя|Описание|
|----------|-----------------|
|[CWinAppEx::LoadCustomState](#loadcustomstate)|Вызывается инфраструктурой при загрузке состояния приложения.|
|[CWinAppEx::LoadWindow](#loadwindowplacement)|Вызывается по системе, когда он загружает размер и местоположение приложения из реестра. Загруженные данные включают размер и расположение основного кадра на момент последнего закрытия приложения.|
|[CWinAppEx::OnClosingMainFrame](#onclosingmainframe)|Вызывается фреймворком при обработке основного окна кадра WM_CLOSE.|
|[CWinAppEx::PreloadState](#preloadstate)|Вызывается инфраструктурой непосредственно перед загрузкой состояния приложения.|
|[CWinAppEx::PreSaveState](#presavestate)|Вызывается инфраструктурой непосредственно перед сохранением состояния приложения.|
|[CWinAppEx::ПерезагрузкаОкно](#reloadwindowplacement)|Перезагружает размер и расположение поставляемого окна из реестра|
|[CWinAppEx::SaveCustomState](#savecustomstate)|Вызывается рамочным после того, как он записывает состояние приложения в реестр.|
|[CWinAppEx::StoreWindowPlacement](#storewindowplacement)|Вызывается по структуре, чтобы написать размер и расположение основной кадр в реестр.|

### <a name="data-members"></a>Элементы данных

|Имя|Описание|
|----------|-----------------|
|[CWinAppEx::m_bForceImageReset](#m_bforceimagereset)|Определяет, будет ли фреймворк сбросить все изображения панели инструментов при загрузке окна кадра, содержащего панель инструментов.|

## <a name="remarks"></a>Remarks

Большая часть функциональности, предоставляемой рамкой `CWinAppEx` MFC, зависит от класса. Вы можете `CWinAppEx` включить класс в приложение одним из двух способов:

- Постройте `CWinAppEx` класс в основной нити.

- Выизвуйте `CWinAppEx`основной класс приложения из .

После включения `CWinAppEx` в приложение можно инициализировать любого из менеджеров приложений. Перед использованием менеджера приложения необходимо инициализировать его, позвонив по соответствующему методу инициализации. Чтобы получить указатель для конкретного менеджера, позвоните в связанный метод получения. Класс `CWinAppEx` управляет следующими менеджерами приложений: [CMouseManager Class,](../../mfc/reference/cmousemanager-class.md) [CContextMenuManager Class,](../../mfc/reference/ccontextmenumanager-class.md) [CKeyboardManager Class,](../../mfc/reference/ckeyboardmanager-class.md) [CUserToolsManager Class](../../mfc/reference/cusertoolsmanager-class.md)и [CMenuTearOffManager Class.](../../mfc/reference/cmenutearoffmanager-class.md)

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

[Cwinapp](../../mfc/reference/cwinapp-class.md)

[CWinAppEx](../../mfc/reference/cwinappex-class.md)

## <a name="requirements"></a>Требования

**Заголовок:** afxwinappex.h

## <a name="cwinappexcleanstate"></a><a name="cleanstate"></a>CWinAppEx::Чистое государство

Удаляет всю информацию о приложении из реестра Windows.

```
virtual BOOL CleanState(LPCTSTR lpszSectionName=NULL);
```

### <a name="parameters"></a>Параметры

*lpszSectionName*<br/>
(в) Строка, содержащая путь ключа реестра.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод был успешным; в противном случае 0.

### <a name="remarks"></a>Remarks

Этот метод очищает данные приложения из определенного раздела реестра. Вы можете указать раздел, чтобы очистить с помощью параметра *lpszSectionName*. Если *lpszSectionName* является NULL, этот метод будет использовать `CWinAppEx` путь реестра по умолчанию, хранящийся в объекте. Чтобы получить путь реестра по умолчанию, используйте [CWinAppEx::GetRegistryBase](#getregistrybase).

## <a name="cwinappexcwinappex"></a><a name="cwinappex"></a>CWinAppEx::CWinAppEx

Формирует объект `CWinAppEx`.

```
CWinAppEx(BOOL bResourceSmartUpdate = FALSE);
```

### <a name="parameters"></a>Параметры

*bResourceSmartUpdate*<br/>
(в) Параметр Boolean, который определяет, должен ли объект рабочей области обнаруживать и обрабатывать обновления ресурсов.

### <a name="remarks"></a>Remarks

Класс `CWinAppEx` имеет методы инициализации, предоставляет функциональность для сохранения и загрузки информации о заявках в реестр и контролирует глобальные настройки приложения. Он также позволяет использовать глобальные менеджеры, такие как [класс CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md) и [CUserToolsManager класса.](../../mfc/reference/cusertoolsmanager-class.md) Каждое приложение может иметь `CWinAppEx` только один экземпляр класса.

## <a name="cwinappexenableloadwindowplacement"></a><a name="enableloadwindowplacement"></a>CWinAppEx::EnableLoadWindowPlacement

Уточняется, будет ли приложение загружать первоначальный размер и расположение окна основного кадра из реестра.

```cpp
void EnableLoadWindowPlacement(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>Параметры

*bEnable*<br/>
(в) Уточняется, загружает ли приложение первоначальный размер и расположение окна основного кадра из реестра.

### <a name="remarks"></a>Remarks

По умолчанию размер и расположение основной кадра загружаются из реестра вместе с другими настройками приложения. Это происходит во время [CWinAppEx::LoadState](#loadstate). Если вы не хотите загружать начальное размещение окна из реестра, позвоните по этому методу с *bEnable,* установленным на FALSE.

## <a name="cwinappexenabletearoffmenus"></a><a name="enabletearoffmenus"></a>CWinAppEx::EnableTearOffMenus

Создает и инициализирует объект [CMenuTearOffManager.](../../mfc/reference/cmenutearoffmanager-class.md)

```
BOOL EnableTearOffMenus(
    LPCTSTR lpszRegEntry,
    const UINT uiCmdFirst,
    const UINT uiCmdLast);
```

### <a name="parameters"></a>Параметры

*lpszRegEntry*<br/>
(в) Строка, содержащая путь ключа реестра. Приложение использует этот ключ реестра для хранения информации для отрыва меню.

*uiCmdFirst*<br/>
(в) Первый отрывать идентификатор меню.

*uiCmdLast*<br/>
(в) Последний идентификатор меню.

### <a name="return-value"></a>Возвращаемое значение

TRUE, `CMenuTearOffManager` если создан и инициализирован успешно; FALSE, если ошибка происходит `CMenuTearOffManager` или если уже существует.

### <a name="remarks"></a>Remarks

Используйте эту функцию, чтобы включить отрывменю в приложении. Вы должны вызвать `InitInstance`эту функцию от .

## <a name="cwinappexenableusertools"></a><a name="enableusertools"></a>CWinAppEx:EnableUserTools

Позволяет пользователю создавать пользовательские команды меню, которые уменьшают нажатия клавиш в приложении. Этот метод создает объект [CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)

```
BOOL EnableUserTools(
    const UINT uiCmdToolsDummy,
    const UINT uiCmdFirst,
    const UINT uiCmdLast,
    CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool),
    UINT uArgMenuID = 0,
    UINT uInitDirMenuID = 0);
```

### <a name="parameters"></a>Параметры

*uiCmdToolsDummy*<br/>
(в) Неподписанный целый ряд, который фреймворк использует в качестве заполнителя для идентификатора команды меню пользовательских инструментов.

*uiCmdFirst*<br/>
(в) Идентификатор команды для первой команды пользователя.

*uiCmdLast*<br/>
(в) Идентификатор команды для последней команды пользователя.

*pToolRTC*<br/>
(в) Класс, который `CUserToolsManager` объект использует для создания новых пользовательских инструментов.

*uArgMenuID*<br/>
(в) Идентификатор меню аргумента.

*uInitDirMenuID*<br/>
(в) Идентификатор меню для начального каталога инструментов.

### <a name="return-value"></a>Возвращаемое значение

TRUE, если метод создает и `CUserToolsManager` инициализирует объект; FALSE, если метод выходит `CUserToolsManager` из строя или если объект уже существует.

### <a name="remarks"></a>Remarks

При включении инструментов, определяемых пользователем, фреймворк автоматически поддерживает динамическое меню, которое может быть расширено во время настройки. Платформа связывает каждый новый элемент с внешней командой. Фрейм вызывает эти команды, когда пользователь выбирает подходящий элемент из меню **Инструментов.**

Каждый раз, когда пользователь добавляет новый элемент, фреймворк создает новый объект. Тип класса для нового объекта определяется *pToolRTC.* Тип класса *pToolRTC* должен быть получен из [класса CUserTool.](../../mfc/reference/cusertool-class.md)

Для получения дополнительной информации об инструментах пользователей [User-defined Tools](../../mfc/user-defined-tools.md)и о том, как включить их в приложение, см.

## <a name="cwinappexexitinstance"></a><a name="exitinstance"></a>CWinAppEx::ExitInstance

```
virtual int ExitInstance();
```

### <a name="return-value"></a>Возвращаемое значение

### <a name="remarks"></a>Remarks

## <a name="cwinappexgetbinary"></a><a name="getbinary"></a>CWinAppEx::GetBinary

Читает двоичные данные из указанного ключа реестра.

```
BOOL GetBinary(
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая имя ключа реестра.

*ppData*<br/>
(ваут) Указатель на буфер, который метод заполняет двоичными данными.

*pBytes*<br/>
(ваут) Указатель на неподписанный целый ряд, который метод использует для записи прочитаемого количества байтов.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE в случае успешного выполнения. В противном случае — значение FALSE.

### <a name="remarks"></a>Remarks

Этот метод считывает двоичные данные, записанные в реестр. Чтобы записать данные в реестр, используйте методы [CWinAppEx::WriteBinary](#writebinary) и [CWinAppEx::WriteSectionBinary](#writesectionbinary).

Параметр *lpszEntry* — это имя входа в реестр, расположенного под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetcontextmenumanager"></a><a name="getcontextmenumanager"></a>CWinAppEx::GetContextMenuManager

Возвращает указатель на глобальный объект [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md)

```
CContextMenuManager* GetContextMenuManager();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на глобальный `CContextMenuManager` объект.

### <a name="remarks"></a>Remarks

Если объект CContextMenuManager не инициализирован, эта функция вызывает [CWinAppEx::InitContextMenuManager](#initcontextmenumanager) перед его возвратом указателя.

## <a name="cwinappexgetdataversion"></a><a name="getdataversion"></a>CWinAppEx::GetDataVersion

```
int GetDataVersion() const;
```

### <a name="return-value"></a>Возвращаемое значение

### <a name="remarks"></a>Remarks

## <a name="cwinappexgetdataversionmajor"></a><a name="getdataversionmajor"></a>CWinAppEx::GetDataVersionMajor

Возвращает основную версию приложения, которая сохраняется в реестре Windows при вызове [CWinAppEx::SaveState](#savestate).

```
int GetDataVersionMajor() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение целых рядов, содержащее основной номер версии.

## <a name="cwinappexgetdataversionminor"></a><a name="getdataversionminor"></a>CWinAppEx::GetDataVersionМин

Возвращает незначительную версию приложения, которая сохраняется в реестре Windows при вызове [CWinAppEx::SaveState](#savestate).

```
int GetDataVersionMinor() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение целых рядов, содержащее номер незначительной версии.

## <a name="cwinappexgetint"></a><a name="getint"></a>CWinAppEx::GetInt

Читает рядданных данных из указанного ключа реестра.

```
int GetInt(
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая название регистрации.

*nДефолт*<br/>
(в) Значение по умолчанию, которое возвращает метод, если указанная запись реестра не существует.

### <a name="return-value"></a>Возвращаемое значение

Данные реестра, если метод был успешным; в противном случае *nDefault*.

### <a name="remarks"></a>Remarks

Этот метод считывает несколько данных из реестра. Если нет рядовых данных, связанных с ключом реестра, указанным *lpszEntry,* этот метод возвращает *nDefault.* Чтобы записать данные в реестр, используйте методы [CWinAppEx::WriteSectionInt](#writesectionint) и [CWinAppEx::WriteInt](#writeint).

Параметр *lpszEntry* — это имя входа в реестр, расположенного под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetkeyboardmanager"></a><a name="getkeyboardmanager"></a>CWinAppEx::GetKeyboardManager

Возвращает указатель на глобальный объект [CKeyboardManager.](../../mfc/reference/ckeyboardmanager-class.md)

```
CKeyboardManager* GetKeyboardManager();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на глобальный `CKeyboardManager` объект.

### <a name="remarks"></a>Remarks

Если клавиатурный менеджер не инициализирован, эта функция вызывает [CWinAppEx::InitKeyboardManager,](#initkeyboardmanager) прежде чем он возвращает указатель.

## <a name="cwinappexgetmousemanager"></a><a name="getmousemanager"></a>CWinAppEx::GetMouseManager

Возвращает указатель на глобальный объект [CMouseManager.](../../mfc/reference/cmousemanager-class.md)

```
CMouseManager* GetMouseManager();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на глобальный `CMouseManager` объект.

### <a name="remarks"></a>Remarks

Если менеджер мыши не инициализирован, эта функция вызывает [CWinAppEx::InitMouseManager,](#initmousemanager) прежде чем он возвращает указатель.

## <a name="cwinappexgetobject"></a><a name="getobject"></a>CWinAppEx::GetObject

Читает [CObject-данные](../../mfc/reference/cobject-class.md)из реестра.

```
BOOL GetObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая относительный путь ввода реестра.

*obj*<br/>
(ваут) Ссылка на `CObject`. Метод использует эту ссылку для хранения данных реестра.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод был успешным; в противном случае 0.

### <a name="remarks"></a>Remarks

Этот метод считывает данные из `CObject`реестра, которые получены из . Чтобы `CObject` записать данные в реестр, используйте [CWinAppEx::WriteObject](#writeobject) или [CWinAppEx::WriteSectionObject](#writesectionobject).

Параметр *lpszEntry* — это имя входа в реестр, который находится под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetregistrybase"></a><a name="getregistrybase"></a>CWinAppEx:GetRegistryBase

Извлекает путь реестра по умолчанию для приложения.

```
LPCTSTR GetRegistryBase();
```

### <a name="return-value"></a>Возвращаемое значение

Строка, содержащая путь расположения реестра по умолчанию.

### <a name="remarks"></a>Remarks

Все методы [класса CWinAppEx,](../../mfc/reference/cwinappex-class.md) которые получают доступ к реестру, начинаются в месте выполнения по умолчанию. Используйте этот метод для получения пути расположения реестра по умолчанию. Используйте [CWinAppEx::SetRegistryBase](#setregistrybase) для изменения местоположения реестра по умолчанию.

## <a name="cwinappexgetregsectionpath"></a><a name="getregsectionpath"></a>CWinAppEx::GetRegSectionPath

Создает и возвращает абсолютный путь ключа реестра.

```
CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));
```

### <a name="parameters"></a>Параметры

*szSectionAdd*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

### <a name="return-value"></a>Возвращаемое значение

A, `CString` содержащий абсолютный путь ключа реестра.

### <a name="remarks"></a>Remarks

Этот метод определяет абсолютный путь ключа реестра, добавляя относительный путь в *szSectionAdd* к местоположению реестра по умолчанию для вашего приложения. Чтобы получить ключ реестра по умолчанию, используйте метод [CWinAppEx::GetRegistryBase](#getregistrybase).

## <a name="cwinappexgetsectionbinary"></a><a name="getsectionbinary"></a>CWinAppEx::GetSectionBinary

Читает двоичные данные из реестра.

```
BOOL GetSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая значение для чтения.

*ppData*<br/>
(ваут) Указатель на буфер, в котором метод хранит данные.

*pBytes*<br/>
(ваут) Указатель на неподписанный ряд. Метод записывает размер *ppData* по этому параметру.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если успешно; в противном случае — FALSE.

### <a name="remarks"></a>Remarks

Этот метод считывает двоичные данные, которые записываются в реестр с помощью методов [CWinAppEx::WriteBinary](#writebinary) и [CWinAppEx::WriteSectionBinary](#writesectionbinary).

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetsectionint"></a><a name="getsectionint"></a>CWinAppEx::GetSectionInt

Читает данные из реестра.

```
int GetSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nDefault = 0);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая значение для чтения.

*nДефолт*<br/>
(в) Значение по умолчанию для возврата, если указанное значение не существует.

### <a name="return-value"></a>Возвращаемое значение

Неопределимые данные, хранящиеся в указанном значении реестра; *nDefault,* если данные не существуют.

### <a name="remarks"></a>Remarks

Используйте методы [CWinAppEx::WriteInt](#writeint) и [CWinAppEx::WriteSectionInt](#writesectionint) для записи неосема данных в реестр.

Параметр *lpszSubSection* не является абсолютным путем вступления в реестр. Это относительный путь, который добавляется к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetsectionobject"></a><a name="getsectionobject"></a>CWinAppEx::GetSectionObject

Читает данные реестра [CObject](../../mfc/reference/cobject-class.md) из реестра.

```
BOOL GetSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая значение для чтения.

*obj*<br/>
(ваут) Ссылка на `CObject`. Метод использует `CObject` это для хранения данных реестра.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

### <a name="remarks"></a>Remarks

Этот метод считывает данные из реестра. Чтение данных `CObject` — это данные или `CObject`данные для класса, полученные из. Чтобы `CObject` записать данные в реестр, используйте [CWinAppEx::WriteObject](#writeobject) или [CWinAppEx::WriteSectionObject](#writesectionobject).

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetsectionstring"></a><a name="getsectionstring"></a>CWinAppEx::GetSectionString

Читает строки данных из реестра.

```
CString GetSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = _T(""));
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая значение для чтения.

*lpszDefault*<br/>
(в) Значение по умолчанию для возврата, если указанное значение не существует.

### <a name="return-value"></a>Возвращаемое значение

Данные строки, хранящиеся в указанном значении реестра, если данные существуют; в противном случае *lpszDefault*.

### <a name="remarks"></a>Remarks

Этот метод считывает строковые данные, записанные в реестр. Используйте [CWinAppEx::WriteString](#writestring) и [CWinAppEx::WriteSectionString](#writesectionstring) для записи строки данных в реестр.

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgetshellmanager"></a><a name="getshellmanager"></a>CWinAppEx::GetShellManager

Возвращает указатель на глобальный объект [CShellManager.](../../mfc/reference/cshellmanager-class.md)

```
CShellManager* GetShellManager();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на глобальный `CShellManager` объект.

### <a name="remarks"></a>Remarks

Если `CShellManager` объект не инициализирован, эта функция вызывает [CWinAppEx::InitShellManager,](#initshellmanager) прежде чем он возвращает указатель.

## <a name="cwinappexgetstring"></a><a name="getstring"></a>CWinAppEx::GetString

Читает строки данных из указанного ключа реестра.

```
CString GetString(
    LPCTSTR lpszEntry,
    LPCTSTR lpzDefault= _T(""));
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая имя ключа реестра

*lpzDefault*<br/>
(в) Значение по умолчанию, которое возвращает метод, если указанная запись реестра не существует.

### <a name="return-value"></a>Возвращаемое значение

Строка данных, хранящихся в реестре в случае успеха; *lpszDefault* в противном случае.

### <a name="remarks"></a>Remarks

Этот метод считывает строковые данные, записанные в реестр. Чтобы записать данные в реестр, используйте методы [CWinAppEx::WriteString](#writestring) или [CWinAppEx::WriteSectionString](#writesectionstring).

Параметр *lpszEntry* — это имя входа в реестр, расположенного под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexgettooltipmanager"></a><a name="gettooltipmanager"></a>CWinAppEx::GetTooltipManager

Возвращает указатель на глобальный объект [CTooltipManager.](../../mfc/reference/ctooltipmanager-class.md)

```
CTooltipManager* GetTooltipManager();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на глобальный `CTooltipManager` объект.

### <a name="remarks"></a>Remarks

Если `CTooltipManager` объект не инициализирован, эта функция вызывает [CWinAppEx::InitTooltipManager,](#inittooltipmanager) прежде чем он возвращает указатель.

## <a name="cwinappexgetusertoolsmanager"></a><a name="getusertoolsmanager"></a>CWinAppEx::GetUserToolsManager

Возвращает указатель на глобальный объект [CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)

```
CUserToolsManager* GetUserToolsManager();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на глобальный `CUserToolsManager` объект; NULL, если управление инструментами пользователя не включено для приложения.

### <a name="remarks"></a>Remarks

Перед тем, как получить `CUserToolsManager` указатель на объект, необходимо инициализировать менеджера, позвонив по [cWinAppEx::EnableUserTools.](#enableusertools)

## <a name="cwinappexinitcontextmenumanager"></a><a name="initcontextmenumanager"></a>CWinAppEx::InitContextMenuManager

Инициализирует объект [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md)

```
BOOL InitContextMenuManager();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод создает объект CContextMenuManager; 0, `CContextMenuManager` если объект уже существует.

### <a name="remarks"></a>Remarks

Если вы [звоните CWinAppEx::GetContextMenuManager](#getcontextmenumanager), реализация `InitContextMenuManager`этого метода по умолчанию вызывает .

Если в приложении уже есть менеджер `InitContextMenuManager`контекстного меню и вы звоните, ваше приложение будет иметь сбой [ASSERT.](diagnostic-services.md#assert) Поэтому не следует `InitContextMenuManager` звонить, если `CContextMenuManager` вы создаете объект напрямую. Если вы не используете пользовательский, `CContextMenuManager`вы должны использовать `GetContextMenuManager` для создания `CContextMenuManager` объекта.

## <a name="cwinappexinitkeyboardmanager"></a><a name="initkeyboardmanager"></a>CWinAppEx::InitKeyboardManager

Инициализирует объект [CKeyboardManager.](../../mfc/reference/ckeyboardmanager-class.md)

```
BOOL InitKeyboardManager();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод `CKeyboardManager` создает объект; 0, `CKeyboardManager` если объект уже существует.

### <a name="remarks"></a>Remarks

Если вы [звоните CWinAppEx::GetKeyboardManager](#getkeyboardmanager), реализация `InitKeyboardManager`этого метода по умолчанию вызывает.

Если в вашем приложении уже `InitKeyboardManager`есть менеджер клавиатуры, и вы звоните, ваше приложение будет иметь [сбой ASSERT.](diagnostic-services.md#assert) Поэтому не следует `InitKeyboardManager` звонить, если `CKeyboardManager` вы создаете объект напрямую. Если вы не используете пользовательский, `CKeyboardManager`вы должны использовать `GetKeyboardManager` для создания `CKeyboardManager` объекта.

## <a name="cwinappexinitmousemanager"></a><a name="initmousemanager"></a>CWinAppEx::InitMouseManager

Инициализирует объект [CMouseManager.](../../mfc/reference/cmousemanager-class.md)

```
BOOL InitMouseManager();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод `CMouseManager` создает объект; 0, `CMouseManager` если объект уже существует.

### <a name="remarks"></a>Remarks

Если вы [звоните CWinAppEx::GetMouseManager](#getmousemanager), реализация `InitMouseManager`этого метода по умолчанию вызывает.

Если в вашем приложении уже `InitMouseManager`есть менеджер мыши, и вы звоните, ваше приложение будет иметь [сбой ASSERT.](diagnostic-services.md#assert) Поэтому не следует `InitMouseManager` звонить, `CMouseManager` если вы создаете объект напрямую. Если вы не используете пользовательский, `CMouseManager`вы должны использовать `GetMouseManager` для создания `CMouseManager` объекта.

## <a name="cwinappexinitshellmanager"></a><a name="initshellmanager"></a>CWinAppEx::InitShellManager

Инициализирует объект [CShellManager.](../../mfc/reference/cshellmanager-class.md)

```
BOOL InitShellManager();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод `CShellManager` создает объект; 0, `CShellManager` если объект уже существует.

### <a name="remarks"></a>Remarks

Если вы [звоните CWinAppEx::GetShellManager](#getshellmanager), реализация `InitShellManager`этого метода по умолчанию вызывает.

Если в вашем приложении уже `InitShellManager`есть менеджер оболочки и вы звоните, ваше приложение вызывает сбой [ASSERT.](diagnostic-services.md#assert) Поэтому не звоните, `InitShellManager` если `CShellManager` вы создаете объект напрямую. Если вы не используете `GetShellManager` пользовательский, `CShellManager` `CShellManager`используйте для создания объекта.

## <a name="cwinappexinittooltipmanager"></a><a name="inittooltipmanager"></a>CWinAppEx::InitTooltipManager

Инициализирует объект [CTooltipManager.](../../mfc/reference/ctooltipmanager-class.md)

```
BOOL InitTooltipManager();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод `CTooltipManager` создает объект; 0, `CTooltipManager` если объект уже существует.

### <a name="remarks"></a>Remarks

Если вы [звоните CWinAppEx::GetTooltipManager](#gettooltipmanager), реализация `InitTooltipManager`этого метода по умолчанию вызывает.

Если в вашем приложении уже есть `InitTooltipManager`менеджер наборов инструментов, и вы звоните, ваше приложение будет иметь сбой [ASSERT.](diagnostic-services.md#assert) Поэтому не следует `InitTooltipManager` звонить, если `CTooltipManager` вы создаете объект напрямую. Если вы не используете пользовательский, `CTooltipManager`вы должны использовать `GetTooltipManager` для создания `CTooltipManager` объекта.

## <a name="cwinappexisresourcesmartupdate"></a><a name="isresourcesmartupdate"></a>CWinAppEx::IsResourceSmartUpdate

```
BOOL IsResourceSmartUpdate() const;
```

### <a name="return-value"></a>Возвращаемое значение

### <a name="remarks"></a>Remarks

## <a name="cwinappexisstateexists"></a><a name="isstateexists"></a>CWinAppEx::IsstateExists

Указывает, находится ли указанный ключ в реестре.

```
BOOL IsStateExists(LPCTSTR lpszSectionName);
```

### <a name="parameters"></a>Параметры

*lpszSectionName*<br/>
(в) Строка, содержащая путь ключа реестра.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если ключ находится в реестре; в противном случае 0.

## <a name="cwinappexloadcustomstate"></a><a name="loadcustomstate"></a>CWinAppEx::LoadCustomState

Платформа вызывает этот метод после того, как он загружает состояние приложения из реестра.

```
virtual void LoadCustomState();
```

### <a name="remarks"></a>Remarks

Переопределить этот метод, если вы хотите сделать любую обработку после того, как приложение загружает состояние из реестра. По умолчанию этот метод не выполняет никаких действий.

Для загрузки пользовательской информации о состоянии из реестра, информация должна быть сохранена с помощью [CWinAppEx::SaveCustomState](#savecustomstate).

## <a name="cwinappexloadstate"></a><a name="loadstate"></a>CWinAppEx::LoadState

Читает состояние приложения из реестра Windows.

```
BOOL LoadState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL LoadState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

virtual BOOL LoadState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);
```

### <a name="parameters"></a>Параметры

*pFrame*<br/>
(в) Указатель на объект окна кадра. Метод применяет государственную информацию в реестре к этому окну кадра.

*lpszSectionName*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*pFrameImpl*<br/>
(в) Указатель на `CFrameImpl` объект. Метод применяет государственную информацию в реестре к этому окну кадра.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение в случае успешного выполнения. В противном случае — 0.

### <a name="remarks"></a>Remarks

Этот метод загружает состояние приложения и любую информацию о состоянии для окна кадра. Загруженная информация для окна рамы наносится на поставляемое окно рамы. Если вы не предоставите окно рамы, загружается только информация о состоянии приложения. Информация о заявке включает в себя состояние [класса CMouseManager,](../../mfc/reference/cmousemanager-class.md) [класса CContextMenuManager,](../../mfc/reference/ccontextmenumanager-class.md) [класса CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)и [класса CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)

Реализация вызовов `CFrameImpl::OnLoadFrame` `LoadState`по умолчанию.

Параметр *lpszSectionName* не является абсолютным путем для входа в реестр. Это относительный путь, который добавляется к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexloadwindowplacement"></a><a name="loadwindowplacement"></a>CWinAppEx::LoadWindow

Вызывается по фрейму, когда он загружает размер и расположение окна основного кадра из реестра.

```
virtual BOOL LoadWindowPlacement(
    CRect& rectNormalPosition,
    int& nFlags,
    int& nShowCmd);
```

### <a name="parameters"></a>Параметры

*rectNormalPosition*<br/>
(ваут) Прямоугольник, содержащий координаты окна основного кадра, когда он находится в восстановленном положении.

*nФлаги*<br/>
(ваут) Флаги, контролирующие положение окна минимизированного окна и то, как операционная система переключается между сведенным минимумом окном и восстановленным окном.

*nShowCmd*<br/>
(ваут) Неисчерп, который определяет состояние шоу окна. Для получения дополнительной информации о возможных значениях см. [CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow).

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение в случае успешного выполнения. В противном случае — 0.

### <a name="remarks"></a>Remarks

По умолчанию MFC автоматически загружает предыдущее положение и состояние окна основного кадра при запуске приложения. Для получения дополнительной информации о том, как эта информация хранится в реестре, [см. CWinAppEx::StoreWindowPlacement](#storewindowplacement).

Переопределить этот метод, если вы хотите загрузить дополнительную информацию о главном окне кадра.

## <a name="cwinappexm_bforceimagereset"></a><a name="m_bforceimagereset"></a>CWinAppEx::m_bForceImageReset

Определяет, сбрасывает ли фреймворк все изображения панели инструментов при перезагрузке окна кадра, содержащего панель инструментов.

```
BOOL m_bForceImageReset;
```

### <a name="remarks"></a>Remarks

Член `m_bForceImageReset` данных является защищенной переменной.

## <a name="cwinappexonappcontexthelp"></a><a name="onappcontexthelp"></a>CWinAppEx::OnAppContextHelp

Платформа вызывает этот метод, когда пользователь запрашивает справку о контексте для окна диалога **настройки.**

```
virtual void OnAppContextHelp(
    CWnd* pWndControl,
    const DWORD dwHelpIDArray[]);
```

### <a name="parameters"></a>Параметры

*pWndControl*<br/>
(в) Указатель на объект окна, для которого пользователь вызвал помощь контекста.

*dwHelpIDArray*<br/>
(в) Зарезервированное значение.

### <a name="remarks"></a>Remarks

Этот метод в настоящее время зарезервирован для использования в будущем. Реализация по умолчанию ничего не делает, и в настоящее время она не называется инфраструктурой.

## <a name="cwinappexonclosingmainframe"></a><a name="onclosingmainframe"></a>CWinAppEx::OnClosingMainFrame

Рамочная система вызывает этот метод при обработке окна кадра WM_CLOSE.

```
virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
```

### <a name="parameters"></a>Параметры

*pFrameImpl*<br/>
(в) Указатель на `CFrameImpl` объект.

### <a name="remarks"></a>Remarks

Реализация этого метода по умолчанию сохраняет состояние *pFrameImpl.*

## <a name="cwinappexonviewdoubleclick"></a><a name="onviewdoubleclick"></a>CWinAppEx::OnViewDoubleClick

Вызывает команду, определяемую пользователем, которая связана с представлением, когда пользователь дважды щелкает в любом месте этого представления.

```
virtual BOOL OnViewDoubleClick(
    CWnd* pWnd,
    int iViewId);
```

### <a name="parameters"></a>Параметры

*pWnd*<br/>
(в) Указатель на объект, полученный из [класса CView.](../../mfc/reference/cview-class.md)

*iViewId*<br/>
(в) Идентификатор представления.

### <a name="return-value"></a>Возвращаемое значение

TRUE, если фреймворк находит команду; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Для поддержки пользовательского поведения мыши необходимо вызвать эту функцию при обработке сообщения WM_LBUTTONDBLCLK. Этот метод будет выполнять команду, связанную с идентификатором представления, поставляемым *iViewId.* Для получения дополнительной информации о пользовательском поведении мыши, см [Клавиатура и мышь настройки](../../mfc/keyboard-and-mouse-customization.md).

## <a name="cwinappexonworkspaceidle"></a><a name="onworkspaceidle"></a>CWinAppEx::OnWorkspaceidle

```
virtual BOOL OnWorkspaceIdle(CWnd*);
```

### <a name="parameters"></a>Параметры

(в) *CWnd&#38;*<br/>

### <a name="return-value"></a>Возвращаемое значение

### <a name="remarks"></a>Remarks

## <a name="cwinappexpreloadstate"></a><a name="preloadstate"></a>CWinAppEx::PreloadState

Рамочная система вызывает этот метод непосредственно перед загрузкой состояния приложения из реестра.

```
virtual void PreLoadState();
```

### <a name="remarks"></a>Remarks

Переопределить этот метод, если вы хотите сделать любую обработку непосредственно перед тем, как фреймворк загружает состояние приложения.

## <a name="cwinappexpresavestate"></a><a name="presavestate"></a>CWinAppEx::PreSaveState

Платформа вызывает этот метод непосредственно перед сохранением состояния приложения.

```
virtual void PreSaveState();
```

### <a name="remarks"></a>Remarks

Переопределить этот метод, если требуется сделать любую обработку непосредственно перед тем, как платформа сохранит состояние приложения.

## <a name="cwinappexreloadwindowplacement"></a><a name="reloadwindowplacement"></a>CWinAppEx::ПерезагрузкаОкно

Перезагружает размер и расположение окна из реестра.

```
virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);
```

### <a name="parameters"></a>Параметры

*pFrame*<br/>
(в) Указатель на окно рамы.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если метод был успешным; 0, если нагрузка не удалась или нет данных для загрузки.

### <a name="remarks"></a>Remarks

Используйте функцию [CWinAppEx::StoreWindowPlacement,](#storewindowplacement) чтобы написать размер и расположение окна в реестр.

## <a name="cwinappexsavecustomstate"></a><a name="savecustomstate"></a>CWinAppEx::SaveCustomState

Платформа вызывает этот метод после того, как он сохраняет состояние приложения в реестре.

```
virtual void SaveCustomState();
```

### <a name="remarks"></a>Remarks

Переопределить этот метод, если вы хотите сделать любую обработку после того, как приложение сохраняет состояние в реестре. По умолчанию этот метод не выполняет никаких действий.

## <a name="cwinappexsavestate"></a><a name="savestate"></a>CWinAppEx::SaveState

Записывает состояние приложения в реестр Windows.

```
virtual BOOL SaveState(
    LPCTSTR lpszSectionName = NULL,
    CFrameImpl* pFrameImpl = NULL);

BOOL SaveState(
    CMDIFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    CFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);

BOOL SaveState(
    COleIPFrameWndEx* pFrame,
    LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>Параметры

*lpszSectionName*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*pFrameImpl*<br/>
(в) Указатель на `CFrameImpl` объект. Этот кадр сохраняется в реестре Windows.

*pFrame*<br/>
(в) Указатель на объект окна кадра. Этот кадр сохраняется в реестре Windows.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE в случае успешного выполнения. В противном случае — значение FALSE.

### <a name="remarks"></a>Remarks

Этот метод сохраняет состояние приложения и любую информацию о состоянии для предоставленного окна кадра. Если окно кадра не предоставляется, метод сохраняет только состояние приложения. Информация о заявке включает в себя состояние [класса CMouseManager,](../../mfc/reference/cmousemanager-class.md) [класса CContextMenuManager,](../../mfc/reference/ccontextmenumanager-class.md) [класса CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)и [класса CUserToolsManager.](../../mfc/reference/cusertoolsmanager-class.md)

Параметр *lpszSectionName* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

## <a name="cwinappexsetregistrybase"></a><a name="setregistrybase"></a>CWinAppEx::SetRegistryBase

Устанавливает путь реестра по умолчанию для приложения.

```
LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
```

### <a name="parameters"></a>Параметры

*lpszSectionName*<br/>
(в) Строка, содержащая путь ключа реестра.

### <a name="return-value"></a>Возвращаемое значение

Строка, содержащая путь расположения реестра по умолчанию.

### <a name="remarks"></a>Remarks

Все методы [класса CWinAppEx,](../../mfc/reference/cwinappex-class.md) которые получают доступ к реестру, начинаются в месте выполнения по умолчанию. Используйте этот метод, чтобы изменить местоположение реестра по умолчанию. Используйте [CWinAppEx::GetRegistryBase](#getregistrybase) для получения местоположения реестра по умолчанию.

## <a name="cwinappexshowpopupmenu"></a><a name="showpopupmenu"></a>CWinAppEx::ShowPopupMenu

Отображает всплывающее меню.

```
virtual BOOL ShowPopupMenu(
    UINT uiMenuResId,
    const CPoint& point,
    CWnd* pWnd);
```

### <a name="parameters"></a>Параметры

*uiMenuResId*<br/>
(в) Идентификатор ресурса меню.

*Точки*<br/>
(в) [CPoint,](../../atl-mfc-shared/reference/cpoint-class.md) который определяет положение меню в координатах экрана.

*pWnd*<br/>
(в) Указатель на окно, которое владеет всплывающее меню.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если всплывающее меню отображается успешно; 0 в противном случае.

### <a name="remarks"></a>Remarks

Этот метод отображает меню, связанное с *uiMenuResId*.

Для поддержки всплывающих меню необходимо иметь объект [CContextMenuManager.](../../mfc/reference/ccontextmenumanager-class.md) Если вы не инициализировали `CContextMenuManager` объект, `ShowPopupMenu` не удастся.

## <a name="cwinappexstorewindowplacement"></a><a name="storewindowplacement"></a>CWinAppEx::StoreWindowPlacement

Вызывается по фреймворку, чтобы написать размер и расположение окна основного кадра в реестр.

```
virtual BOOL StoreWindowPlacement(
    const CRect& rectNormalPosition,
    int nFlags,
    int nShowCmd);
```

### <a name="parameters"></a>Параметры

*nФлаги*<br/>
(в) Флаги, контролирующие положение окна минимизированного окна и то, как операционная система переключается между сведенным минимумом окном и восстановленным окном.

*nShowCmd*<br/>
(в) Неисчерп, который определяет состояние шоу окна. Для получения дополнительной информации о возможных значениях см. [CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow).

*rectNormalPosition*<br/>
(в) Прямоугольник, содержащий координаты окна основного кадра, когда он находится в восстановленном состоянии.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение в случае успешного выполнения. В противном случае — 0.

### <a name="remarks"></a>Remarks

По умолчанию MFC автоматически сохраняет положение и состояние окна основного кадра перед выходом приложения. Эта информация хранится в реестре Windows под ключом WindowPlacement в месте расположения реестра по умолчанию для приложения. Для получения дополнительной информации о местонахождении реестра по умолчанию вашего приложения, [см. CWinAppEx::GetRegistryBase](#getregistrybase).

Переувитрите этот метод, если вы хотите сохранить дополнительную информацию о главном окне кадра.

## <a name="cwinappexwritebinary"></a><a name="writebinary"></a>CWinAppEx::WriteBinary

Записывает двоичные данные в реестр.

```
BOOL WriteBinary(
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая имя ключа реестра.

*Pdata*<br/>
(в) Данные для хранения.

*nБайт*<br/>
(в) Размер *pData* в байтах.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszEntry* — это имя входа в реестр, который находится под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

Если ключ, указанный *lpszEntry,* не существует, этот метод создаст его.

## <a name="cwinappexwriteint"></a><a name="writeint"></a>CWinAppEx::WriteInt

Записывает числовые данные в реестр.

```
BOOL WriteInt(
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая имя ключа реестра.

*nValue*<br/>
(в) Данные для хранения.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszEntry* — это имя входа в реестр, расположенного под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

Если ключ, указанный *lpszEntry,* не существует, этот метод создаст его.

## <a name="cwinappexwriteobject"></a><a name="writeobject"></a>CWinAppEx::WriteObject

Записывает данные, полученные из [класса CObject,](../../mfc/reference/cobject-class.md) в реестр.

```
BOOL WriteObject(
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая значение для установки.

*obj*<br/>
(в) Ссылка `CObject` на данные, которые будет хранить метод.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Этот метод записывает данные *obj* к указанному значению под ключом реестра по умолчанию. Используйте [CWinAppEx::GetRegistryBase](#getregistrybase) для определения текущего ключа реестра.

## <a name="cwinappexwritesectionbinary"></a><a name="writesectionbinary"></a>CWinAppEx::WriteSectionBinary

Записывает двоичные данные на значение в реестре.

```
BOOL WriteSectionBinary(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая имя ключа реестра

*lpszEntry*<br/>
(в) Строка, содержащая значение для установки.

*Pdata*<br/>
(в) Данные для записи в реестр.

*nБайт*<br/>
(в) Размер *pData* в байтах.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

Если ключ, указанный *lpszEntry,* не существует, этот метод создаст его.

## <a name="cwinappexwritesectionint"></a><a name="writesectionint"></a>CWinAppEx::WriteSectionInt

Записывает числовые данные в реестр.

```
BOOL WriteSectionInt(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая относительный путь ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая значение для установки.

*nValue*<br/>
(в) Данные для записи в реестр.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к ключу реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

Если ключ, указанный *lpszEntry,* не существует, этот метод создаст его.

## <a name="cwinappexwritesectionobject"></a><a name="writesectionobject"></a>CWinAppEx::WriteSectionObject

Записывает данные, полученные из [класса CObject,](../../mfc/reference/cobject-class.md) в определенное значение реестра.

```
BOOL WriteSectionObject(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    CObject& obj);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая имя ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая имя значения для установки.

*obj*<br/>
(в) Данные для хранения.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase), соответственно.

Если значение, указанное *lpszEntry,* не существует в ключе реестра, указанном *lpszSubSection,* этот метод создаст это значение.

## <a name="cwinappexwritesectionstring"></a><a name="writesectionstring"></a>CWinAppEx::WriteSectionString

Записывает строки данных на значение в реестре.

```
BOOL WriteSectionString(
    LPCTSTR lpszSubSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Параметры

*lpszSubSection*<br/>
(в) Строка, содержащая имя ключа реестра.

*lpszEntry*<br/>
(в) Строка, содержащая значение для установки.

*lpszValue*<br/>
(в) Данные строки для записи в реестр.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszSubSection* не является абсолютным путем для входа в реестр. Это относительный путь, который придатим к концу ключа реестра по умолчанию для приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase), соответственно.

Если значение, указанное *lpszEntry,* не существует в *lpszSubSection,* этот метод создаст его.

## <a name="cwinappexwritestring"></a><a name="writestring"></a>CWinAppEx::WriteString

Записывает строки данных в реестр.

```
BOOL WriteString(
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Параметры

*lpszEntry*<br/>
(в) Строка, содержащая имя ключа реестра.

*lpszValue*<br/>
(в) Данные для хранения.

### <a name="return-value"></a>Возвращаемое значение

ПРАВДА, если этот метод является успешным; в противном случае FALSE.

### <a name="remarks"></a>Remarks

Параметр *lpszEntry* — это имя входа в реестр, расположенного под ключом реестра по умолчанию для вашего приложения. Чтобы получить или установить ключ реестра по умолчанию, используйте методы [CWinAppEx::GetRegistryBase](#getregistrybase) и [CWinAppEx::SetRegistryBase](#setregistrybase) соответственно.

Если ключ, указанный *lspzEntry,* не существует, этот метод создаст его.

## <a name="see-also"></a>См. также раздел

[Диаграмма иерархии](../../mfc/hierarchy-chart.md)<br/>
[Классы](../../mfc/reference/mfc-classes.md)<br/>
[Класс CWinApp](../../mfc/reference/cwinapp-class.md)<br/>
[Класс CMouseManager](../../mfc/reference/cmousemanager-class.md)<br/>
[Класс CContextMenuManager](../../mfc/reference/ccontextmenumanager-class.md)<br/>
[Класс CKeyboardManager](../../mfc/reference/ckeyboardmanager-class.md)<br/>
[Класс CUserToolsManager](../../mfc/reference/cusertoolsmanager-class.md)
