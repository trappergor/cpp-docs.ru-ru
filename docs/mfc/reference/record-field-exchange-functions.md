---
title: Функции обмена данными полями записей
ms.date: 09/17/2019
f1_keywords:
- AFXDB/RFX_Binary
- AFXDB/RFX_Bool
- AFXDB/RFX_Byte
- AFXDB/RFX_Date
- AFXDB/RFX_Double
- AFXDB/RFX_Int
- AFXDB/RFX_Long
- AFXDB/RFX_LongBinary
- AFXDB/RFX_Single
- AFXDB/RFX_Text
- AFXDB/RFX_Binary_Bulk
- AFXDB/RFX_Bool_Bulk
- AFXDB/RFX_Byte_Bulk
- AFXDB/RFX_Date_Bulk
- AFXDB/RFX_Double_Bulk
- AFXDB/RFX_Int_Bulk
- AFXDB/RFX_Long_Bulk
- AFXDB/RFX_Single_Bulk
- AFXDB/RFX_Text_Bulk
- AFXDB/DFX_Binary
- AFXDB/DFX_Bool
- AFXDB/DFX_Byte
- AFXDB/DFX_Currency
- AFXDB/DFX_DateTime
- AFXDB/DFX_Double
- AFXDB/DFX_Long
- AFXDB/DFX_LongBinary
- AFXDB/DFX_Short
- AFXDB/DFX_Single
- AFXDB/DFX_Text
helpviewer_keywords:
- DAO (Data Access Objects), record field exchange (DFX)
- ODBC, bulk RFX data exchange functions [MFC]
- RFX (record field exchange), ODBC classes
- DFX (DAO record field exchange), data exchange functions [MFC]
- DFX functions [MFC]
- bulk RFX functions [MFC]
- DFX (DAO record field exchange)
- RFX (record field exchange), DAO classes
- ODBC, RFX
- RFX (record field exchange), data exchange functions [MFC]
- RFX (record field exchange)
ms.assetid: 6e4c5c1c-acb7-4c18-bf51-bf7959a696cd
ms.openlocfilehash: 491b00fe65634acf7c8805dd471fa6e3cc62acf0
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79426609"
---
# <a name="record-field-exchange-functions"></a>Функции обмена данными полями записей

В этом разделе перечислены функции обмена полями записей (RFX, Bulk RFX и DFX), используемые для автоматизации передачи данных между объектом набора записей и источником данных и выполнения других операций с данными.

При использовании классов на основе ODBC и реализации массовой выборки строк необходимо вручную переопределить функцию-член `DoBulkFieldExchange``CRecordset` путем вызова функций Bulk RFX для каждого элемента данных, соответствующего столбцу источника данных.

Если вы не реализовали многострочную выборку строк в классах на основе ODBC или используете классы на основе DAO (устарели), ClassWizard переопределит функцию-член `DoFieldExchange` `CRecordset` или `CDaoRecordset`, вызвав функции RFX (для классов ODBC) или функции DFX (для классов DAO) для каждого элемента данных поля в наборе записей.

Функции обмена полями записей передают данные каждый раз, когда платформа вызывает `DoFieldExchange` или `DoBulkFieldExchange`. Каждая функция передает определенный тип данных.

Дополнительные сведения об использовании этих функций см. в статьях [Обмен полями записей: принцип работы RFX (ODBC)](../../data/odbc/record-field-exchange-how-rfx-works.md). Дополнительные сведения о массовой выборке строк см. в статье [Набор записей: пакетная выборка строк (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

Для столбцов данных с динамической привязкой можно самостоятельно вызвать функции RFX и DFX, как описано в статьях [Набор записей. Динамическая привязка столбцов данных (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md). Кроме того, можно написать собственные подпрограммы RFX и DFX, как описано в техническом примечании [43](../../mfc/tn043-rfx-routines.md) (для ODBC) и техническом примечании [53](../../mfc/tn053-custom-dfx-routines-for-dao-database-classes.md) (для DAO).

Пример функций RFX и функции групповой RFX, которые отображаются в функциях `DoFieldExchange` и `DoBulkFieldExchange`, см. в разделе [RFX_Text](#rfx_text) и [RFX_Text_Bulk] #rfx_text_bulk). Функции DFX очень похожи на функции RFX.

### <a name="rfx-functions-odbc"></a>Функции RFX (ODBC)

|||
|-|-|
|[RFX_Binary](#rfx_binary)|Передает массивы байтов типа [CByteArray](cbytearray-class.md).|
|[RFX_Bool](#rfx_bool)|Передает логический тип данных.|
|[RFX_Byte](#rfx_byte)|Передает один байт данных.|
|[RFX_Date](#rfx_date)|Передает данные времени и даты с помощью [CTime](../../atl-mfc-shared/reference/ctime-class.md) или TIMESTAMP_STRUCT.|
|[RFX_Double](#rfx_double)|Передает данные двойной точности с плавающей запятой.|
|[RFX_Int](#rfx_int)|Передает целочисленные данные.|
|[RFX_Long](#rfx_long)|Передает длинные целые данные.|
|[RFX_LongBinary](#rfx_longbinary)|Передает данные больших двоичных объектов (BLOB) с объектом класса [CLongBinary](clongbinary-class.md) .|
|[RFX_Single](#rfx_single)|Передает данные с плавающей запятой.|
|[RFX_Text](#rfx_text)|Передает строковые данные.|

### <a name="bulk-rfx-functions-odbc"></a>Функции Bulk RFX (ODBC)

|||
|-|-|
|[RFX_Binary_Bulk](#rfx_binary_bulk)|Передает массивы байтов данных.|
|[RFX_Bool_Bulk](#rfx_bool_bulk)|Передает массивы логических данных.|
|[RFX_Byte_Bulk](#rfx_byte_bulk)|Передает массивы отдельных байтов.|
|[RFX_Date_Bulk](#rfx_date_bulk)|Передает массивы данных типа TIMESTAMP_STRUCT.|
|[RFX_Double_Bulk](#rfx_double_bulk)|Передает массивы данных двойной точности с плавающей запятой.|
|[RFX_Int_Bulk](#rfx_int_bulk)|Передает массивы целочисленных данных.|
|[RFX_Long_Bulk](#rfx_long_bulk)|Передает массивы длинных целых данных.|
|[RFX_Single_Bulk](#rfx_single_bulk)|Передает массивы данных с плавающей запятой.|
|[RFX_Text_Bulk](#rfx_text_bulk)|Передает массивы данных типа LPSTR.|

### <a name="dfx-functions-dao"></a>Функции DFX (DAO)

|||
|-|-|
|[DFX_Binary](#dfx_binary)|Передает массивы байтов типа [CByteArray](cbytearray-class.md).|
|[DFX_Bool](#dfx_bool)|Передает логический тип данных.|
|[DFX_Byte](#dfx_byte)|Передает один байт данных.|
|[DFX_Currency](#dfx_currency)|Передает данные денежных единиц типа [COleCurrency](colecurrency-class.md).|
|[DFX_DateTime](#dfx_datetime)|Передает данные даты и времени типа [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md).|
|[DFX_Double](#dfx_double)|Передает данные двойной точности с плавающей запятой.|
|[DFX_Long](#dfx_long)|Передает длинные целые данные.|
|[DFX_LongBinary](#dfx_longbinary)|Передает данные больших двоичных объектов (BLOB) с объектом класса `CLongBinary` . Для DAO рекомендуется использовать [DFX_Binary](#dfx_binary) .|
|[DFX_Short](#dfx_short)|Передает короткие целые данные.|
|[DFX_Single](#dfx_single)|Передает данные с плавающей запятой.|
|[DFX_Text](#dfx_text)|Передает строковые данные.|

=============================================

## <a name="rfx_binary"></a>  RFX_Binary

Передает массивы байтов между элементами данных поля объекта `CRecordset` и столбцами записи в источнике данных типа ODBC SQL_BINARY, SQL_VARBINARY или SQL_LONGVARBINARY.

### <a name="syntax"></a>Синтаксис

```
void RFX_Binary(
   CFieldExchange* pFX,
   const char* szName,
   CByteArray& value,
   int nMaxLength = 255);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа [CByteArray](cbytearray-class.md)берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*нмаксленгс*<br/>
Максимально допустимая длина передаваемой строки или массива. Значение по умолчанию для *нмаксленгс* — 255. Допустимые значения: от 1 до INT_MAX. Платформа выделяет этот объем пространства для данных. Для лучшей производительности передайте значение, достаточное для размещения самого большого элемента данных.

### <a name="remarks"></a>Remarks

Данные в источнике данных этих типов сопоставляются с типом `CByteArray` в наборе записей.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_bool"></a>  RFX_Bool

Передает логические данные между элементами данных поля `CRecordset` объекта и столбцами записи в источнике данных ODBC типа SQL_BIT.

### <a name="syntax"></a>Синтаксис

```
void RFX_Bool(
   CFieldExchange* pFX,
   const char* szName,
   BOOL& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа BOOL берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_byte"></a>  RFX_Byte

Передает отдельные байты между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных ODBC типа SQL_TINYINT.

### <a name="syntax"></a>Синтаксис

```
void RFX_Byte(
   CFieldExchange* pFX,
   const char* szName,
   BYTE& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа BYTE берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_date"></a>  RFX_Date

Передает `CTime` или TIMESTAMP_STRUCT данные между элементами данных поля `CRecordset` объекта и столбцами записи в источнике данных типа ODBC SQL_DATE, SQL_TIME или SQL_TIMESTAMP.

### <a name="syntax"></a>Синтаксис

```
void RFX_Date(
   CFieldExchange* pFX,
   const char* szName,
   CTime& value);

void RFX_Date(
   CFieldExchange* pFX,
   const char* szName,
   TIMESTAMP_STRUCT& value);

void RFX_Date(
   CFieldExchange* pFX,
   const char* szName,
   COleDateTime& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном члене данных; значение для передачи. Различные версии функции принимают разные типы данных для значения:

Первая версия функции принимает ссылку на объект [CTime](../../atl-mfc-shared/reference/ctime-class.md) . Для перемещения из набора записей в источник данных это значение берется из указанного элемента данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

Вторая версия функции принимает ссылку на структуру `TIMESTAMP_STRUCT`. Эту структуру необходимо настроить перед вызовом. Для этой версии не предусмотрена поддержка обмена данными диалоговых окон (DDX) и мастера кода. Третья версия функции работает аналогично первой версии, за исключением того, что она принимает ссылку на объект [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) .

### <a name="remarks"></a>Remarks

`CTime`ная версия функции накладывает дополнительную нагрузку на промежуточную обработку и имеет несколько ограниченный диапазон. Если вы обнаружите, что одно из этих факторов слишком ограничено, используйте вторую версию функции. Но обратите внимание на отсутствие мастера кода и поддержку DDX, а также о необходимости самостоятельной настройки структуры.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_double"></a>  RFX_Double

Передает данные типа **Double с плавающей запятой** между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных SQL_DOUBLE типов ODBC.

### <a name="syntax"></a>Синтаксис

```
void RFX_Double(
   CFieldExchange* pFX,
   const char* szName,
   double& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **Double**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_int"></a>  RFX_Int

Передает целочисленные данные между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных ODBC типа SQL_SMALLINT.

### <a name="syntax"></a>Синтаксис

```
void RFX_Int(
   CFieldExchange* pFX,
   const char* szName,
   int& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **int**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_long"></a>  RFX_Long

Передает длинные целочисленные данные между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных ODBC типа SQL_INTEGER.

### <a name="syntax"></a>Синтаксис

```
void RFX_Long(
   CFieldExchange* pFX,
   const char* szName,
   LONG&
value );
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **Long**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_longbinary"></a>  RFX_LongBinary

Передает данные больших двоичных объектов (BLOB) с помощью класса [CLongBinary](clongbinary-class.md) между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных типа ODBC SQL_LONGVARBINARY или SQL_LONGVARCHAR.

### <a name="syntax"></a>Синтаксис

```
void RFX_LongBinary(
   CFieldExchange* pFX,
   const char* szName,
   CLongBinary& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа `CLongBinary`берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_single"></a>  RFX_Single

Передает данные с плавающей запятой между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных типа ODBC SQL_REAL.

### <a name="syntax"></a>Синтаксис

```
void RFX_Single(
   CFieldExchange* pFX,
   const char* szName,
   float& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **float**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_text"></a>  RFX_Text

Передает `CString` данные между элементами данных поля `CRecordset` объекта и столбцами записи в источнике данных типа ODBC SQL_LONGVARCHAR, SQL_CHAR, SQL_VARCHAR, SQL_DECIMAL или SQL_NUMERIC.

### <a name="syntax"></a>Синтаксис

```
void RFX_Text(
   CFieldExchange* pFX,
   const char* szName,
   CString& value,
   int nMaxLength = 255,
   int nColumnType = SQL_VARCHAR,
   short nScale = 0);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса `CFieldExchange`. Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа `CString`берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*нмаксленгс*<br/>
Максимально допустимая длина передаваемой строки или массива. Значение по умолчанию для *нмаксленгс* — 255. Допустимые значения: от 1 до INT_MAX). Платформа выделяет этот объем пространства для данных. Для лучшей производительности передайте значение, достаточное для размещения самого большого элемента данных.

*нколумнтипе*<br/>
Используется в основном для параметров. Целое число, указывающее тип данных параметра. Тип является типом данных ODBC в форме **SQL_XXX**.

*нскале*<br/>
Задает масштаб для значений типа ODBC SQL_DECIMAL или SQL_NUMERIC. *нскале* полезен только при задании значений параметров. Дополнительные сведения см. в разделе "точность, масштаб, Длина и размер дисплея" в приложении г из *справочника по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Данные в источнике данных всех этих типов сопоставляются с `CString` в наборе записей.

### <a name="example"></a>Пример

В этом примере показано несколько вызовов `RFX_Text`. Обратите также внимание на два вызова `CFieldExchange::SetFieldType`. Для параметров необходимо написать вызов `SetFieldType` и его вызов RFX. Вызов выходного столбца и связанные с ним вызовы RFX обычно записываются мастером кода.

```cpp
void CCustomer::DoFieldExchange(CFieldExchange* pFX)
{
   pFX->SetFieldType(CFieldExchange::outputColumn);
   // Macros such as RFX_Text() and RFX_Int() are dependent on the
   // type of the member variable, not the type of the field in the database.
   // ODBC will try to automatically convert the column value to the requested type
   RFX_Long(pFX, _T("[CustomerID]"), m_CustomerID);
   RFX_Text(pFX, _T("[ContactFirstName]"), m_ContactFirstName);
   RFX_Text(pFX, _T("[PostalCode]"), m_PostalCode);
   RFX_Text(pFX, _T("[L_Name]"), m_L_Name);
   RFX_Long(pFX, _T("[BillingID]"), m_BillingID);

   pFX->SetFieldType(CFieldExchange::inputParam);
   RFX_Text(pFX, _T("Param"), m_strParam);
}
```

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_binary_bulk"></a>  RFX_Binary_Bulk

Передает несколько строк байтовых данных из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Binary_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   BYTE** prgByteVals,
   long** prgLengths,
   int nMaxLength);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргбитевалс*<br/>
Указатель на массив БАЙТовых значений. Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргбитевалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

*нмаксленгс*<br/>
Максимально допустимая длина значений, хранящихся в массиве, на который указывает *пргбитевалс*. Чтобы гарантировать, что данные не будут обрезаны, передайте значение, достаточное для размещения самого большого элемента данных.

### <a name="remarks"></a>Remarks

Столбец источника данных может иметь тип ODBC SQL_BINARY, SQL_VARBINARY или SQL_LONGVARBINARY. Набор записей должен определять элемент данных поля типа pointer на BYTE.

Если инициализировать *пргбитевалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_bool_bulk"></a>  RFX_Bool_Bulk

Передает несколько строк логических данных из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Bool_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   BOOL** prgBoolVals,
   long** prgLengths);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргбулвалс*<br/>
Указатель на массив значений BOOL. Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргбулвалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Столбец источника данных должен иметь тип ODBC SQL_BIT. Набор записей должен определять элемент данных поля типа pointer на BOOL.

Если инициализировать *пргбулвалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_byte_bulk"></a>  RFX_Byte_Bulk

Передает несколько строк из одного байта из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Byte_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   BYTE** prgByteVals,
   long** prgLengths);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргбитевалс*<br/>
Указатель на массив БАЙТовых значений. Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргбитевалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Столбец источника данных должен иметь тип ODBC SQL_TINYINT. Набор записей должен определять элемент данных поля типа pointer на BYTE.

Если инициализировать *пргбитевалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_date_bulk"></a>  RFX_Date_Bulk

Передает несколько строк данных TIMESTAMP_STRUCT из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Date_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   TIMESTAMP_STRUCT** prgTSVals,
   long** prgLengths);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргтсвалс*<br/>
Указатель на массив значений TIMESTAMP_STRUCT. Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей. Дополнительные сведения о типе данных TIMESTAMP_STRUCT см. в разделе «Типы данных C» в приложении г из *справочника по программированию для ODBC SDK*.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргтсвалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Столбец источника данных может иметь тип ODBC SQL_DATE, SQL_TIME или SQL_TIMESTAMP. Набор записей должен определять элемент данных поля типа pointer на TIMESTAMP_STRUCT.

Если инициализировать *пргтсвалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_double_bulk"></a>  RFX_Double_Bulk

Передает несколько строк данных двойной точности с плавающей запятой из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Double_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   double** prgDblVals,
   long** prgLengths);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргдблвалс*<br/>
Указатель на массив значений **типа Double** . Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргдблвалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Столбец источника данных должен иметь тип ODBC SQL_DOUBLE. Набор записей должен определять элемент данных поля типа pointer на **Double**.

Если инициализировать *пргдблвалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_int_bulk"></a>  RFX_Int_Bulk

Передает целочисленные данные между элементами данных поля `CRecordset`ного объекта и столбцами записи в источнике данных ODBC типа SQL_SMALLINT.

### <a name="syntax"></a>Синтаксис

```
void RFX_Int(
   CFieldExchange* pFX,
   const char* szName,
   int& value);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кфиелдексчанже](cfieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения об операциях, которые может указывать `CFieldExchange` объект, см. в статье [Обмен данными с полями статей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **int**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

### <a name="example"></a>Пример

См. [RFX_Text](#rfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_long_bulk"></a>  RFX_Long_Bulk

Передает несколько строк длинных целочисленных данных из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Long_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   long** prgLongVals,
   long** prgLengths);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*прглонгвалс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *прглонгвалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Столбец источника данных должен иметь тип ODBC SQL_INTEGER. Набор записей должен определять элемент данных поля типа pointer на **Long**.

Если инициализировать *прглонгвалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_single_bulk"></a>  RFX_Single_Bulk

Передает несколько строк данных с плавающей запятой из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Single_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   float** prgFltVals,
   long** prgLengths);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргфлтвалс*<br/>
Указатель на массив значений с **плавающей запятой** . Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргфлтвалс*. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

### <a name="remarks"></a>Remarks

Столбец источника данных должен иметь тип ODBC SQL_REAL. Набор записей должен определять элемент данных поля типа pointer на **float**.

Если инициализировать *пргфлтвалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

См. [RFX_Text_Bulk](#rfx_text_bulk).

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="rfx_text_bulk"></a>  RFX_Text_Bulk

Передает несколько строк символьных данных из столбца источника данных ODBC в соответствующий массив в объекте, производном от `CRecordset`.

### <a name="syntax"></a>Синтаксис

```
void RFX_Text_Bulk(
   CFieldExchange* pFX,
   LPCTSTR szName,
   LPSTR* prgStrVals,
   long** prgLengths,
   int nMaxLength);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект [кфиелдексчанже](cfieldexchange-class.md) . Этот объект содержит сведения, определяющие контекст для каждого вызова функции. Дополнительные сведения см. в статье [Обмен полями записей статьи: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md).

*szName*<br/>
Имя столбца данных.

*пргстрвалс*<br/>
Указатель на массив значений LPSTR. Этот массив будет хранить данные, которые будут переданы из источника данных в набор записей. Обратите внимание, что в текущей версии ODBC эти значения не могут быть в Юникоде.

*пргленгсс*<br/>
Указатель на массив длинных целых чисел. Этот массив будет хранить длину в байтах каждого значения в массиве, на которое указывает *пргстрвалс*. Эта длина исключает завершающий символ null. Обратите внимание, что значение SQL_NULL_DATA будет сохранено, если соответствующий элемент данных содержит значение null. Дополнительные сведения см. в описании функции API ODBC `SQLBindCol` в *справочнике по программированию для ODBC SDK*.

*нмаксленгс*<br/>
Максимально допустимая длина значений, хранящихся в массиве, на который указывает *пргстрвалс*, включая завершающий символ null. Чтобы гарантировать, что данные не будут обрезаны, передайте значение, достаточное для размещения самого большого элемента данных.

### <a name="remarks"></a>Remarks

Столбец источника данных может иметь тип ODBC SQL_LONGVARCHAR, SQL_CHAR, SQL_VARCHAR, SQL_DECIMAL или SQL_NUMERIC. Набор записей должен определять элемент данных поля типа LPSTR.

Если инициализировать *пргстрвалс* и *пргленгсс* в NULL, то массивы, на которые они указывают, будут выделены автоматически, а размеры равны размеру набора строк.

> [!NOTE]
>  Обмен полями с массовыми записями передает данные только из источника данных в объект набора записей. Чтобы сделать набор записей обновляемым, необходимо использовать функцию API ODBC `SQLSetPos`.

Дополнительные сведения см. в статье [набор записей: выборка записей в групповой операции (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md) и [Обмен ПОЛЯМИ записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

### <a name="example"></a>Пример

Необходимо вручную написать вызовы в переопределении `DoBulkFieldExchange`. В этом примере показан вызов `RFX_Text_Bulk`, а также вызов `RFX_Long_Bulk`для передачи данных. Этим вызовам предшествует вызов [кфиелдексчанже:: сетфиелдтипе](CFieldExchange::SetFieldType.md). Обратите внимание, что для параметров необходимо вызвать функции RFX вместо функций, выполняющих функции групповой RFX.

```cpp
void CMultiCustomer::DoBulkFieldExchange(CFieldExchange* pFX)
{
   pFX->SetFieldType(CFieldExchange::outputColumn);
   RFX_Long_Bulk(pFX, _T("[CustomerID]"), &m_pCustomerID, &m_pcCustomerID);
   RFX_Text_Bulk(pFX, _T("[ContactFirstName]"), &m_pContactFirstName, &m_pcContactFirstName, 50);
   RFX_Text_Bulk(pFX, _T("[PostalCode]"), &m_pPostalCode, &m_pcPostalCode, 50);
   RFX_Text_Bulk(pFX, _T("[L_Name]"), &m_pL_Name, &m_pcL_Name, 50);
   RFX_Long_Bulk(pFX, _T("[BillingID]"), &m_pBillingID, &m_pcBillingID);

   pFX->SetFieldType(CFieldExchange::inputParam);
   RFX_Text(pFX, _T("Param"), m_strParam);
}
```

### <a name="requirements"></a>Требования

**Заголовок:** афксдб. h

## <a name="dfx_binary"></a>  DFX_Binary

Передает массивы байтов между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Binary(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   CByteArray& value,
   int nPreAllocSize = AFX_DAO_BINARY_DEFAULT_SIZE,
   DWORD dwBindOptions = 0);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа [CByteArray](cbytearray-class.md)берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*нпреаллоксизе*<br/>
Платформа предварительно выделяет этот объем памяти. Если объем данных больше, платформа будет выделять больше пространства при необходимости. Для повышения производительности задайте для этого размера достаточно большое значение, чтобы предотвратить перераспределение. Размер по умолчанию определяется в АФКСДАО. H файл AFX_DAO_BINARY_DEFAULT_SIZE.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_DISABLE_FIELD_CACHE не использует двойную буферизацию, и вы должны вызывать [сетфиелддирти](cdaorecordset-class.md#setfielddirty) и [сетфиелднулл](cdaorecordset-class.md#setfieldnull) самостоятельно. Другое возможное значение, AFX_DAO_ENABLE_FIELD_CACHE, использует двойную буферизацию, и вам не нужно выполнять дополнительные действия, чтобы пометить поля как грязные, так и NULL. В целях повышения производительности и памяти следует избегать этого значения, если двоичные данные относительно невелики.

> [!NOTE]
>  Вы можете управлять двойным буфером данных для всех полей по умолчанию, установив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_BYTES в DAO и тип [CByteArray](cbytearray-class.md) в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_bool"></a>  DFX_Bool

Передает логические данные между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Bool(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   BOOL& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа BOOL берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_BOOL в DAO и типа BOOL в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_byte"></a>  DFX_Byte

Передает отдельные байты между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Byte(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   BYTE& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа BYTE берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_BYTES в DAO и типом BYTE в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_currency"></a>  DFX_Currency

Передает денежные данные между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Currency(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   COleCurrency& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных это значение берется из указанного члена данных типа [COleCurrency](colecurrency-class.md). Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_CURRENCY в DAO и Type [COleCurrency](colecurrency-class.md) в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_datetime"></a>  DFX_DateTime

Передает данные о времени и датах между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_DateTime(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   COleDateTime& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Функция принимает ссылку на объект [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) . Для перемещения из набора записей в источник данных это значение берется из указанного элемента данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_DATE в DAO и Type [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) в наборе записей.

> [!NOTE]
>  `COleDateTime` заменяет [CTime](../../atl-mfc-shared/reference/ctime-class.md) и TIMESTAMP_STRUCT для этой цели в классах DAO. `CTime` и TIMESTAMP_STRUCT по-прежнему используются для классов доступа к данным на основе ODBC.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_double"></a>  DFX_Double

Передает данные **типа Double с плавающей запятой** между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Double(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   double& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **Double**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_R8 в DAO и тип **Double float** в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_long"></a>  DFX_Long

Передает длинные целочисленные данные между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Long(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   long& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **Long**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_I4 в DAO и имеют тип **Long** в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_longbinary"></a>  DFX_LongBinary

**Важно!** Вместо этой функции рекомендуется использовать [DFX_Binary](#dfx_binary) .

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_LongBinary(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   CLongBinary& value,
   DWORD dwPreAllocSize = AFX_DAO_LONGBINARY_DEFAULT_SIZE,
   DWORD dwBindOptions = 0);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа [CLongBinary](clongbinary-class.md)берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двпреаллоксизе*<br/>
Платформа предварительно выделяет этот объем памяти. Если объем данных больше, платформа будет выделять больше пространства при необходимости. Для повышения производительности задайте для этого размера достаточно большое значение, чтобы предотвратить перераспределение.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DISABLE_FIELD_CACHE не использует двойную буферизацию. Другое возможное значение — AFX_DAO_ENABLE_FIELD_CACHE. Использует двойную буферизацию, и вам не нужно выполнять дополнительные действия, чтобы пометить поля как грязные, так и NULL. В целях повышения производительности и памяти следует избегать этого значения, если двоичные данные относительно невелики.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

`DFX_LongBinary` предоставляется для обеспечения совместимости с классами ODBC MFC. Функция `DFX_LongBinary` передает данные большого двоичного объекта (BLOB) с помощью класса `CLongBinary` между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных. Данные сопоставляются между типом DAO_BYTES в DAO и Type [CLongBinary](clongbinary-class.md) в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_short"></a>  DFX_Short

Передает короткие целочисленные данные между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Short(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   short& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **Short**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_I2 в DAO и имеют **короткий** тип в наборе записей.

> [!NOTE]
>  `DFX_Short` эквивалентна [RFX_Int](#rfx_int) для классов на основе ODBC.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_single"></a>  DFX_Single

Передает данные с плавающей запятой между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Single(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   float& value,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа **float**берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать `SetFieldDirty` и `SetFieldNull` самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_R4 в DAO и тип **float** в наборе записей.

### <a name="example"></a>Пример

См. [DFX_Text](#dfx_text).

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="dfx_text"></a>  DFX_Text

Передает `CString` данные между элементами данных поля объекта [CDaoRecordset](cdaorecordset-class.md) и столбцами записи в источнике данных.

### <a name="syntax"></a>Синтаксис

```
void AFXAPI DFX_Text(
   CDaoFieldExchange* pFX,
   LPCTSTR szName,
   CString& value,
   int nPreAllocSize = AFX_DAO_TEXT_DEFAULT_SIZE,
   DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
```

### <a name="parameters"></a>Параметры

*Сохраняется*<br/>
Указатель на объект класса [кдаофиелдексчанже](cdaofieldexchange-class.md). Этот объект содержит сведения, определяющие контекст для каждого вызова функции.

*szName*<br/>
Имя столбца данных.

*value*<br/>
Значение, хранящееся в указанном элементе данных — значение, которое необходимо передать. Для перемещения из набора записей в источник данных значение типа [CString](../../atl-mfc-shared/reference/cstringt-class.md)берется из указанного члена данных. Для перемещения из источника данных в набор записей значение сохраняется в указанном члене данных.

*нпреаллоксизе*<br/>
Платформа предварительно выделяет этот объем памяти. Если объем данных больше, платформа будет выделять больше пространства при необходимости. Для повышения производительности задайте для этого размера достаточно большое значение, чтобы предотвратить перераспределение.

*двбиндоптионс*<br/>
Параметр, позволяющий воспользоваться преимуществами механизма двойного буферизации MFC для обнаружения измененных полей набора записей. По умолчанию AFX_DAO_ENABLE_FIELD_CACHE использует двойную буферизацию. Другое возможное значение — AFX_DAO_DISABLE_FIELD_CACHE. Если указать это значение, MFC не проверяет это поле. Необходимо вызвать [сетфиелддирти](cdaorecordset-class.md#setfielddirty) и [сетфиелднулл](cdaorecordset-class.md#setfieldnull) самостоятельно.

> [!NOTE]
>  Вы можете управлять двойным буферизацией данных по умолчанию, настроив [CDaoRecordset:: m_bCheckCacheForDirtyFields](cdaorecordset-class.md#m_bcheckcachefordirtyfields).

### <a name="remarks"></a>Remarks

Данные сопоставляются между типом DAO_CHAR в DAO (или, если определен символ _UNICODE, DAO_WCHAR) и тип [CString](../../atl-mfc-shared/reference/cstringt-class.md) в наборе записей.  n

### <a name="example"></a>Пример

В этом примере показано несколько вызовов `DFX_Text`. Обратите также внимание на два вызова [кдаофиелдексчанже:: сетфиелдтипе](cdaofieldexchange-class.md#setfieldtype). Необходимо написать первый вызов `SetFieldType` и его **DFX** вызов. Второй вызов и связанные с ними **DFX** вызовы обычно записываются мастером кода, который создал класс.

```cpp
void CCustSet::DoFieldExchange(CDaoFieldExchange* pFX)
{
   pFX->SetFieldType(CDaoFieldExchange::param);
   DFX_Text(pFX, _T("Param"), m_strParam);
   pFX->SetFieldType(CDaoFieldExchange::outputColumn);
   DFX_Short(pFX, _T("EmployeeID"), m_EmployeeID);
   DFX_Text(pFX, _T("LastName"), m_LastName);
   DFX_Short(pFX, _T("Age"), m_Age);
   DFX_DateTime(pFX, _T("hire_date"), m_hire_date);
   DFX_DateTime(pFX, _T("termination_date"), m_termination_date);

   CDaoRecordset::DoFieldExchange(pFX);
}
```

### <a name="requirements"></a>Требования

**Заголовок:** афксдао. h

## <a name="see-also"></a>См. также раздел

[Макросы и глобальные](mfc-macros-and-globals.md)<br/>
[CRecordset::D Офиелдексчанже](crecordset-class.md#dofieldexchange)<br/>
[CRecordset::D Обулкфиелдексчанже](crecordset-class.md#dobulkfieldexchange)<br/>
[CDaoRecordset::D Офиелдексчанже](cdaorecordset-class.md#dofieldexchange)
