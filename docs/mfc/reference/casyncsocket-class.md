---
title: Класс CAsyncSocket
ms.date: 06/25/2020
f1_keywords:
- CAsyncSocket
- AFXSOCK/CAsyncSocket
- AFXSOCK/CAsyncSocket::CAsyncSocket
- AFXSOCK/CAsyncSocket::Accept
- AFXSOCK/CAsyncSocket::AsyncSelect
- AFXSOCK/CAsyncSocket::Attach
- AFXSOCK/CAsyncSocket::Bind
- AFXSOCK/CAsyncSocket::Close
- AFXSOCK/CAsyncSocket::Connect
- AFXSOCK/CAsyncSocket::Create
- AFXSOCK/CAsyncSocket::Detach
- AFXSOCK/CAsyncSocket::FromHandle
- AFXSOCK/CAsyncSocket::GetLastError
- AFXSOCK/CAsyncSocket::GetPeerName
- AFXSOCK/CAsyncSocket::GetPeerNameEx
- AFXSOCK/CAsyncSocket::GetSockName
- AFXSOCK/CAsyncSocket::GetSockNameEx
- AFXSOCK/CAsyncSocket::GetSockOpt
- AFXSOCK/CAsyncSocket::IOCtl
- AFXSOCK/CAsyncSocket::Listen
- AFXSOCK/CAsyncSocket::Receive
- AFXSOCK/CAsyncSocket::ReceiveFrom
- AFXSOCK/CAsyncSocket::ReceiveFromEx
- AFXSOCK/CAsyncSocket::Send
- AFXSOCK/CAsyncSocket::SendTo
- AFXSOCK/CAsyncSocket::SendToEx
- AFXSOCK/CAsyncSocket::SetSockOpt
- AFXSOCK/CAsyncSocket::ShutDown
- AFXSOCK/CASyncSocket::Socket
- AFXSOCK/CAsyncSocket::OnAccept
- AFXSOCK/CAsyncSocket::OnClose
- AFXSOCK/CAsyncSocket::OnConnect
- AFXSOCK/CAsyncSocket::OnOutOfBandData
- AFXSOCK/CAsyncSocket::OnReceive
- AFXSOCK/CAsyncSocket::OnSend
- AFXSOCK/CAsyncSocket::m_hSocket
helpviewer_keywords:
- CAsyncSocket [MFC], CAsyncSocket
- CAsyncSocket [MFC], Accept
- CAsyncSocket [MFC], AsyncSelect
- CAsyncSocket [MFC], Attach
- CAsyncSocket [MFC], Bind
- CAsyncSocket [MFC], Close
- CAsyncSocket [MFC], Connect
- CAsyncSocket [MFC], Create
- CAsyncSocket [MFC], Detach
- CAsyncSocket [MFC], FromHandle
- CAsyncSocket [MFC], GetLastError
- CAsyncSocket [MFC], GetPeerName
- CAsyncSocket [MFC], GetPeerNameEx
- CAsyncSocket [MFC], GetSockName
- CAsyncSocket [MFC], GetSockNameEx
- CAsyncSocket [MFC], GetSockOpt
- CAsyncSocket [MFC], IOCtl
- CAsyncSocket [MFC], Listen
- CAsyncSocket [MFC], Receive
- CAsyncSocket [MFC], ReceiveFrom
- CAsyncSocket [MFC], ReceiveFromEx
- CAsyncSocket [MFC], Send
- CAsyncSocket [MFC], SendTo
- CAsyncSocket [MFC], SendToEx
- CAsyncSocket [MFC], SetSockOpt
- CAsyncSocket [MFC], ShutDown
- CASyncSocket [MFC], Socket
- CAsyncSocket [MFC], OnAccept
- CAsyncSocket [MFC], OnClose
- CAsyncSocket [MFC], OnConnect
- CAsyncSocket [MFC], OnOutOfBandData
- CAsyncSocket [MFC], OnReceive
- CAsyncSocket [MFC], OnSend
- CAsyncSocket [MFC], m_hSocket
ms.assetid: cca4d5a1-aa0f-48bd-843e-ef0e2d7fc00b
ms.openlocfilehash: 95d24c9fb9e432a54705a6b8f9fa7638affad2d2
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87195100"
---
# <a name="casyncsocket-class"></a>Класс CAsyncSocket

Представляет сокет Windows — конечную точку сетевого взаимодействия.

## <a name="syntax"></a>Синтаксис

```
class CAsyncSocket : public CObject
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CAsyncSocket:: CAsyncSocket](#casyncsocket)|Формирует объект `CAsyncSocket`.|

### <a name="public-methods"></a>Открытые методы

|name|Описание|
|----------|-----------------|
|[CAsyncSocket:: Accept](#accept)|Принимает подключение к сокету.|
|[CAsyncSocket:: Асинкселект](#asyncselect)|Запрашивает уведомление о событии для сокета.|
|[CAsyncSocket:: Attach](#attach)|Присоединяет к объекту маркер сокета `CAsyncSocket` .|
|[CAsyncSocket:: BIND](#bind)|Связывает локальный адрес с сокетом.|
|[CAsyncSocket:: Close](#close)|Закрывает сокет.|
|[CAsyncSocket:: Connect](#connect)|Устанавливает соединение с одноранговым сокетом.|
|[CAsyncSocket::Create](#create)|Создает сокет.|
|[CAsyncSocket:: Креатикс](#createex)|Создает сокет с дополнительными параметрами.|
|[CAsyncSocket::D етач](#detach)|Отсоединяет от объекта маркер сокета `CAsyncSocket` .|
|[CAsyncSocket:: FromHandle](#fromhandle)|Возвращает указатель на `CAsyncSocket` объект по заданному маркеру сокета.|
|[CAsyncSocket:: GetLastError](#getlasterror)|Возвращает состояние ошибки для последней операции, которая завершилась ошибкой.|
|[CAsyncSocket:: Жетпирнаме](#getpeername)|Возвращает адрес однорангового сокета, к которому подключен сокет.|
|[CAsyncSocket:: Жетпирнамикс](#getpeernameex)|Возвращает адрес однорангового сокета, к которому подключен сокет (обрабатывает IPv6-адреса).|
|[CAsyncSocket:: Жетсоккнаме](#getsockname)|Возвращает локальное имя для сокета.|
|[CAsyncSocket:: Жетсоккнамикс](#getsocknameex)|Возвращает локальное имя для сокета (обрабатывает IPv6-адреса).|
|[CAsyncSocket:: Жетсоккопт](#getsockopt)|Получает параметр сокета.|
|[CAsyncSocket:: IOCtl](#ioctl)|Управляет режимом сокета.|
|[CAsyncSocket:: Listen](#listen)|Устанавливает сокет для прослушивания входящих запросов на подключение.|
|[CAsyncSocket:: Receive](#receive)|Получает данные от сокета.|
|[CAsyncSocket:: Рецеивефром](#receivefrom)|Получает датаграмму и сохраняет исходный адрес.|
|[CAsyncSocket:: Рецеивефромекс](#receivefromex)|Получает датаграмму и сохраняет исходный адрес (обрабатывает IPv6-адреса).|
|[CAsyncSocket:: send](#send)|Отправляет данные в подключенный сокет.|
|[CAsyncSocket:: SendTo](#sendto)|Отправляет данные в определенное место назначения.|
|[CAsyncSocket:: Сендтоекс](#sendtoex)|Отправляет данные в определенное место назначения (обрабатывает IPv6-адреса).|
|[CAsyncSocket:: Сетсоккопт](#setsockopt)|Задает параметр сокета.|
|[CAsyncSocket:: ShutDown](#shutdown)|Отключает `Send` и (или) `Receive` вызовы сокета.|
|[CASyncSocket:: сокет](#socket)|Выделяет маркер сокета.|

### <a name="protected-methods"></a>Защищенные методы

|Имя|Описание|
|----------|-----------------|
|[CAsyncSocket:: OnAccept](#onaccept)|Уведомляет сокет прослушивания о том, что он может принимать запросы на подключение, ожидающие подключения, путем вызова `Accept` .|
|[CAsyncSocket:: OnClose](#onclose)|Уведомляет сокет о закрытии подключенного к нему сокета.|
|[CAsyncSocket:: OnConnect](#onconnect)|Уведомляет соединительный сокет о том, что попытка подключения завершена, как при успешном, так и в случае ошибки.|
|[CAsyncSocket:: Онаутофбанддата](#onoutofbanddata)|Уведомляет принимающий сокет о том, что на сокете имеются нестандартные данные для считывания, обычно это срочное сообщение.|
|[CAsyncSocket:: OnReceive](#onreceive)|Уведомляет сокет прослушивания о том, что данные для извлечения вызываются `Receive` .|
|[CAsyncSocket:: OnSend](#onsend)|Уведомляет сокет о том, что он может отправить данные путем вызова `Send` .|

### <a name="public-operators"></a>Открытые операторы

|Имя|Описание|
|----------|-----------------|
|[CAsyncSocket:: operator =](#operator_eq)|Присваивает новое значение `CAsyncSocket` объекту.|
|[СОКЕТ CAsyncSocket:: operator](#operator_socket)|Этот оператор используется для получения маркера СОКЕТа `CAsyncSocket` объекта.|

### <a name="public-data-members"></a>Открытые члены данных

|Имя|Описание|
|----------|-----------------|
|[CAsyncSocket:: m_hSocket](#m_hsocket)|Указывает маркер СОКЕТа, присоединенный к этому `CAsyncSocket` объекту.|

## <a name="remarks"></a>Remarks

`CAsyncSocket`ИНКАПСУЛИРУЕТ API функций Windows Socket, предоставляя объектно-ориентированную абстракцию для программистов, желающих использовать сокеты Windows совместно с MFC.

Этот класс основан на предположении, что вы понимаете сетевую связь. Вы несете ответственность за обработку блокировок, различия порядка байтов и преобразования между строками Юникода и многобайтовой кодировки (MBCS). Если вам нужен более удобный интерфейс, который управляет этими проблемами, см. раздел Class [CSocket](../../mfc/reference/csocket-class.md).

Чтобы использовать `CAsyncSocket` объект, вызовите его конструктор, а затем вызовите функцию [CREATE](#create) для создания базового маркера сокета (Type `SOCKET` ), за исключением принятых сокетов. Для сокета сервера вызывается функция-член [Listen](#listen) , а для сокета клиента вызывается функция-член [Connect](#connect) . Сокет сервера должен вызвать функцию [Accept](#accept) при получении запроса на соединение. Используйте оставшиеся `CAsyncSocket` функции для выполнения обмена данными между сокетами. После завершения удалите объект, `CAsyncSocket` если он был создан в куче; деструктор автоматически вызывает функцию [Close](#close) . Тип данных СОКЕТа описан в статье [Windows Sockets: Background](../../mfc/windows-sockets-background.md).

> [!NOTE]
> При использовании сокетов MFC во вторичных потоках в статическом связанном приложении MFC необходимо вызвать `AfxSocketInit` в каждом потоке, использующем сокеты для инициализации библиотек сокетов. По умолчанию `AfxSocketInit` метод вызывается только в основном потоке.

Дополнительные сведения см. в статьях [сокеты Windows: использование класса CAsyncSocket](../../mfc/windows-sockets-using-class-casyncsocket.md) и связанные статьи., а также [API Windows Sockets 2](/windows/win32/WinSock/windows-sockets-start-page-2).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

`CAsyncSocket`

## <a name="requirements"></a>Требования

**Заголовок:** афкссокк. h

## <a name="casyncsocketaccept"></a><a name="accept"></a>CAsyncSocket:: Accept

Вызовите эту функцию-член, чтобы принять соединение через сокет.

```
virtual BOOL Accept(
    CAsyncSocket& rConnectedSocket,
    SOCKADDR* lpSockAddr = NULL,
    int* lpSockAddrLen = NULL);
```

### <a name="parameters"></a>Параметры

*рконнектедсоккет*<br/>
Ссылка, идентифицирующая новый сокет, доступный для подключения.

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , которая получает адрес подключающегося сокета, как известно в сети. Точный формат аргумента *лпсоккаддр* определяется семейством адресов, установленным при создании сокета. Если *лпсоккаддр* и/или *лпсоккаддрлен* равны NULL, то не возвращаются сведения об удаленном адресе принятого сокета.

*лпсоккаддрлен*<br/>
Указатель на длину адреса в *лпсоккаддр* в байтах. *Лпсоккаддрлен* — это параметр результата: он должен первоначально содержать объем пространства, на который указывает *лпсоккаддр*; При возврате он будет содержать фактическую длину (в байтах) возвращенного адреса.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. аргумент *лпсоккаддрлен* слишком мал (меньше размера [SOCKADDR](/windows/win32/winsock/sockaddr-2) структуры).

- ВСАЕИНПРОГРЕСС выполняется вызов блокирующих сокетов Windows.

- ВСАЕИНВАЛ `Listen` не был вызван до принятия.

- ВСАЕМФИЛЕ. очередь пуста, когда запись будет принята и нет доступных дескрипторов.

- ВСАЕНОБУФС. буферное пространство недоступно.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- ВСАЕОПНОТСУПП ссылочный сокет не является типом, поддерживающим службу, ориентированную на подключение.

- ВСАЕВАУЛДБЛОКК. сокет помечается как незаблокированный и не принимает никаких соединений.

### <a name="remarks"></a>Remarks

Эта подпрограммы извлекает первое подключение в очереди ожидающих подключений, создает новый сокет с теми же свойствами, что и этот сокет, и прикрепляет его к *рконнектедсоккет*. Если в очереди отсутствуют ожидающие подключения, `Accept` возвращает ноль и `GetLastError` возвращает ошибку. Принятый сокет ( *рконнектедсоккет)* нельзя использовать для приема дополнительных соединений. Исходный сокет остается открытым и прослушивается.

Аргумент *лпсоккаддр* — это параметр результата, который заполняется адресом соединяющего сокета, как известно на коммуникационном уровне. `Accept`используется с типами сокетов на основе соединения, например SOCK_STREAM.

## <a name="casyncsocketasyncselect"></a><a name="asyncselect"></a>CAsyncSocket:: Асинкселект

Вызовите эту функцию-член, чтобы запросить уведомление о событии для сокета.

```
BOOL AsyncSelect(long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
```

### <a name="parameters"></a>Параметры

*левент*<br/>
Битовая маска, указывающая сочетание сетевых событий, в которых заинтересовано приложение.

- FD_READ хотите получить уведомление о готовности к чтению.

- FD_WRITE хотите получать уведомления о доступности данных для чтения.

- FD_OOB хотите получить уведомление о поступлении нестандартных данных.

- FD_ACCEPT хотите получить уведомления о входящих подключениях.

- FD_CONNECT хотите получить уведомления о результатах подключения.

- FD_CLOSE хотите получить уведомление, если сокет был закрыт одноранговым узлом.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕИНВАЛ указывает, что один из указанных параметров является недопустимым.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

### <a name="remarks"></a>Remarks

Эта функция используется для указания того, какие функции уведомления обратного вызова MFC будут вызываться для сокета. `AsyncSelect`автоматически задает для этого сокета режим неблокировки. Дополнительные сведения см. в статье [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

## <a name="casyncsocketattach"></a><a name="attach"></a>CAsyncSocket:: Attach

Вызовите эту функцию члена, чтобы присоединить обработчик *хсоккет* к `CAsyncSocket` объекту.

```
BOOL Attach(
    SOCKET hSocket, long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
```

### <a name="parameters"></a>Параметры

*хсоккет*<br/>
Содержит маркер для сокета.

*левент*<br/>
Битовая маска, указывающая сочетание сетевых событий, в которых заинтересовано приложение.

- FD_READ хотите получить уведомление о готовности к чтению.

- FD_WRITE хотите получать уведомления о доступности данных для чтения.

- FD_OOB хотите получить уведомление о поступлении нестандартных данных.

- FD_ACCEPT хотите получить уведомления о входящих подключениях.

- FD_CONNECT хотите получить уведомления о результатах подключения.

- FD_CLOSE хотите получить уведомление, если сокет был закрыт одноранговым узлом.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно.

### <a name="remarks"></a>Remarks

Маркер СОКЕТа хранится в элементе данных [m_hSocket](#m_hsocket) объекта.

## <a name="casyncsocketbind"></a><a name="bind"></a>CAsyncSocket:: BIND

Вызовите эту функцию-член, чтобы связать локальный адрес с сокетом.

```
BOOL Bind(
    UINT nSocketPort,
    LPCTSTR lpszSocketAddress = NULL);

BOOL Bind (
    const SOCKADDR* lpSockAddr,
    int nSockAddrLen);
```

### <a name="parameters"></a>Параметры

*нсоккетпорт*<br/>
Порт, идентифицирующий приложение сокета.

*лпсзсоккетаддресс*<br/>
Сетевой адрес, разделенный цифрой, например "128.56.22.8". Передача строки NULL для этого параметра указывает на то, что `CAsyncSocket` экземпляр должен прослушивать активность клиента во всех сетевых интерфейсах.

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , содержащую адрес для назначения этому сокету.

*нсоккаддрлен*<br/>
Длина адреса в *лпсоккаддр* в байтах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). В следующем списке описаны некоторые ошибки, которые могут быть возвращены. Полный список см. в разделе [коды ошибок сокетов Windows](/windows/win32/winsock/windows-sockets-error-codes-2).

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАДДРИНУСЕ указанный адрес уже используется. (См. параметр SO_REUSEADDR Socket в разделе [сетсоккопт](#setsockopt).)

- ВСАЕФАУЛТ. аргумент *нсоккаддрлен* слишком мал (меньше размера [SOCKADDR](/windows/win32/winsock/sockaddr-2) структуры).

- ВСАЕИНПРОГРЕСС выполняется вызов блокирующих сокетов Windows.

- ВСАЕАФНОСУППОРТ указанное семейство адресов не поддерживается этим портом.

- ВСАЕИНВАЛ. сокет уже привязан к адресу.

- ВСАЕНОБУФС недостаточно доступных буферов, слишком много подключений.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

Эта подпрограммы используется для неподключенных датаграмм или сокета потока перед последующим `Connect` `Listen` вызовом или. Прежде чем он сможет принимать запросы на подключение, сокет сервера прослушивания должен выбрать номер порта и сделать его известным сокетам Windows, вызвав `Bind` . `Bind`устанавливает локальное сопоставление (адрес узла или номер порта) сокета путем назначения локального имени неименованному сокету.

## <a name="casyncsocketcasyncsocket"></a><a name="casyncsocket"></a>CAsyncSocket:: CAsyncSocket

Конструирует пустой объект сокета.

```
CAsyncSocket();
```

### <a name="remarks"></a>Remarks

После создания объекта необходимо вызвать его `Create` функцию члена, чтобы создать структуру данных сокета и привязать ее адрес. (На стороне сервера при обмене данными с сокетами Windows, когда сокет для прослушивания создает сокет для использования в `Accept` вызове, этот сокет не вызывается `Create` .)

## <a name="casyncsocketclose"></a><a name="close"></a>CAsyncSocket:: Close

Закрывает сокет.

```
virtual void Close();
```

### <a name="remarks"></a>Remarks

Эта функция освобождает дескриптор сокета, чтобы дальнейшие ссылки на него завершились с ошибкой ВСАЕНОТСОКК. Если это последняя ссылка на базовый сокет, связанная информация об именовании и данные, поставленные в очередь, отбрасываются. Деструктор объекта Socket вызывается `Close` за вас.

Для `CAsyncSocket` , но не для `CSocket` , семантика зависит от `Close` параметров сокета SO_LINGER и SO_DONTLINGER. Дополнительные сведения см. в разделе функция члена `GetSockOpt` .

## <a name="casyncsocketconnect"></a><a name="connect"></a>CAsyncSocket:: Connect

Вызовите эту функцию-член, чтобы установить соединение с неподключенным потоком или сокетом датаграммы.

```
BOOL Connect(
    LPCTSTR lpszHostAddress,
    UINT nHostPort);

BOOL Connect(
    const SOCKADDR* lpSockAddr,
    int nSockAddrLen);
```

### <a name="parameters"></a>Параметры

*лпсзостаддресс*<br/>
Сетевой адрес сокета, к которому подключен этот объект: имя компьютера, например "ftp.microsoft.com", или разделенное число, например "128.56.22.8".

*нхостпорт*<br/>
Порт, идентифицирующий приложение сокета.

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , содержащую адрес подключенного сокета.

*нсоккаддрлен*<br/>
Длина адреса в *лпсоккаддр* в байтах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). Если это указывает код ошибки ВСАЕВАУЛДБЛОКК, и ваше приложение использует переопределяемые обратные вызовы, приложение получит `OnConnect` сообщение о завершении операции подключения. К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАДДРИНУСЕ указанный адрес уже используется.

- ВСАЕИНПРОГРЕСС выполняется вызов блокирующих сокетов Windows.

- ВСАЕАДДРНОТАВАИЛ указанный адрес недоступен с локального компьютера.

- Адреса ВСАЕАФНОСУППОРТ в указанном семействе нельзя использовать с этим сокетом.

- ВСАЕКОННРЕФУСЕД попытка подключения была отклонена.

- ВСАЕДЕСТАДДРРЕК. требуется адрес назначения.

- ВСАЕФАУЛТ. недопустимый аргумент *нсоккаддрлен* .

- ВСАЕИНВАЛ недопустимый адрес узла.

- ВСАЕИСКОНН. сокет уже подключен.

- ВСАЕМФИЛЕ. больше нет доступных дескрипторов файлов.

- ВСАЕНЕТУНРЕАЧ. в данный момент сеть недоступна с этого узла.

- ВСАЕНОБУФС. буферное пространство недоступно. Не удается подключить сокет.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Истекло время ожидания ВСАЕТИМЕДАУТ для подключения без установления соединения.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокирующий, и соединение не может быть завершено немедленно.

### <a name="remarks"></a>Remarks

Если сокет не привязан, уникальные значения назначаются в локальную ассоциацию системой, а сокет помечается как привязанный. Обратите внимание, что если поле адреса структуры имени равно нулю, `Connect` возвращает ноль. Чтобы получить расширенные сведения об ошибке, вызовите `GetLastError` функцию члена.

Для сокетов потоков (тип SOCK_STREAM) активное подключение инициируется для инородного узла. Когда вызов сокета завершается успешно, сокет готов к отправке и получению данных.

Для сокета датаграммы (тип SOCK_DGRAM) устанавливается назначение по умолчанию, которое будет использоваться при последующих `Send` `Receive` вызовах и.

## <a name="casyncsocketcreate"></a><a name="create"></a>CAsyncSocket:: Create

Вызовите `Create` функцию-член после создания объекта сокета, чтобы создать сокет Windows и присоединить его.

```
BOOL Create(
    UINT nSocketPort = 0,
    int nSocketType = SOCK_STREAM,
    long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
    LPCTSTR lpszSocketAddress = NULL);
```

### <a name="parameters"></a>Параметры

*нсоккетпорт*<br/>
Хорошо известный порт, используемый с сокетом, или 0, если вы хотите, чтобы сокеты Windows выбрали порт.

*нсоккеттипе*<br/>
SOCK_STREAM или SOCK_DGRAM.

*левент*<br/>
Битовая маска, указывающая сочетание сетевых событий, в которых заинтересовано приложение.

- FD_READ хотите получить уведомление о готовности к чтению.

- FD_WRITE хотите получить уведомление о готовности к написанию.

- FD_OOB хотите получить уведомление о поступлении нестандартных данных.

- FD_ACCEPT хотите получить уведомления о входящих подключениях.

- FD_CONNECT хотите получить уведомление о завершенном подключении.

- FD_CLOSE хотите получить уведомление о замыкании сокета.

*лпсзсоккаддресс*<br/>
Указатель на строку, содержащую сетевой адрес подключенного сокета, разделенный цифрой, например "128.56.22.8". Передача строки NULL для этого параметра указывает на то, что `CAsyncSocket` экземпляр должен прослушивать активность клиента во всех сетевых интерфейсах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАФНОСУППОРТ указанное семейство адресов не поддерживается.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕМФИЛЕ. больше нет доступных дескрипторов файлов.

- ВСАЕНОБУФС. буферное пространство недоступно. Невозможно создать сокет.

- ВСАЕПРОТОНОСУППОРТ указанный порт не поддерживается.

- ВСАЕПРОТОТИПЕ. указанный порт имеет неправильный тип для этого сокета.

- ВСАЕСОККТНОСУППОРТ. указанный тип сокета не поддерживается в этом семействе адресов.

### <a name="remarks"></a>Remarks

`Create`вызывает [сокет](#socket) и при успешном выполнении вызывает [BIND](#bind) для привязки сокета к указанному адресу. Поддерживаются следующие типы сокетов:

- SOCK_STREAM предоставляет последовательные, надежные, полные дуплексные потоки байтов на основе соединений. Использует протокол TCP для семейства Интернет-адресов.

- SOCK_DGRAM поддерживает датаграммы без установления соединения, ненадежные пакеты фиксированной (обычно небольшой) максимальной длины. Использует протокол UDP для семейства Интернет-адресов.

    > [!NOTE]
    >  `Accept`Функция-член принимает ссылку на новый пустой `CSocket` объект в качестве параметра. Этот объект необходимо создать перед вызовом метода `Accept` . Помните, что если объект сокета выходит за пределы области действия, соединение закрывается. Не вызывайте `Create` этот новый объект сокета.

> [!IMPORTANT]
> `Create`**не** является потокобезопасным.  При вызове его в многопоточной среде, где ее можно вызвать одновременно разными потоками, обязательно Защитите каждый вызов с помощью мьютекса или другой блокировки синхронизации.

Дополнительные сведения о потоках и сокетах датаграмм см. в статьях [сокеты Windows: фоновый режим](../../mfc/windows-sockets-background.md) и [сокеты Windows: порты и адреса сокетов](../../mfc/windows-sockets-ports-and-socket-addresses.md) и [API Windows Sockets 2](/windows/win32/WinSock/windows-sockets-start-page-2).

## <a name="casyncsocketcreateex"></a><a name="createex"></a>CAsyncSocket:: Креатикс

Вызовите `CreateEx` функцию-член после создания объекта сокета, чтобы создать сокет Windows и присоединить его.

Эта функция используется, если необходимо предоставить дополнительные параметры, такие как тип сокета.

```
BOOL CreateEx(
    ADDRINFOT* pAI,
    long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
```

### <a name="parameters"></a>Параметры

*паи*<br/>
Указатель на [аддринфот](https://docs.microsoft.com/windows/win32/api/ws2def/ns-ws2def-addrinfoa) для хранения сведений о сокете, таких как семейство и тип сокета.

*левент*<br/>
Битовая маска, указывающая сочетание сетевых событий, в которых заинтересовано приложение.

- FD_READ хотите получить уведомление о готовности к чтению.

- FD_WRITE хотите получить уведомление о готовности к написанию.

- FD_OOB хотите получить уведомление о поступлении нестандартных данных.

- FD_ACCEPT хотите получить уведомления о входящих подключениях.

- FD_CONNECT хотите получить уведомление о завершенном подключении.

- FD_CLOSE хотите получить уведомление о замыкании сокета.

### <a name="return-value"></a>Возвращаемое значение

См. возвращаемое значение для [Create ()](#return-value-5).

### <a name="remarks"></a>Remarks

См. примечания для [Create ()](#remarks-8).

## <a name="casyncsocketdetach"></a><a name="detach"></a>CAsyncSocket::D етач

Вызовите эту функцию члена, чтобы отсоединить маркер СОКЕТа в элементе данных *m_hSocket* от `CAsyncSocket` объекта и присвоить *m_hSocket* значение null.

```
SOCKET Detach();
```

## <a name="casyncsocketfromhandle"></a><a name="fromhandle"></a>CAsyncSocket:: FromHandle

Возвращает указатель на `CAsyncSocket` объект.

```
static CAsyncSocket* PASCAL FromHandle(SOCKET hSocket);
```

### <a name="parameters"></a>Параметры

*хсоккет*<br/>
Содержит маркер для сокета.

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CAsyncSocket` объект или значение null, если нет `CAsyncSocket` объекта, присоединенного к *хсоккет*.

### <a name="remarks"></a>Remarks

Если при задании маркера СОКЕТа `CAsyncSocket` объект не присоединен к этому обработчику, функция-член возвращает значение null.

## <a name="casyncsocketgetlasterror"></a><a name="getlasterror"></a>CAsyncSocket:: GetLastError

Вызовите эту функцию члена, чтобы получить состояние ошибки для последней операции, которая завершилась ошибкой.

```
static int PASCAL GetLastError();
```

### <a name="return-value"></a>Возвращаемое значение

Возвращаемое значение указывает код ошибки для последней подпрограммы API сокетов Windows, выполненной этим потоком.

### <a name="remarks"></a>Remarks

Если определенная функция-член указывает, что произошла ошибка, `GetLastError` следует вызвать метод, чтобы получить соответствующий код ошибки. Список применимых кодов ошибок см. в описании отдельных функций-членов.

Дополнительные сведения о кодах ошибок см. в разделе [API Windows Sockets 2](/windows/win32/WinSock/windows-sockets-start-page-2).

## <a name="casyncsocketgetpeername"></a><a name="getpeername"></a>CAsyncSocket:: Жетпирнаме

Вызовите эту функцию-член, чтобы получить адрес однорангового сокета, к которому подключен этот сокет.

```
BOOL GetPeerName(
    CString& rPeerAddress,
    UINT& rPeerPort);

BOOL GetPeerName(
    SOCKADDR* lpSockAddr,
    int* lpSockAddrLen);
```

### <a name="parameters"></a>Параметры

*рпираддресс*<br/>
Ссылка на `CString` объект, который получает IP-адрес с точками в виде чисел.

*рпирпорт*<br/>
Ссылка на UINT, в котором хранится порт.

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , которая получает имя однорангового сокета.

*лпсоккаддрлен*<br/>
Указатель на длину адреса в *лпсоккаддр* в байтах. При возврате аргумент *лпсоккаддрлен* содержит фактический размер *лпсоккаддр* , возвращаемый в байтах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. аргумент *лпсоккаддрлен* недостаточно велик.

- ВСАЕИНПРОГРЕСС выполняется вызов блокирующих сокетов Windows.

- ВСАЕНОТКОНН. сокет не подключен.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

Для работы с IPv6-адресами используйте [CAsyncSocket:: жетпирнамикс](#getpeernameex).

## <a name="casyncsocketgetpeernameex"></a><a name="getpeernameex"></a>CAsyncSocket:: Жетпирнамикс

Вызовите эту функцию-член, чтобы получить адрес однорангового сокета, к которому подключен этот сокет (обрабатывает IPv6-адреса).

```
BOOL GetPeerNameEx(
    CString& rPeerAddress,
    UINT& rPeerPort);
```

### <a name="parameters"></a>Параметры

*рпираддресс*<br/>
Ссылка на `CString` объект, который получает IP-адрес с точками в виде чисел.

*рпирпорт*<br/>
Ссылка на UINT, в котором хранится порт.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. аргумент *лпсоккаддрлен* недостаточно велик.

- ВСАЕИНПРОГРЕСС выполняется вызов блокирующих сокетов Windows.

- ВСАЕНОТКОНН. сокет не подключен.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

Эта функция аналогична [CAsyncSocket:: жетпирнаме](#getpeername) , за исключением того, что она обрабатывает IPv6-адреса, а также более старые протоколы.

## <a name="casyncsocketgetsockname"></a><a name="getsockname"></a>CAsyncSocket:: Жетсоккнаме

Вызовите эту функцию-член, чтобы получить локальное имя для сокета.

```
BOOL GetSockName(
    CString& rSocketAddress,
    UINT& rSocketPort);

BOOL GetSockName(
    SOCKADDR* lpSockAddr,
    int* lpSockAddrLen);
```

### <a name="parameters"></a>Параметры

*рсоккетаддресс*<br/>
Ссылка на `CString` объект, который получает IP-адрес с точками в виде чисел.

*рсоккетпорт*<br/>
Ссылка на UINT, в котором хранится порт.

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , которая получает адрес сокета.

*лпсоккаддрлен*<br/>
Указатель на длину адреса в *лпсоккаддр* в байтах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. аргумент *лпсоккаддрлен* недостаточно велик.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- ВСАЕИНВАЛ. сокет не привязан к адресу с `Bind` .

### <a name="remarks"></a>Remarks

Этот вызов особенно удобен в том случае, если `Connect` был выполнен вызов без `Bind` первого выполнения. Этот вызов предоставляет единственные средства, с помощью которых можно определить локальную связь, установленную системой.

Для работы с IPv6-адресами используйте [CAsyncSocket:: жетсоккнамикс](#getsocknameex)

## <a name="casyncsocketgetsocknameex"></a><a name="getsocknameex"></a>CAsyncSocket:: Жетсоккнамикс

Вызовите эту функцию-член, чтобы получить локальное имя для сокета (обрабатывает IPv6-адреса).

```
BOOL GetSockNameEx(
    CString& rSocketAddress,
    UINT& rSocketPort);
```

### <a name="parameters"></a>Параметры

*рсоккетаддресс*<br/>
Ссылка на `CString` объект, который получает IP-адрес с точками в виде чисел.

*рсоккетпорт*<br/>
Ссылка на UINT, в котором хранится порт.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. аргумент *лпсоккаддрлен* недостаточно велик.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- ВСАЕИНВАЛ. сокет не привязан к адресу с `Bind` .

### <a name="remarks"></a>Remarks

Этот вызов аналогичен [CAsyncSocket:: жетсоккнаме](#getsockname) , за исключением того, что он обрабатывает IPv6-адреса, а также более старые протоколы.

Этот вызов особенно удобен в том случае, если `Connect` был выполнен вызов без `Bind` первого выполнения. Этот вызов предоставляет единственные средства, с помощью которых можно определить локальную связь, установленную системой.

## <a name="casyncsocketgetsockopt"></a><a name="getsockopt"></a>CAsyncSocket:: Жетсоккопт

Вызовите эту функцию-член, чтобы получить параметр сокета.

```
BOOL GetSockOpt(
    int nOptionName,
    void* lpOptionValue,
    int* lpOptionLen,
    int nLevel = SOL_SOCKET);
```

### <a name="parameters"></a>Параметры

*ноптионнаме*<br/>
Параметр сокета, для которого должно быть получено значение.

*лпоптионвалуе*<br/>
Указатель на буфер, в котором возвращается значение запрошенного параметра. Значение, связанное с выбранным параметром, возвращается в буфере *лпоптионвалуе*. Целое число, на которое указывает *лпоптионлен* , должно первоначально содержать размер этого буфера в байтах; и при возврате он будет установлен равным размеру возвращаемого значения. Для SO_LINGER это будет размер `LINGER` структуры; для всех остальных параметров он будет иметь размер bool или **`int`** , в зависимости от параметра. Список параметров и их размеры см. в разделе "Примечания".

*лпоптионлен*<br/>
Указатель на размер буфера *лпоптионвалуе* в байтах.

*нлевел*<br/>
Уровень, на котором определен параметр; поддерживаются только уровни SOL_SOCKET и IPPROTO_TCP.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). Если параметр не был задан с помощью `SetSockOpt` , `GetSockOpt` возвращает значение по умолчанию для параметра. К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ: недопустимый аргумент *лпоптионлен* .

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕНОПРОТУПТ параметр неизвестен или не поддерживается. В частности, SO_BROADCAST не поддерживается для сокетов типа SOCK_STREAM, а SO_ACCEPTCONN, SO_DONTLINGER, SO_KEEPALIVE, SO_LINGER и SO_OOBINLINE не поддерживаются для сокетов типа SOCK_DGRAM.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

`GetSockOpt`Извлекает текущее значение для параметра сокета, связанного с сокетом любого типа, в любом состоянии и сохраняет результат в *лпоптионвалуе*. Параметры влияют на операции сокета, например маршрутизацию пакетов, передачу данных по внештатному каналу и т. д.

Для поддерживаются следующие параметры `GetSockOpt` . Тип определяет тип данных, адресованных *лпоптионвалуе*. Параметр TCP_NODELAY использует IPPROTO_TCP уровня; все остальные параметры используют SOL_SOCKET уровня.

|Значение|Тип|Значение|
|-----------|----------|-------------|
|SO_ACCEPTCONN|BOOL|Сокет прослушивается.|
|SO_BROADCAST|BOOL|Сокет настроен для передачи широковещательных сообщений.|
|SO_DEBUG|BOOL|Отладка включена.|
|SO_DONTLINGER|BOOL|Если значение равно true, параметр SO_LINGER отключен.|
|SO_DONTROUTE|BOOL|Маршрутизация отключена.|
|SO_ERROR|**`int`**|Получение состояния ошибки и очистка.|
|SO_KEEPALIVE|BOOL|Выполняется отправка данных проверки активности.|
|SO_LINGER|`struct LINGER`|Возвращает текущие параметры "ожидание".|
|SO_OOBINLINE|BOOL|Данные по внешнему каналу получаются в потоке обычных данных.|
|SO_RCVBUF|INT|Размер буфера для получения.|
|SO_REUSEADDR|BOOL|Сокет можно привязать к адресу, который уже используется.|
|SO_SNDBUF|**`int`**|Размер буфера для отправки.|
|SO_TYPE|**`int`**|Тип сокета (например, SOCK_STREAM).|
|TCP_NODELAY|BOOL|Отключить алгоритм Nagle для отправки объединенных пакетов.|

Параметры Berkeley Software Distribution (BSD) не поддерживаются для `GetSockOpt` :

|Значение|Тип|Значение|
|-----------|----------|-------------|
|SO_RCVLOWAT|**`int`**|Получение нижнего знака подложки.|
|SO_RCVTIMEO|**`int`**|Время ожидания получения.|
|SO_SNDLOWAT|**`int`**|Отправка нижней метки наводы.|
|SO_SNDTIMEO|**`int`**|Время ожидания отправки.|
|IP_OPTIONS||Получение параметров в заголовке IP-адреса.|
|TCP_MAXSEG|**`int`**|Получение максимального размера сегмента TCP.|

Вызов `GetSockOpt` с неподдерживаемым параметром приведет к возвращению кода ошибки всаенопротупт `GetLastError` .

## <a name="casyncsocketioctl"></a><a name="ioctl"></a>CAsyncSocket:: IOCtl

Вызовите эту функцию-член для управления режимом сокета.

```
BOOL IOCtl(
    long lCommand,
    DWORD* lpArgument);
```

### <a name="parameters"></a>Параметры

*лкомманд*<br/>
Команда для выполнения на сокете.

*лпаргумент*<br/>
Указатель на параметр для *лкомманд*.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕИНВАЛ *лкомманд* не является допустимой командой, или *лпаргумент* не является допустимым параметром для *лкомманд*, либо команда неприменима к указанному типу сокета.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

Эта подпрограммы может использоваться на любом сокете в любом состоянии. Он используется для получения или получения операционных параметров, связанных с сокетом, независимо от подсистемы протокола и связи. Поддерживаются следующие команды:

- ФИОНБИО включает или отключает неблокирующий режим на сокете. Параметр *лпаргумент* указывает на `DWORD` , что является ненулевым, если включен режим без блокировки, и нуль, если он должен быть отключен. Если `AsyncSelect` на сокете был выдан, любая попытка использовать `IOCtl` для установки сокета в блокирующем режиме завершится с помощью всаеинвал. Чтобы вернуть сокет в режим блокировки и предотвратить ошибку ВСАЕИНВАЛ, необходимо сначала отключить приложение, `AsyncSelect` вызвав метод `AsyncSelect` с параметром *Левент* , равным 0, а затем вызвать `IOCtl` .

- ФИОНРЕАД определяет максимальное число байтов, которое может быть считано одним `Receive` вызовом из этого сокета. Параметр *лпаргумент* указывает на в, `DWORD` где `IOCtl` хранится результат. Если этот сокет имеет тип SOCK_STREAM, ФИОНРЕАД возвращает общий объем данных, которые можно считать одним `Receive` . обычно это то же самое, что и общий объем данных, поставленных в очередь на сокете. Если этот сокет имеет тип SOCK_DGRAM, ФИОНРЕАД возвращает размер первой датаграммы, поставленной в очередь на сокете.

- СИОКАТМАРК определяет, были ли считаны все данные по внешнему каналу. Это относится только к сокету типа SOCK_STREAM, которая настроена для интерактивного приема любых данных вне диапазона (SO_OOBINLINE). Если данные вне диапазона не ожидают чтения, операция возвращает ненулевое значение. В противном случае она возвращает 0, а следующая `Receive` или `ReceiveFrom` выполняемая на сокете данные будут извлекать некоторые или все сведения, предшествующие "Mark"; приложение должно использовать операцию сиокатмарк, чтобы определить, остаются ли данные. Если имеются обычные данные, предшествующие "срочные" (внештатные) данные, они будут получены по порядку. (Обратите внимание, что `Receive` или `ReceiveFrom` никогда не будет смешивать нестандартные и обычные данные в одном вызове.) Параметр *лпаргумент* указывает на в, `DWORD` где `IOCtl` хранится результат.

Эта функция является подмножеством `ioctl()` , используемым в сокетах Berkeley. В частности, отсутствует команда, эквивалентная ФИОАСИНК, а СИОКАТМАРК — единственная поддерживаемая команда уровня сокета.

## <a name="casyncsocketlisten"></a><a name="listen"></a>CAsyncSocket:: Listen

Вызовите эту функцию члена, чтобы прослушивать входящие запросы на подключение.

```
BOOL Listen(int nConnectionBacklog = 5);
```

### <a name="parameters"></a>Параметры

*нконнектионбакклог*<br/>
Максимальная длина, до которой может расти очередь ожидающих подключений. Допустимый диапазон: от 1 до 5.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАДДРИНУСЕ попытка прослушать используемый адрес.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕИНВАЛ. сокет не привязан к `Bind` или уже подключен.

- ВСАЕИСКОНН. сокет уже подключен.

- ВСАЕМФИЛЕ. больше нет доступных дескрипторов файлов.

- ВСАЕНОБУФС. буферное пространство недоступно.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- ВСАЕОПНОТСУПП ссылочный сокет не относится к типу, который поддерживает `Listen` операцию.

### <a name="remarks"></a>Remarks

Для приема подключений сокет сначала создается с помощью `Create` , а невыполненная работа для входящих подключений задается с помощью `Listen` , а затем эти соединения принимаются с помощью `Accept` . `Listen`применяется только к сокетам, поддерживающим соединения, то есть к типу SOCK_STREAM. Этот сокет помещается в пассивный режим, в котором входящие подключения подтверждаются и ожидаются в очереди процессом.

Эта функция обычно используется серверами (или любым приложением, которым требуется принимать подключения), которые могут иметь несколько запросов одновременно за раз: Если запрос на подключение прибывает в очередь полон, клиент получит сообщение об ошибке с указанием ВСАЕКОННРЕФУСЕД.

`Listen`При отсутствии доступных портов (дескрипторов) попытки продолжать работать рационально. Он будет принимать подключения до тех пор, пока очередь не будет очищена. Если порты становятся доступными, последующий вызов или приведет к повторному `Listen` `Accept` заполнению очереди на текущую или последнюю "невыполненную работу", если это возможно, и возобновить прослушивание входящих подключений.

## <a name="casyncsocketm_hsocket"></a><a name="m_hsocket"></a>CAsyncSocket:: m_hSocket

Содержит маркер СОКЕТа для сокета, инкапсулированного этим `CAsyncSocket` объектом.

```
SOCKET m_hSocket;
```

## <a name="casyncsocketonaccept"></a><a name="onaccept"></a>CAsyncSocket:: OnAccept

Вызывается платформой для уведомления сокета прослушивания о том, что он может принимать ожидающие запросы на подключение, вызывая функцию-член [Accept](#accept) .

```
virtual void OnAccept(int nErrorCode);
```

### <a name="parameters"></a>Параметры

*нерроркоде*<br/>
Самая последняя ошибка на сокете. Следующие коды ошибок относятся к `OnAccept` функции члена:

- **0** функция успешно выполнена.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

## <a name="casyncsocketonclose"></a><a name="onclose"></a>CAsyncSocket:: OnClose

Вызывается платформой для уведомления этого сокета о том, что подключенный сокет закрыт процессом.

```
virtual void OnClose(int nErrorCode);
```

### <a name="parameters"></a>Параметры

*нерроркоде*<br/>
Самая последняя ошибка на сокете. Следующие коды ошибок относятся к `OnClose` функции члена:

- **0** функция успешно выполнена.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕКОННРЕСЕТ подключение сброшено на удаленной стороне.

- ВСАЕКОННАБОРТЕД подключение прервано из-за истечения времени ожидания или другого сбоя.

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

## <a name="casyncsocketonconnect"></a><a name="onconnect"></a>CAsyncSocket:: OnConnect

Вызывается платформой для уведомления этого подключающегося сокета о том, что попытка подключения завершается успешно или по ошибке.

```
virtual void OnConnect(int nErrorCode);
```

### <a name="parameters"></a>Параметры

*нерроркоде*<br/>
Самая последняя ошибка на сокете. Следующие коды ошибок относятся к `OnConnect` функции члена:

- **0** функция успешно выполнена.

- ВСАЕАДДРИНУСЕ указанный адрес уже используется.

- ВСАЕАДДРНОТАВАИЛ указанный адрес недоступен с локального компьютера.

- Адреса ВСАЕАФНОСУППОРТ в указанном семействе нельзя использовать с этим сокетом.

- ВСАЕКОННРЕФУСЕД попытка подключения была принудительно отклонена.

- ВСАЕДЕСТАДДРРЕК. требуется адрес назначения.

- ВСАЕФАУЛТ. недопустимый аргумент *лпсоккаддрлен* .

- ВСАЕИНВАЛ. сокет уже привязан к адресу.

- ВСАЕИСКОНН. сокет уже подключен.

- ВСАЕМФИЛЕ. больше нет доступных дескрипторов файлов.

- ВСАЕНЕТУНРЕАЧ. в данный момент сеть недоступна с этого узла.

- ВСАЕНОБУФС. буферное пространство недоступно. Не удается подключить сокет.

- ВСАЕНОТКОНН. сокет не подключен.

- ВСАЕНОТСОКК дескриптор является файлом, а не сокетом.

- ВСАЕТИМЕДАУТ попытку подключения истекло без установления соединения.

### <a name="remarks"></a>Remarks

> [!NOTE]
> В [CSocket](../../mfc/reference/csocket-class.md) `OnConnect` функция уведомления никогда не вызывается. Для соединений необходимо просто вызвать метод `Connect` , который будет возвращать, когда соединение завершается (успешно или по ошибке). Обработка уведомлений о соединении — это сведения о реализации MFC.

Дополнительные сведения см. в разделе [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAsyncSocket#1](../../mfc/reference/codesnippet/cpp/casyncsocket-class_1.cpp)]

## <a name="casyncsocketonoutofbanddata"></a><a name="onoutofbanddata"></a>CAsyncSocket:: Онаутофбанддата

Вызывается платформой для уведомления принимающего сокета о том, что отправляющий сокет имеет данные, находящиеся вне диапазона для отправки.

```
virtual void OnOutOfBandData(int nErrorCode);
```

### <a name="parameters"></a>Параметры

*нерроркоде*<br/>
Самая последняя ошибка на сокете. Следующие коды ошибок относятся к `OnOutOfBandData` функции члена:

- **0** функция успешно выполнена.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

### <a name="remarks"></a>Remarks

Нестандартные данные — это логически независимый канал, связанный с каждой парой подключенных сокетов типа SOCK_STREAM. Канал обычно используется для отправки срочных данных.

MFC поддерживает данные вне диапазона, но пользователям класса `CAsyncSocket` не рекомендуется использовать их. Проще всего создать второй сокет для передачи таких данных. Дополнительные сведения о нестандартных данных см. в разделе [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

## <a name="casyncsocketonreceive"></a><a name="onreceive"></a>CAsyncSocket:: OnReceive

Вызывается платформой для уведомления этого сокета о том, что в буфере есть данные, которые можно извлечь, вызвав `Receive` функцию-член.

```
virtual void OnReceive(int nErrorCode);
```

### <a name="parameters"></a>Параметры

*нерроркоде*<br/>
Самая последняя ошибка на сокете. Следующие коды ошибок относятся к `OnReceive` функции члена:

- **0** функция успешно выполнена.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAsyncSocket#2](../../mfc/reference/codesnippet/cpp/casyncsocket-class_2.cpp)]

## <a name="casyncsocketonsend"></a><a name="onsend"></a>CAsyncSocket:: OnSend

Вызывается платформой для уведомления сокета о том, что теперь он может отправлять данные путем вызова `Send` функции члена.

```
virtual void OnSend(int nErrorCode);
```

### <a name="parameters"></a>Параметры

*нерроркоде*<br/>
Самая последняя ошибка на сокете. Следующие коды ошибок относятся к `OnSend` функции члена:

- **0** функция успешно выполнена.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе [сокеты Windows: уведомления сокетов](../../mfc/windows-sockets-socket-notifications.md).

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAsyncSocket#3](../../mfc/reference/codesnippet/cpp/casyncsocket-class_3.cpp)]

## <a name="casyncsocketoperator-"></a><a name="operator_eq"></a>CAsyncSocket:: operator =

Присваивает новое значение `CAsyncSocket` объекту.

```cpp
void operator=(const CAsyncSocket& rSrc);
```

### <a name="parameters"></a>Параметры

*rSrc*<br/>
Ссылка на существующий `CAsyncSocket` объект.

### <a name="remarks"></a>Remarks

Вызовите эту функцию, чтобы скопировать существующий `CAsyncSocket` объект в другой `CAsyncSocket` объект.

## <a name="casyncsocketoperator-socket"></a><a name="operator_socket"></a>СОКЕТ CAsyncSocket:: operator

Этот оператор используется для получения маркера СОКЕТа `CAsyncSocket` объекта.

```
operator SOCKET() const;
```

### <a name="return-value"></a>Возвращаемое значение

В случае успеха — маркер объекта СОКЕТа; в противном случае значение NULL.

### <a name="remarks"></a>Remarks

Вы можете использовать этот обработчик для непосредственного вызова интерфейсов API Windows.

## <a name="casyncsocketreceive"></a><a name="receive"></a>CAsyncSocket:: Receive

Вызовите эту функцию-член для получения данных от сокета.

```
virtual int Receive(
    void* lpBuf,
    int nBufLen,
    int nFlags = 0);
```

### <a name="parameters"></a>Параметры

*лпбуф*<br/>
Буфер для входящих данных.

*нбуфлен*<br/>
Длина *лпбуф* в байтах.

*нфлагс*<br/>
Указывает способ вызова. Семантика этой функции определяется параметрами сокета и параметром *нфлагс* . Второй вариант создается путем объединения любого из следующих значений с оператором C++ **или** :

- MSG_PEEK просматривать входящие данные. Данные копируются в буфер, но не удаляются из входной очереди.

- MSG_OOB обрабатывать данные вне диапазона.

### <a name="return-value"></a>Возвращаемое значение

Если ошибка не возникает, `Receive` возвращает число полученных байтов. Если соединение было закрыто, оно возвращает 0. В противном случае возвращается значение SOCKET_ERROR, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕНОТКОНН. сокет не подключен.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Указан MSG_OOB ВСАЕОПНОТСУПП, но тип сокета не SOCK_STREAM.

- ВСАЕШУТДОВН. Работа сокета была завершена; вызов через `Receive` сокет после вызова с параметром нхов, равным `ShutDown` 0 или 2 *nHow* , невозможен.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокируемая и `Receive` операция блокируется.

- ВСАЕМСГСИЗЕ датаграмму слишком велика, чтобы вместить указанный буфер, и был усечен.

- ВСАЕИНВАЛ. сокет не привязан к `Bind` .

- ВСАЕКОННАБОРТЕД. виртуальный канал был прерван из-за истечения времени ожидания или другого сбоя.

- ВСАЕКОННРЕСЕТ. виртуальный канал был сброшен удаленной стороной.

### <a name="remarks"></a>Remarks

Эта функция используется для подключенного потока или сокетов датаграмм и используется для чтения входящих данных.

Для сокетов типа SOCK_STREAM, сколько информации в настоящее время доступно вплоть до размера переданного буфера, возвращается. Если сокет настроен для интерактивного приема нестандартных данных (параметр сокета SO_OOBINLINE), а непрочтенные данные не считываются, возвращаются только данные, не являющиеся внешними. Приложение может использовать `IOCtlSIOCATMARK` параметр или [онаутофбанддата](#onoutofbanddata) , чтобы определить, остаются ли недоступные для чтения данные.

Для сокетов датаграмм данные извлекаются из первой поставленной в очередь датаграммы вплоть до размера переданного буфера. Если датаграмма превышает указанный буфер, буфер заполняется первой частью датаграммы, лишние данные теряются и `Receive` возвращается значение SOCKET_ERROR с кодом ошибки, установленным в всаемсгсизе. Если на сокете недоступны входящие данные, возвращается значение SOCKET_ERROR с кодом ошибки, равным ВСАЕВАУЛДБЛОКК. Функцию обратного вызова [OnReceive](#onreceive) можно использовать, чтобы определить, когда поступит больше данных.

Если сокет имеет тип SOCK_STREAM и удаленная сторона успешно отключила подключение, то завершается `Receive` немедленно с полученным 0 байт. Если подключение было сброшено, `Receive` произойдет сбой с ошибкой всаеконнресет.

`Receive`метод должен вызываться только один раз для каждого вызова [CAsyncSocket:: OnReceive](#onreceive) .

### <a name="example"></a>Пример

  См. пример для [CAsyncSocket:: OnReceive](#onreceive).

## <a name="casyncsocketreceivefrom"></a><a name="receivefrom"></a>CAsyncSocket:: Рецеивефром

Вызовите эту функцию-член, чтобы получить датаграмму и сохранить адрес источника в структуре [SOCKADDR](/windows/win32/winsock/sockaddr-2) или в *рсоккетаддресс*.

```
int ReceiveFrom(
    void* lpBuf,
    int nBufLen,
    CString& rSocketAddress,
    UINT& rSocketPort,
    int nFlags = 0);

int ReceiveFrom(
    void* lpBuf,
    int nBufLen,
    SOCKADDR* lpSockAddr,
    int* lpSockAddrLen,
    int nFlags = 0);
```

### <a name="parameters"></a>Параметры

*лпбуф*<br/>
Буфер для входящих данных.

*нбуфлен*<br/>
Длина *лпбуф* в байтах.

*рсоккетаддресс*<br/>
Ссылка на `CString` объект, который получает IP-адрес с точками в виде чисел.

*рсоккетпорт*<br/>
Ссылка на UINT, в котором хранится порт.

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , которая содержит исходный адрес после возврата.

*лпсоккаддрлен*<br/>
Указатель на длину исходного адреса в *лпсоккаддр* в байтах.

*нфлагс*<br/>
Указывает способ вызова. Семантика этой функции определяется параметрами сокета и параметром *нфлагс* . Второй вариант создается путем объединения любого из следующих значений с оператором C++ **или** :

- MSG_PEEK просматривать входящие данные. Данные копируются в буфер, но не удаляются из входной очереди.

- MSG_OOB обрабатывать данные вне диапазона.

### <a name="return-value"></a>Возвращаемое значение

Если ошибка не возникает, `ReceiveFrom` возвращает число полученных байтов. Если соединение было закрыто, оно возвращает 0. В противном случае возвращается значение SOCKET_ERROR, и можно получить конкретный код ошибки, вызвав метод `GetLastError` . К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. недопустимый аргумент *лпсоккаддрлен* : буфер *лпсоккаддр* слишком мал для размещения однорангового адреса.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕИНВАЛ. сокет не привязан к `Bind` .

- ВСАЕНОТКОНН. сокет не подключен (только SOCK_STREAM).

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Указан MSG_OOB ВСАЕОПНОТСУПП, но тип сокета не SOCK_STREAM.

- ВСАЕШУТДОВН. Работа сокета была завершена; вызов через `ReceiveFrom` сокет после вызова с параметром нхов, равным `ShutDown` 0 или 2 *nHow* , невозможен.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокируемая и `ReceiveFrom` операция блокируется.

- ВСАЕМСГСИЗЕ датаграмму слишком велика, чтобы вместить указанный буфер, и был усечен.

- ВСАЕКОННАБОРТЕД. виртуальный канал был прерван из-за истечения времени ожидания или другого сбоя.

- ВСАЕКОННРЕСЕТ. виртуальный канал был сброшен удаленной стороной.

### <a name="remarks"></a>Remarks

Эта функция используется для чтения входящих данных по сокету (возможно, подключенному) и записи адреса, из которого были отправлены данные.

Для работы с IPv6-адресами используйте [CAsyncSocket:: рецеивефромекс](#receivefromex).

Для сокетов типа SOCK_STREAM, сколько информации в настоящее время доступно вплоть до размера переданного буфера, возвращается. Если сокет настроен для интерактивного приема нестандартных данных (параметр сокета SO_OOBINLINE), а непрочтенные данные не считываются, возвращаются только данные, не являющиеся внешними. Приложение может использовать `IOCtlSIOCATMARK` параметр или, `OnOutOfBandData` чтобы определить, будут ли доступны дополнительные данные для чтения. Параметры *лпсоккаддр* и *лпсоккаддрлен* игнорируются для сокетов SOCK_STREAM.

Для сокетов датаграмм данные извлекаются из первой поставленной в очередь датаграммы вплоть до размера переданного буфера. Если датаграмма превышает указанный буфер, буфер заполняется первой частью сообщения, лишние данные теряются и `ReceiveFrom` возвращается значение SOCKET_ERROR с кодом ошибки, установленным в всаемсгсизе.

Если *лпсоккаддр* имеет ненулевое значение и сокет относится к типу SOCK_DGRAM, то сетевой адрес сокета, который отправил данные, копируется в соответствующую структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) . Значение, на которое указывает *лпсоккаддрлен* , инициализируется до размера этой структуры и изменяется при возврате для указания фактического размера адреса, хранящегося в ней. Если на сокете отсутствуют входящие данные, `ReceiveFrom` вызов ожидает поступления данных, если только сокет не блокируется. В этом случае возвращается значение SOCKET_ERROR с кодом ошибки, установленным в ВСАЕВАУЛДБЛОКК. `OnReceive`Обратный вызов можно использовать, чтобы определить, когда поступит больше данных.

Если сокет имеет тип SOCK_STREAM и удаленная сторона успешно отключила подключение, то завершается `ReceiveFrom` немедленно с полученным 0 байт.

## <a name="casyncsocketreceivefromex"></a><a name="receivefromex"></a>CAsyncSocket:: Рецеивефромекс

Вызовите эту функцию-член, чтобы получить датаграмму и сохранить адрес источника в структуре [SOCKADDR](/windows/win32/winsock/sockaddr-2) или в *Рсоккетаддресс* (обрабатывает IPv6-адреса).

```
int ReceiveFromEx(
    void* lpBuf,
    int nBufLen,
    CString& rSocketAddress,
    UINT& rSocketPort,
    int nFlags = 0);
```

### <a name="parameters"></a>Параметры

*лпбуф*<br/>
Буфер для входящих данных.

*нбуфлен*<br/>
Длина *лпбуф* в байтах.

*рсоккетаддресс*<br/>
Ссылка на `CString` объект, который получает IP-адрес с точками в виде чисел.

*рсоккетпорт*<br/>
Ссылка на UINT, в котором хранится порт.

*нфлагс*<br/>
Указывает способ вызова. Семантика этой функции определяется параметрами сокета и параметром *нфлагс* . Второй вариант создается путем объединения любого из следующих значений с оператором C++ **или** :

- MSG_PEEK просматривать входящие данные. Данные копируются в буфер, но не удаляются из входной очереди.

- MSG_OOB обрабатывать данные вне диапазона.

### <a name="return-value"></a>Возвращаемое значение

Если ошибка не возникает, `ReceiveFromEx` возвращает число полученных байтов. Если соединение было закрыто, оно возвращает 0. В противном случае возвращается значение SOCKET_ERROR, и можно получить конкретный код ошибки, вызвав метод `GetLastError` . К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ. недопустимый аргумент *лпсоккаддрлен* : буфер *лпсоккаддр* слишком мал для размещения однорангового адреса.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕИНВАЛ. сокет не привязан к `Bind` .

- ВСАЕНОТКОНН. сокет не подключен (только SOCK_STREAM).

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Указан MSG_OOB ВСАЕОПНОТСУПП, но тип сокета не SOCK_STREAM.

- ВСАЕШУТДОВН. Работа сокета была завершена; вызов через `ReceiveFromEx` сокет после вызова с параметром нхов, равным `ShutDown` 0 или 2 *nHow* , невозможен.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокируемая и `ReceiveFromEx` операция блокируется.

- ВСАЕМСГСИЗЕ датаграмму слишком велика, чтобы вместить указанный буфер, и был усечен.

- ВСАЕКОННАБОРТЕД. виртуальный канал был прерван из-за истечения времени ожидания или другого сбоя.

- ВСАЕКОННРЕСЕТ. виртуальный канал был сброшен удаленной стороной.

### <a name="remarks"></a>Remarks

Эта функция используется для чтения входящих данных по сокету (возможно, подключенному) и записи адреса, из которого были отправлены данные.

Эта функция аналогична [CAsyncSocket:: рецеивефром](#receivefrom) , за исключением того, что она обрабатывает IPv6-адреса, а также более старые протоколы.

Для сокетов типа SOCK_STREAM, сколько информации в настоящее время доступно вплоть до размера переданного буфера, возвращается. Если сокет настроен для интерактивного приема нестандартных данных (параметр сокета SO_OOBINLINE), а непрочтенные данные не считываются, возвращаются только данные, не являющиеся внешними. Приложение может использовать `IOCtlSIOCATMARK` параметр или, `OnOutOfBandData` чтобы определить, будут ли доступны дополнительные данные для чтения. Параметры *лпсоккаддр* и *лпсоккаддрлен* игнорируются для сокетов SOCK_STREAM.

Для сокетов датаграмм данные извлекаются из первой поставленной в очередь датаграммы вплоть до размера переданного буфера. Если датаграмма превышает указанный буфер, буфер заполняется первой частью сообщения, лишние данные теряются и `ReceiveFromEx` возвращается значение SOCKET_ERROR с кодом ошибки, установленным в всаемсгсизе.

Если *лпсоккаддр* имеет ненулевое значение и сокет относится к типу SOCK_DGRAM, то сетевой адрес сокета, который отправил данные, копируется в соответствующую структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) . Значение, на которое указывает *лпсоккаддрлен* , инициализируется до размера этой структуры и изменяется при возврате для указания фактического размера адреса, хранящегося в ней. Если на сокете отсутствуют входящие данные, `ReceiveFromEx` вызов ожидает поступления данных, если только сокет не блокируется. В этом случае возвращается значение SOCKET_ERROR с кодом ошибки, установленным в ВСАЕВАУЛДБЛОКК. `OnReceive`Обратный вызов можно использовать, чтобы определить, когда поступит больше данных.

Если сокет имеет тип SOCK_STREAM и удаленная сторона успешно отключила подключение, то завершается `ReceiveFromEx` немедленно с полученным 0 байт.

## <a name="casyncsocketsend"></a><a name="send"></a>CAsyncSocket:: send

Вызовите эту функцию-член для отправки данных на подключенный сокет.

```
virtual int Send(
    const void* lpBuf,
    int nBufLen,
    int nFlags = 0);
```

### <a name="parameters"></a>Параметры

*лпбуф*<br/>
Буфер, содержащий передаваемые данные.

*нбуфлен*<br/>
Длина данных в *лпбуф* в байтах.

*нфлагс*<br/>
Указывает способ вызова. Семантика этой функции определяется параметрами сокета и параметром *нфлагс* . Второй вариант создается путем объединения любого из следующих значений с оператором C++ **или** :

- MSG_DONTROUTE указывает, что данные не должны подвергаться маршрутизации. Поставщик сокетов Windows может игнорировать этот флаг.

- MSG_OOB отправки нестандартных данных (только SOCK_STREAM).

### <a name="return-value"></a>Возвращаемое значение

Если ошибка не возникает, `Send` возвращает общее число отправленных символов. (Обратите внимание, что это значение может быть меньше числа, указанного в *нбуфлен*.) В противном случае возвращается значение SOCKET_ERROR, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАКЦЕС. Запрошенный адрес является широковещательным адресом, но соответствующий флаг не был установлен.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕФАУЛТ. аргумент *лпбуф* не находится в допустимой части адресного пространства пользователя.

- ВСАЕНЕТРЕСЕТ подключение должно быть сброшено из-за того, что реализация сокетов Windows отбросила его.

- ВСАЕНОБУФС. Реализация сокетов Windows сообщает о взаимоблокировке буфера.

- ВСАЕНОТКОНН. сокет не подключен.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Указан MSG_OOB ВСАЕОПНОТСУПП, но тип сокета не SOCK_STREAM.

- ВСАЕШУТДОВН. Работа сокета была завершена; невозможно вызвать `Send` сокет после `ShutDown` вызова с параметром *нхов* , равным 1 или 2.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокирующий, а запрошенная операция блокируется.

- ВСАЕМСГСИЗЕ, что сокет имеет тип SOCK_DGRAM, а датаграмма больше максимальной, поддерживаемой реализацией Windows Sockets.

- ВСАЕИНВАЛ. сокет не привязан к `Bind` .

- ВСАЕКОННАБОРТЕД. виртуальный канал был прерван из-за истечения времени ожидания или другого сбоя.

- ВСАЕКОННРЕСЕТ. виртуальный канал был сброшен удаленной стороной.

### <a name="remarks"></a>Remarks

`Send`используется для записи исходящих данных в подключенном потоке или сокетах датаграмм. Для сокетов датаграмм необходимо соблюдать осторожность, чтобы превысить максимальный размер пакета IP-адресов базовых подсетей, который определяется `iMaxUdpDg` элементом в структуре [всадата](/windows/win32/api/winsock2/ns-winsock2-wsadata) , возвращаемой `AfxSocketInit` . Если данные слишком длинны для передачи атомарным образом через базовый протокол, то ошибка ВСАЕМСГСИЗЕ возвращается через `GetLastError` и никакие данные не передаются.

Обратите внимание, что для сокета датаграмм успешное завершение `Send` не указывает на то, что данные были успешно доставлены.

Для `CAsyncSocket` объектов типа SOCK_STREAM число записанных байтов может быть в диапазоне от 1 до запрошенной длины в зависимости от доступности буфера как на локальном, так и на инородном узлах.

### <a name="example"></a>Пример

  См. пример для [CAsyncSocket:: OnSend](#onsend).

## <a name="casyncsocketsendto"></a><a name="sendto"></a>CAsyncSocket:: SendTo

Вызовите эту функцию-член для отправки данных в определенное место назначения.

```
int SendTo(
    const void* lpBuf,
    int nBufLen,
    UINT nHostPort,
    LPCTSTR lpszHostAddress = NULL,
    int nFlags = 0);

int SendTo(
    const void* lpBuf,
    int nBufLen,
    const SOCKADDR* lpSockAddr,
    int nSockAddrLen,
    int nFlags = 0);
```

### <a name="parameters"></a>Параметры

*лпбуф*<br/>
Буфер, содержащий передаваемые данные.

*нбуфлен*<br/>
Длина данных в *лпбуф* в байтах.

*нхостпорт*<br/>
Порт, идентифицирующий приложение сокета.

*лпсзостаддресс*<br/>
Сетевой адрес сокета, к которому подключен этот объект: имя компьютера, например "ftp.microsoft.com", или разделенное число, например "128.56.22.8".

*нфлагс*<br/>
Указывает способ вызова. Семантика этой функции определяется параметрами сокета и параметром *нфлагс* . Второй вариант создается путем объединения любого из следующих значений с оператором C++ **или** :

- MSG_DONTROUTE указывает, что данные не должны подвергаться маршрутизации. Поставщик сокетов Windows может игнорировать этот флаг.

- MSG_OOB отправки нестандартных данных (только SOCK_STREAM).

*лпсоккаддр*<br/>
Указатель на структуру [SOCKADDR](/windows/win32/winsock/sockaddr-2) , содержащую адрес целевого сокета.

*нсоккаддрлен*<br/>
Длина адреса в *лпсоккаддр* в байтах.

### <a name="return-value"></a>Возвращаемое значение

Если ошибка не возникает, `SendTo` возвращает общее число отправленных символов. (Обратите внимание, что это значение может быть меньше числа, указанного в *нбуфлен*.) В противном случае возвращается значение SOCKET_ERROR, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАКЦЕС. Запрошенный адрес является широковещательным адресом, но соответствующий флаг не был установлен.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕФАУЛТ. параметры *лпбуф* или *лпсоккаддр* не являются частью адресного пространства пользователя, или аргумент *лпсоккаддр* слишком мал (меньше, чем размер структуры [SOCKADDR](/windows/win32/winsock/sockaddr-2) ).

- ВСАЕИНВАЛ. имя узла недопустимо.

- ВСАЕНЕТРЕСЕТ подключение должно быть сброшено из-за того, что реализация сокетов Windows отбросила его.

- ВСАЕНОБУФС. Реализация сокетов Windows сообщает о взаимоблокировке буфера.

- ВСАЕНОТКОНН. сокет не подключен (только SOCK_STREAM).

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Указан MSG_OOB ВСАЕОПНОТСУПП, но тип сокета не SOCK_STREAM.

- ВСАЕШУТДОВН. Работа сокета была завершена; невозможно вызвать `SendTo` сокет после `ShutDown` вызова с параметром *нхов* , равным 1 или 2.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокирующий, а запрошенная операция блокируется.

- ВСАЕМСГСИЗЕ, что сокет имеет тип SOCK_DGRAM, а датаграмма больше максимальной, поддерживаемой реализацией Windows Sockets.

- ВСАЕКОННАБОРТЕД. виртуальный канал был прерван из-за истечения времени ожидания или другого сбоя.

- ВСАЕКОННРЕСЕТ. виртуальный канал был сброшен удаленной стороной.

- ВСАЕАДДРНОТАВАИЛ указанный адрес недоступен с локального компьютера.

- Адреса ВСАЕАФНОСУППОРТ в указанном семействе нельзя использовать с этим сокетом.

- ВСАЕДЕСТАДДРРЕК. требуется адрес назначения.

- ВСАЕНЕТУНРЕАЧ. в данный момент сеть недоступна с этого узла.

### <a name="remarks"></a>Remarks

`SendTo`используется в сокетах датаграммы и потока и используется для записи исходящих данных на сокете. Для сокетов датаграмм необходимо не превышать максимальный размер пакета IP-адресов в базовых подсетях, который задается `iMaxUdpDg` элементом в структуре [всадата](/windows/win32/api/winsock2/ns-winsock2-wsadata) , заполненной [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit). Если данные слишком длинны для передачи атомарным образом через базовый протокол, возвращается ошибка ВСАЕМСГСИЗЕ и данные не передаются.

Обратите внимание, что успешное завершение `SendTo` не означает, что данные были успешно доставлены.

`SendTo`используется только в сокете SOCK_DGRAM для отправки датаграммы конкретному сокету, определяемому параметром *лпсоккаддр* .

Чтобы отправить вещание (только в SOCK_DGRAM), адрес в параметре *лпсоккаддр* должен быть создан с использованием специального IP-адреса INADDR_BROADCAST (определенного в файле заголовка Windows Sockets в формате Winsock. H) вместе с требуемым номером порта. Или, если параметр *лпсзостаддресс* имеет значение null, сокет настраивается для вещания. Как правило, широковещательная датаграмма должна превысить размер, при котором может произойти фрагментация, что означает, что часть данных датаграммы (за исключением заголовков) не должна превышать 512 байт.

Для работы с IPv6-адресами используйте [CAsyncSocket:: сендтоекс](#sendtoex).

## <a name="casyncsocketsendtoex"></a><a name="sendtoex"></a>CAsyncSocket:: Сендтоекс

Вызовите эту функцию-член для отправки данных в определенное место назначения (обрабатывает IPv6-адреса).

```
int SendToEx(
    const void* lpBuf,
    int nBufLen,
    UINT nHostPort,
    LPCTSTR lpszHostAddress = NULL,
    int nFlags = 0);
```

### <a name="parameters"></a>Параметры

*лпбуф*<br/>
Буфер, содержащий передаваемые данные.

*нбуфлен*<br/>
Длина данных в *лпбуф* в байтах.

*нхостпорт*<br/>
Порт, идентифицирующий приложение сокета.

*лпсзостаддресс*<br/>
Сетевой адрес сокета, к которому подключен этот объект: имя компьютера, например "ftp.microsoft.com", или разделенное число, например "128.56.22.8".

*нфлагс*<br/>
Указывает способ вызова. Семантика этой функции определяется параметрами сокета и параметром *нфлагс* . Второй вариант создается путем объединения любого из следующих значений с оператором C++ **или** :

- MSG_DONTROUTE указывает, что данные не должны подвергаться маршрутизации. Поставщик сокетов Windows может игнорировать этот флаг.

- MSG_OOB отправки нестандартных данных (только SOCK_STREAM).

### <a name="return-value"></a>Возвращаемое значение

Если ошибка не возникает, `SendToEx` возвращает общее число отправленных символов. (Обратите внимание, что это значение может быть меньше числа, указанного в *нбуфлен*.) В противном случае возвращается значение SOCKET_ERROR, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕАКЦЕС. Запрошенный адрес является широковещательным адресом, но соответствующий флаг не был установлен.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕФАУЛТ. параметры *лпбуф* или *лпсоккаддр* не являются частью адресного пространства пользователя, или аргумент *лпсоккаддр* слишком мал (меньше, чем размер структуры [SOCKADDR](/windows/win32/winsock/sockaddr-2) ).

- ВСАЕИНВАЛ. имя узла недопустимо.

- ВСАЕНЕТРЕСЕТ подключение должно быть сброшено из-за того, что реализация сокетов Windows отбросила его.

- ВСАЕНОБУФС. Реализация сокетов Windows сообщает о взаимоблокировке буфера.

- ВСАЕНОТКОНН. сокет не подключен (только SOCK_STREAM).

- ВСАЕНОТСОКК. дескриптор не является сокетом.

- Указан MSG_OOB ВСАЕОПНОТСУПП, но тип сокета не SOCK_STREAM.

- ВСАЕШУТДОВН. Работа сокета была завершена; невозможно вызвать `SendToEx` сокет после `ShutDown` вызова с параметром *нхов* , равным 1 или 2.

- ВСАЕВАУЛДБЛОКК. сокет помечается как неблокирующий, а запрошенная операция блокируется.

- ВСАЕМСГСИЗЕ, что сокет имеет тип SOCK_DGRAM, а датаграмма больше максимальной, поддерживаемой реализацией Windows Sockets.

- ВСАЕКОННАБОРТЕД. виртуальный канал был прерван из-за истечения времени ожидания или другого сбоя.

- ВСАЕКОННРЕСЕТ. виртуальный канал был сброшен удаленной стороной.

- ВСАЕАДДРНОТАВАИЛ указанный адрес недоступен с локального компьютера.

- Адреса ВСАЕАФНОСУППОРТ в указанном семействе нельзя использовать с этим сокетом.

- ВСАЕДЕСТАДДРРЕК. требуется адрес назначения.

- ВСАЕНЕТУНРЕАЧ. в данный момент сеть недоступна с этого узла.

### <a name="remarks"></a>Remarks

Этот метод аналогичен [CAsyncSocket:: SendTo](#sendto) , за исключением того, что он обрабатывает IPv6-адреса, а также более старые протоколы.

`SendToEx`используется в сокетах датаграммы и потока и используется для записи исходящих данных на сокете. Для сокетов датаграмм необходимо не превышать максимальный размер пакета IP-адресов в базовых подсетях, который задается `iMaxUdpDg` элементом в структуре [всадата](/windows/win32/api/winsock2/ns-winsock2-wsadata) , заполненной [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit). Если данные слишком длинны для передачи атомарным образом через базовый протокол, возвращается ошибка ВСАЕМСГСИЗЕ и данные не передаются.

Обратите внимание, что успешное завершение `SendToEx` не означает, что данные были успешно доставлены.

`SendToEx`используется только в сокете SOCK_DGRAM для отправки датаграммы конкретному сокету, определяемому параметром *лпсоккаддр* .

Чтобы отправить вещание (только в SOCK_DGRAM), адрес в параметре *лпсоккаддр* должен быть создан с использованием специального IP-адреса INADDR_BROADCAST (определенного в файле заголовка Windows Sockets в формате Winsock. H) вместе с требуемым номером порта. Или, если параметр *лпсзостаддресс* имеет значение null, сокет настраивается для вещания. Как правило, широковещательная датаграмма должна превысить размер, при котором может произойти фрагментация, что означает, что часть данных датаграммы (за исключением заголовков) не должна превышать 512 байт.

## <a name="casyncsocketsetsockopt"></a><a name="setsockopt"></a>CAsyncSocket:: Сетсоккопт

Вызовите эту функцию-член, чтобы задать параметр сокета.

```
BOOL SetSockOpt(
    int nOptionName,
    const void* lpOptionValue,
    int nOptionLen,
    int nLevel = SOL_SOCKET);
```

### <a name="parameters"></a>Параметры

*ноптионнаме*<br/>
Параметр сокета, для которого задается значение.

*лпоптионвалуе*<br/>
Указатель на буфер, в котором указано значение запрошенного параметра.

*ноптионлен*<br/>
Размер буфера *лпоптионвалуе* в байтах.

*нлевел*<br/>
Уровень, на котором определен параметр; поддерживаются только уровни SOL_SOCKET и IPPROTO_TCP.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- ВСАЕФАУЛТ *лпоптионвалуе* не находится в допустимой части адресного пространства процесса.

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- Недопустимый ВСАЕИНВАЛ *нлевел* или неверная информация в *лпоптионвалуе* .

- Истекло время ожидания подключения ВСАЕНЕТРЕСЕТ, если SO_KEEPALIVE установлен.

- ВСАЕНОПРОТУПТ параметр неизвестен или не поддерживается. В частности, SO_BROADCAST не поддерживается для сокетов типа SOCK_STREAM, а SO_DONTLINGER, SO_KEEPALIVE, SO_LINGER и SO_OOBINLINE не поддерживаются для сокетов типа SOCK_DGRAM.

- ВСАЕНОТКОНН подключение было сброшено, когда задано SO_KEEPALIVE.

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

`SetSockOpt`Задает текущее значение параметра сокета, связанного с сокетом любого типа, в любом состоянии. Хотя параметры могут существовать на нескольких уровнях протоколов, эта спецификация определяет только те параметры, которые существуют на самом верхнем уровне "сокет". Параметры влияют на операции сокета, такие как получение срочных данных в нормальном потоке данных, возможность отправки широковещательных сообщений на сокет и т. д.

Существует два типа параметров сокетов: логические параметры, которые включают или отключает функцию или поведение, а также параметры, для которых требуется целочисленное значение или структура. Чтобы включить логический параметр, *лпоптионвалуе* указывает на ненулевое целое число. Чтобы отключить параметр *лпоптионвалуе* указывает на целое число, равное нулю. *ноптионлен* должен быть равен `sizeof(BOOL)` для логических параметров. Для других параметров *лпоптионвалуе* указывает на целое число или структуру, содержащую нужное значение параметра, а *ноптионлен* — длину целого числа или структуры.

SO_LINGER управляет действием, выполняемым, когда неотправленные данные помещаются в очередь на сокете, а `Close` функция вызывается для закрытия сокета.

По умолчанию сокет не может быть привязан (см. раздел [BIND](#bind)) с локальным адресом, который уже используется. Однако в некоторых случаях может потребоваться «повторно использовать» адрес таким образом. Поскольку каждое подключение однозначно определяется сочетанием локальных и удаленных адресов, нет проблем с подключением двух сокетов к одному локальному адресу, если удаленные адреса отличаются.

Чтобы сообщить о реализации сокетов Windows, что `Bind` вызов на сокете не должен быть запрещен, поскольку нужный адрес уже используется другим сокетом, приложение должно установить параметр SO_REUSEADDR сокета для сокета перед `Bind` вызовом. Обратите внимание, что параметр интерпретируется только во время `Bind` вызова: поэтому он не нужен (но является безопасным) для установки параметра на сокете, который не должен быть привязан к существующему адресу, и установки или сброса параметра после того, как `Bind` вызов не будет оказывать никакого влияния на этот или любой другой сокет.

Приложение может запрашивать, что реализация сокетов Windows позволяет использовать пакеты с поддержкой проверки на активность подключений по протоколу TCP, включив параметр сокета SO_KEEPALIVE. Реализация сокетов Windows не должна поддерживать использование проверки активности. Если это так, точная семантика зависит от реализации, но должна соответствовать разделу 4.2.3.6 RFC 1122: "требования для узлов Интернета — уровни связи". Если соединение отбрасывается как результат "Проверка активности", код ошибки ВСАЕНЕТРЕСЕТ возвращается к любым выполняемым в сокете вызовам, а последующие вызовы будут завершаться с помощью ВСАЕНОТКОНН.

Параметр TCP_NODELAY отключает алгоритм Nagle. Алгоритм Nagle используется для сокращения числа небольших пакетов, отправляемых узлом путем буферизации неподтвержденной отправки данных до тех пор, пока не будет отправлен пакет полного размера. Однако для некоторых приложений этот алгоритм может снизить производительность, а TCP_NODELAY можно использовать для его отключения. Средства записи приложений не должны устанавливать TCP_NODELAY, пока не будет хорошо понятный и желаемый эффект, поскольку Настройка TCP_NODELAY может оказать значительное негативное влияние на производительность сети. TCP_NODELAY является единственным поддерживаемым параметром сокета, который использует IPPROTO_TCP уровня; все остальные параметры используют SOL_SOCKET уровня.

Некоторые реализации сокетов Windows предоставляют выходные данные отладки, если параметр SO_DEBUG задан приложением.

Для поддерживаются следующие параметры `SetSockOpt` . Тип определяет тип данных, адресованных *лпоптионвалуе*.

|Значение|Тип|Значение|
|-----------|----------|-------------|
|SO_BROADCAST|BOOL|Разрешить передачу широковещательных сообщений на сокет.|
|SO_DEBUG|BOOL|Записать отладочную информацию.|
|SO_DONTLINGER|BOOL|Не блокируйте `Close` Ожидание отправки неотправленных данных. Установка этого параметра эквивалентна установке SO_LINGER с `l_onoff` нулевым значением.|
|SO_DONTROUTE|BOOL|Не маршрутизировать: прямая отправка в интерфейс.|
|SO_KEEPALIVE|BOOL|Отправка проверки активности.|
|SO_LINGER|`struct LINGER`|Ожидание `Close` при наличии неотправленных данных.|
|SO_OOBINLINE|BOOL|Получение нестандартных данных в потоке обычных данных.|
|SO_RCVBUF|**`int`**|Укажите размер буфера для получения.|
|SO_REUSEADDR|BOOL|Разрешить привязку сокета к адресу, который уже используется. (См. раздел [BIND](#bind).)|
|SO_SNDBUF|**`int`**|Укажите размер буфера для отправки.|
|TCP_NODELAY|BOOL|Отключить алгоритм Nagle для отправки объединенных пакетов.|

Параметры Berkeley Software Distribution (BSD) не поддерживаются для `SetSockOpt` :

|Значение|Тип|Значение|
|-----------|----------|-------------|
|SO_ACCEPTCONN|BOOL|Сокет прослушивается|
|SO_ERROR|**`int`**|Получение состояния ошибки и очистка.|
|SO_RCVLOWAT|**`int`**|Получение нижнего знака подложки.|
|SO_RCVTIMEO|**`int`**|Время ожидания получения|
|SO_SNDLOWAT|**`int`**|Отправка нижней метки наводы.|
|SO_SNDTIMEO|**`int`**|Время ожидания отправки.|
|SO_TYPE|**`int`**|Тип сокета.|
|IP_OPTIONS||Задание поля параметров в заголовке IP-адреса.|

## <a name="casyncsocketshutdown"></a><a name="shutdown"></a>CAsyncSocket:: ShutDown

Вызовите эту функцию члена, чтобы отключить операции отправки, получения или и то, и другое на сокете.

```
BOOL ShutDown(int nHow = sends);
```

### <a name="parameters"></a>Параметры

*нхов*<br/>
Флаг, описывающий, какие типы операций больше не будут разрешены, используя следующие перечислимые значения:

- **Получает = 0**

- **отправляет = 1**

- **Оба = 2**

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0, а конкретный код ошибки можно получить, вызвав [GetLastError](#getlasterror). К этой функции члена применяются следующие ошибки:

- ВСАНОТИНИТИАЛИСЕД успешное [афкссоккетинит](../../mfc/reference/application-information-and-management.md#afxsocketinit) должно произойти перед использованием этого API.

- ВСАЕНЕТДОВН. Реализация Windows Sockets обнаружила, что не удалось выполнить сетевую подсистему.

- Недопустимый ВСАЕИНВАЛ *нхов* .

- ВСАЕИНПРОГРЕСС выполняется операция блокирования сокетов Windows.

- ВСАЕНОТКОНН. сокет не подключен (только SOCK_STREAM).

- ВСАЕНОТСОКК. дескриптор не является сокетом.

### <a name="remarks"></a>Remarks

`ShutDown`используется для всех типов сокетов для отключения приема, передачи или и того и другого. Если значение *нхов* равно 0, последующие приемы на сокете будут запрещены. Это не влияет на более низкие уровни протокола.

Для протокола TCP TCP-окно не изменяется, и входящие данные принимаются (но не подтверждаются) до тех пор, пока окно не будет исчерпано. Для протокола UDP входящие датаграммы принимаются и ставятся в очередь. В противном случае будет создан пакет ошибок ICMP. Если *нхов* имеет значение 1, последующие отправки запрещены. Для сокетов TCP будет отправлен FIN. Установка параметра *нхов* в значение 2 отключает обе операции отправки и получения, как описано выше.

Обратите внимание, что не `ShutDown` закрывает сокет, а ресурсы, подключенные к сокету, не будут освобождены до `Close` вызова метода. Приложение не должно полагаться на возможность повторного использования сокета после его завершения работы. В частности, реализация сокетов Windows не требуется для поддержки использования `Connect` на таком сокете.

### <a name="example"></a>Пример

  См. пример для [CAsyncSocket:: OnReceive](#onreceive).

## <a name="casyncsocketsocket"></a><a name="socket"></a>CASyncSocket:: сокет

Выделяет маркер сокета.

```
BOOL Socket(
    int nSocketType = SOCK_STREAM,
    long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
    int nProtocolType = 0,
    int nAddressFormat = PF_INET);
```

### <a name="parameters"></a>Параметры

*нсоккеттипе*<br/>
Указывает `SOCK_STREAM` или `SOCK_DGRAM` .

*левент*<br/>
Битовая маска, указывающая сочетание сетевых событий, в которых заинтересовано приложение.

- `FD_READ`: Требуется получить уведомление о готовности к чтению.

- `FD_WRITE`: Требуется получить уведомление о готовности к написанию.

- `FD_OOB`: Требуется получение уведомлений о поступлении нестандартных данных.

- `FD_ACCEPT`: Требуется получение уведомлений о входящих подключениях.

- `FD_CONNECT`: Требуется получение уведомлений о завершенном подключении.

- `FD_CLOSE`: Требуется получение уведомлений о замыкании сокета.

*нпротоколтипе*<br/>
Протокол, используемый с сокетом, относящимся к указанному семейству адресов.

*наддрессформат*<br/>
Спецификация семейства адресов.

### <a name="return-value"></a>Возвращаемое значение

Возвращает значение "успешно" в случае `TRUE` `FALSE` сбоя.

### <a name="remarks"></a>Remarks

Этот метод выделяет маркер сокета. Он не вызывает [CAsyncSocket:: BIND](#bind) для привязки сокета к указанному адресу, поэтому необходимо вызвать позже, `Bind` чтобы привязать сокет к указанному адресу. Чтобы задать параметр сокета перед его привязкой, можно использовать [CAsyncSocket:: сетсоккопт](#setsockopt) .

## <a name="see-also"></a>См. также раздел

[CObject, класс](../../mfc/reference/cobject-class.md)<br/>
[Иерархическая диаграмма](../../mfc/hierarchy-chart.md)<br/>
[Класс CSocket](../../mfc/reference/csocket-class.md)<br/>
[Класс CSocketFile](../../mfc/reference/csocketfile-class.md)
