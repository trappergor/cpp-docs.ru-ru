---
title: Класс CEvent
ms.date: 11/04/2016
f1_keywords:
- CEvent
- AFXMT/CEvent
- AFXMT/CEvent::CEvent
- AFXMT/CEvent::PulseEvent
- AFXMT/CEvent::ResetEvent
- AFXMT/CEvent::SetEvent
- AFXMT/CEvent::Unlock
helpviewer_keywords:
- CEvent [MFC], CEvent
- CEvent [MFC], PulseEvent
- CEvent [MFC], ResetEvent
- CEvent [MFC], SetEvent
- CEvent [MFC], Unlock
ms.assetid: df676042-ce27-4702-800a-e73ff4f44395
ms.openlocfilehash: 009a17342cb92025d67bf2fe0df1b9d5c7c0c6f0
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81373960"
---
# <a name="cevent-class"></a>Класс CEvent

Представляет событие, являвется объектом синхронизации, позволяющим одному потоку уведомлять другой о том, что событие произошло.

## <a name="syntax"></a>Синтаксис

```
class CEvent : public CSyncObject
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CEvent::CEvent](#cevent)|Формирует объект `CEvent`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CEvent::PulseEvent](#pulseevent)|Устанавливает событие к доступному (сигнализированному), выпускает потоки ожидания и устанавливает событие в недоступное (несигнализированное).|
|[CEvent::ResetEvent](#resetevent)|Устанавливает событие недоступно (несигнализированное).|
|[CEvent::SetEvent](#setevent)|Устанавливает событие в доступное (сигнализированное) и выпускает любые ожидающие потоки.|
|[CEvent::Разблокирование](#unlock)|Выпускает объект события.|

## <a name="remarks"></a>Remarks

События полезны, когда поток должен знать, когда выполнять свою задачу. Например, поток, который копирует данные в архив данных, должен быть уведомлен при наличии новых данных. С помощью `CEvent` объекта для уведомления потока копий потока при наличии новых данных поток может выполнить свою задачу как можно скорее.

`CEvent`объекты имеют два типа: ручной и автоматический.

Автоматический `CEvent` объект автоматически возвращается в состояние, не доступное (недоступное) после выпуска хотя бы одного потока. По умолчанию `CEvent` объект автоматически проходит, если вы не проходите `TRUE` для параметра *bManualReset* во время строительства.

Объект `CEvent` ручного вхажий остается в состоянии, установленном [SetEvent](#setevent) или [ResetEvent,](#resetevent) пока не будет вызвана другая функция. Чтобы создать `CEvent` ручной `TRUE` объект, `bManualReset` пройти по параметру во время строительства.

Чтобы использовать `CEvent` объект, `CEvent` постройте объект, когда это необходимо. Укажите название события, которое вы хотите ждать, а также укажите, что ваше приложение должно изначально владеть им. Затем можно получить доступ к событию при возврате конструктора. Вызов [SetEvent,](#setevent) чтобы сигнализировать (сделать доступным) объект события, а затем вызвать [разблокировку,](#unlock) когда вы закончите доступ к контролируемому ресурсу.

Альтернативным методом `CEvent` использования объектов является `CEvent` добавление переменной типа в качестве члена данных в класс, который вы хотите контролировать. Во время строительства контролируемого объекта позвоните в конструктор пользователя `CEvent` данных и укажите, является ли событие изначально сигнализированным, а также укажите тип объекта события, который вы хотите, имя события (если оно будет использовано через границы процесса), и любые атрибуты безопасности, которые вы хотите.

Чтобы получить таким образом `CEvent` доступ к ресурсу, контролируемому объектом, сначала создайте переменную либо типа [CSingleLock,](../../mfc/reference/csinglelock-class.md) либо введите [CMultiLock](../../mfc/reference/cmultilock-class.md) в методе доступа ресурса. Затем позвоните в `Lock` метод объекта блокировки (например, [CMultiLock::Lock](../../mfc/reference/cmultilock-class.md#lock)). На этом этапе поток либо получит доступ к ресурсу, либо будет ждать, пока ресурс будет выпущен, и получит доступ, либо будет ждать, пока ресурс будет выпущен, тайм-аут и не сможет получить доступ к ресурсу. В любом случае, доступ к вашему ресурсу был безопасным способом. Чтобы освободить ресурс, `SetEvent` позвоните, чтобы сигнализировать `Unlock` объект события, а затем используйте метод объекта блокировки (например, [CMultiLock::Unlock),](../../mfc/reference/cmultilock-class.md#unlock)или пусть объект блокировки выпадет из области.

Для получения дополнительной информации о том, как использовать `CEvent` объекты, см. [Multithreading: How to Use the Synchronization Classes](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)

## <a name="example"></a>Пример

[!code-cpp[NVC_MFC_Utilities#45](../../mfc/codesnippet/cpp/cevent-class_1.cpp)]

[!code-cpp[NVC_MFC_Utilities#46](../../mfc/codesnippet/cpp/cevent-class_2.cpp)]

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CSyncObject](../../mfc/reference/csyncobject-class.md)

`CEvent`

## <a name="requirements"></a>Требования

**Заголовок:** afxmt.h

## <a name="ceventcevent"></a><a name="cevent"></a>CEvent::CEvent

Строит названный или `CEvent` неназванный объект.

```
CEvent(
    BOOL bInitiallyOwn = FALSE,
    BOOL bManualReset = FALSE,
    LPCTSTR lpszName = NULL,
    LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);
```

### <a name="parameters"></a>Параметры

*bInitiallyOwn*<br/>
Если true, поток `CMultilock` для `CSingleLock` объекта включен. В противном случае все потоки, желающие получить доступ к ресурсу, должны подождать.

*bManualReset*<br/>
Если истина, указывает, что объект события является ручным событием, в противном случае объект события является автоматическим событием.

*lpszName*<br/>
Имя объекта `CEvent`. Должен быть поставлен, если объект будет использоваться через границы процесса. Если имя совпадает с существующим событием, `CEvent` конструктор создает новый объект, который ссылается на событие этого имени. Если имя совпадает с существующим объектом синхронизации, который не является событием, конструкция завершается неудачей. Если NULL, имя будет недействительным.

*lpsaAttribute*<br/>
Атрибуты безопасности для объекта события. Полное описание этой структуры [можно](/previous-versions/windows/desktop/legacy/aa379560\(v=vs.85\)) SECURITY_ATTRIBUTES в SDK Windows.

### <a name="remarks"></a>Remarks

Чтобы получить доступ `CEvent` к объекту или освободить объект, создайте объект [CMultiLock](../../mfc/reference/cmultilock-class.md) или [CSingleLock](../../mfc/reference/csinglelock-class.md) и позвоните [в](../../mfc/reference/csinglelock-class.md#lock) его функции lock and [Unlock.](../../mfc/reference/csinglelock-class.md#unlock)

Чтобы изменить состояние `CEvent` объекта на сигнал (потоки ждать не нужно), позвоните [setEvent](#setevent) или [PulseEvent](#pulseevent). Чтобы установить состояние `CEvent` объекта на несигнализированный (потоки должны подождать), позвоните [в ResetEvent.](#resetevent)

> [!IMPORTANT]
> После создания `CEvent` объекта используйте [GetLastError,](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) чтобы убедиться, что mutex еще не существует. Если mutex действительно существовал неожиданно, это может означать, что процесс изгоев приседает на корточках и может быть намерен использовать mutex злонамеренно. В этом случае рекомендуемая процедура, связанная с безопасностью, заключается в том, чтобы закрыть ручку и продолжить, как если бы произошел сбой в создании объекта.

## <a name="ceventpulseevent"></a><a name="pulseevent"></a>CEvent::PulseEvent

Устанавливает состояние события в сигнальные (доступные), автоматически выпускает любые ожидающие потоки и автоматически сбрасывает его на несигнализированные (недоступные).

```
BOOL PulseEvent();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция была успешной; в противном случае 0.

### <a name="remarks"></a>Remarks

Если событие выполняется вручную, все потоки ожидания освобождаются, событие `PulseEvent` устанавливается на несигнал из дан и возвращается. Если событие происходит автоматически, один поток освобождается, событие устанавливается `PulseEvent` на несигнал из несигналистого и возвращается.

Если потоки не ждут, или потоки не `PulseEvent` могут быть немедленно выпущены, устанавливает состояние события на несигнализируется и возвращается.

`PulseEvent`использует базовую функцию `PulseEvent` Win32, которая может быть на мгновение удалена из состояния ожидания асинхронным вызовом процедуры ядра-режима. Таким `PulseEvent` образом, является ненадежным и не должны использоваться новыми приложениями. Для получения дополнительной [информации](/windows/win32/api/winbase/nf-winbase-pulseevent)см.

## <a name="ceventresetevent"></a><a name="resetevent"></a>CEvent::ResetEvent

Устанавливает состояние события в несигналистов до тех пор, пока не будет явно установлено для сигнализации функцией участника [SetEvent.](#setevent)

```
BOOL ResetEvent();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция была успешной; в противном случае 0.

### <a name="remarks"></a>Remarks

Это заставляет все потоки, желающие получить доступ к этому событию, ждать.

Эта функция участника не используется автоматическими событиями.

## <a name="ceventsetevent"></a><a name="setevent"></a>CEvent::SetEvent

Устанавливает состояние события в сигнал, выпуская любые ожидающие потоки.

```
BOOL SetEvent();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция была успешной, в противном случае 0.

### <a name="remarks"></a>Remarks

Если событие является ручным, событие будет оставаться сигналом до вызова [ResetEvent.](#resetevent) В этом случае может быть выпущено несколько потоков. Если событие происходит автоматически, событие будет оставаться сигналом до тех пор, пока не будет выпущен один поток. Затем система установит состояние события в несигнал. Если потоки не ждут, состояние остается сигналом до выпуска одного потока.

## <a name="ceventunlock"></a><a name="unlock"></a>CEvent::Разблокирование

Выпускает объект события.

```
BOOL Unlock();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если поток принадлежит объекту события, а событие является автоматическим событием; в противном случае 0.

### <a name="remarks"></a>Remarks

Эта функция элемента вызывается потоками, которые в настоящее время владеют автоматическим событием, чтобы выпустить его после того, как они сделаны, если их объект блокировки должен быть повторно использован. Если объект блокировки не будет повторно использован, эта функция будет вызвана деструктором объекта блокировки.

## <a name="see-also"></a>См. также раздел

[Класс CSyncObject](../../mfc/reference/csyncobject-class.md)<br/>
[Диаграмма иерархии](../../mfc/hierarchy-chart.md)
