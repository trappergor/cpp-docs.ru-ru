---
title: Класс Кмемфиле
description: Описывает функции, доступные в классе Кмемфиле, которые позволяют работать с файлами памяти.
ms.date: 07/23/2020
f1_keywords:
- CMemFile
- AFX/CMemFile
- AFX/CMemFile::CMemFile
- AFX/CMemFile::Attach
- AFX/CMemFile::Detach
- AFX/CMemFile::Alloc
- AFX/CMemFile::Free
- AFX/CmemFile::GetBufferPtr
- AFX/CMemFile::GrowFile"
- AFX/CMemFile::Memcpy
- AFX/CMemFile::Realloc
helpviewer_keywords:
- CMemFile [MFC], CMemFile
- CMemFile [MFC], Attach
- CMemFile [MFC], Detach
- CMemFile [MFC], Alloc
- CMemFile [MFC], Free
- CMemFile [MFC], GetBufferPtr
- CMemFile [MFC], GrowFile
- CMemFile [MFC], Memcpy
- CMemFile [MFC], Realloc
ms.assetid: 20e86515-e465-4f73-b2ea-e49789d63165
ms.openlocfilehash: edd1d8b8d3979427602bdb61fc7647aec15d58b5
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87222944"
---
# <a name="cmemfile-class"></a>Класс Кмемфиле

Класс, производный от [кфиле](../../mfc/reference/cfile-class.md), который поддерживает файлы памяти.

## <a name="syntax"></a>Синтаксис

```
class CMemFile : public CFile
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание:|
|----------|-----------------|
|[Кмемфиле:: Кмемфиле](#cmemfile)|Конструирует объект файла памяти.|

### <a name="public-methods"></a>Открытые методы

|name|Описание:|
|----------|-----------------|
|[Кмемфиле:: Attach](#attach)|Присоединяет блок памяти к `CMemFile` .|
|[Кмемфиле::D етач](#detach)|Отсоединяет блок памяти от `CMemFile` и возвращает указатель на блок памяти отсоединяется.|
|[Кмемфиле:: Жетбуфферптр](#getbufferptr)|Получение или запись в буфер памяти, который создает резервную копию файла памяти.|

### <a name="protected-methods"></a>Защищенные методы

|Имя|Описание:|
|----------|-----------------|
|[Кмемфиле:: Alloc](#alloc)|Переопределите, чтобы изменить поведение выделения памяти.|
|[Кмемфиле:: Free](#free)|Переопределите, чтобы изменить поведение при освобождении памяти.|
|[Кмемфиле:: Гровфиле](#growfile)|Переопределите, чтобы изменить поведение при увеличении размера файла.|
|[Кмемфиле:: memcpy](#memcpy)|Переопределите, чтобы изменить поведение копирования в памяти при чтении и записи файлов.|
|[Кмемфиле:: перераспределить](#realloc)|Переопределите, чтобы изменить поведение при перераспределении памяти.|

## <a name="remarks"></a>Remarks

Эти файлы памяти ведут себя как дисковые файлы, за исключением того, что файл хранится в ОЗУ, а не на диске. Файл памяти полезен для:

- быстрое временное хранилище
- Передача необработанных байтов между независимыми процессами
- Передача сериализованных объектов между независимыми процессами

`CMemFile`объекты могут автоматически распределять собственную память. Или можно присоединить собственный блок памяти к `CMemFile` объекту, вызвав [attach](#attach). В любом случае память для увеличения размера файла памяти автоматически выделяется по `nGrowBytes` размеру, если `nGrowBytes` не равен нулю.

Блок памяти будет автоматически удален после уничтожения `CMemFile` объекта, если память была изначально выделена `CMemFile` объектом. в противном случае вы несете ответственность за отмену выделения памяти, присоединенной к объекту.

Доступ к блоку памяти можно получить с помощью указателя, предоставленного при его отсоединении от `CMemFile` объекта путем вызова метода [Detach](#detach).

Чаще всего используется `CMemFile` для создания `CMemFile` объекта и его использования путем вызова функций-членов [кфиле](../../mfc/reference/cfile-class.md) . Создание `CMemFile` автоматически открывает его: вы не вызываете [кфиле:: Open](../../mfc/reference/cfile-class.md#open), который используется только для дисковых файлов. Поскольку `CMemFile` не использует файл на диске, элемент данных `CFile::m_hFile` не используется.

`CFile`Функции элементов, [Duplicate](../../mfc/reference/cfile-class.md#duplicate) [локкранже](../../mfc/reference/cfile-class.md#lockrange)и [унлоккранже](../../mfc/reference/cfile-class.md#unlockrange) , не реализуются для `CMemFile` . При вызове этих функций для `CMemFile` объекта вы получите [кнотсуппортедексцептион](../../mfc/reference/cnotsupportedexception-class.md).

`CMemFile`использует функции библиотеки времени выполнения [malloc](../../c-runtime-library/reference/malloc.md), [realloc](../../c-runtime-library/reference/realloc.md)и [Free](../../c-runtime-library/reference/free.md) для выделения, перераспределения и освобождения памяти; и встроенная [memcpy](../../c-runtime-library/reference/memcpy-wmemcpy.md) для блокировки памяти копирования при чтении и записи. Если вы хотите изменить это поведение или поведение при `CMemFile` расширении файла, сделайте собственный класс производным от `CMemFile` и переопределите соответствующие функции.

Дополнительные сведения о см `CMemFile` . в разделе [файлы статей в MFC](../../mfc/files-in-mfc.md) и [управлении памятью (MFC)](../../mfc/memory-management.md) и см. в разделе [Обработка файлов](../../c-runtime-library/file-handling.md) в *справочнике по библиотеке времени выполнения*.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CFile](../../mfc/reference/cfile-class.md)

`CMemFile`

## <a name="requirements"></a>Требования

**Заголовок:** AFX. h

## <a name="cmemfilealloc"></a><a name="alloc"></a>Кмемфиле:: Alloc

Эта функция вызывается `CMemFile` функциями-членами.

```
virtual BYTE* Alloc(SIZE_T nBytes);
```

### <a name="parameters"></a>Параметры

*nBytes*<br/>
Число байтов памяти, выделяемых для выделения.

### <a name="return-value"></a>Возвращаемое значение

Указатель на выделенный блок памяти или значение NULL в случае сбоя выделения.

### <a name="remarks"></a>Remarks

Переопределите эту функцию, чтобы реализовать пользовательское выделение памяти. При переопределении этой функции вы, вероятно, захотите также переопределить [Free](#free) и [realloc](#realloc) .

Реализация по умолчанию использует функцию [malloc](../../c-runtime-library/reference/malloc.md) функции библиотеки времени выполнения для выделения памяти.

## <a name="cmemfileattach"></a><a name="attach"></a>Кмемфиле:: Attach

Вызовите эту функцию, чтобы присоединить блок памяти к `CMemFile` .

```cpp
void Attach(
    BYTE* lpBuffer,
    UINT nBufferSize,
    UINT nGrowBytes = 0);
```

### <a name="parameters"></a>Параметры

*лпбуффер*<br/>
Указатель на буфер, к которому необходимо присоединиться `CMemFile` .

*нбуфферсизе*<br/>
Целое число, указывающее размер буфера в байтах.

*нгровбитес*<br/>
Шаг выделения памяти в байтах.

### <a name="remarks"></a>Remarks

Это приводит `CMemFile` к использованию блока памяти в качестве файла памяти.

Если *нгровбитес* имеет значение 0, `CMemFile` будет задана длина файла *нбуфферсизе*. Это означает, что данные в блоке памяти до того, как они были присоединены к, `CMemFile` будут использоваться в качестве файла. Создаваемые таким образом файлы памяти не могут быть увеличены.

Поскольку файл не может быть увеличился, следует избегать `CMemFile` попыток увеличить размер файла. Например, не вызывайте `CMemFile` переопределения [Кфиле: Write](../../mfc/reference/cfile-class.md#write) для записи после конца или не вызывайте [кфиле: SetLength](../../mfc/reference/cfile-class.md#setlength) с длиной больше *нбуфферсизе*.

Если *нгровбитес* больше 0, `CMemFile` будет игнорировать содержимое присоединенного блока памяти. Необходимо записать содержимое файла памяти с нуля с помощью `CMemFile` переопределения `CFile::Write` . Если вы попытаетесь записать после конца файла или увеличить его, вызвав `CMemFile` Переопределение `CFile::SetLength` , `CMemFile` будет увеличивать объем выделяемой памяти с шагом в *нгровбитес*. Увеличение выделения памяти завершится ошибкой, если блок памяти, передаваемый в, не `Attach` был выделен с помощью метода, совместимого с [Alloc](#alloc). Чтобы обеспечить совместимость с реализацией по умолчанию `Alloc` , необходимо выделить память в функции библиотеки времени выполнения [malloc](../../c-runtime-library/reference/malloc.md) или [calloc](../../c-runtime-library/reference/calloc.md).

## <a name="cmemfilecmemfile"></a><a name="cmemfile"></a>Кмемфиле:: Кмемфиле

Первая перегрузка открывает пустой файл памяти.

```
CMemFile(UINT nGrowBytes = 1024);

CMemFile(
    BYTE* lpBuffer,
    UINT nBufferSize,
    UINT nGrowBytes = 0);
```

### <a name="parameters"></a>Параметры

*нгровбитес*<br/>
Шаг выделения памяти в байтах.

*лпбуффер* Указатель на буфер, который получает сведения о размере *нбуфферсизе*.

*нбуфферсизе*<br/>
Целое число, указывающее размер буферного файла в байтах.

### <a name="remarks"></a>Remarks

Файл открывается конструктором. Не вызывайте [кфиле:: Open](../../mfc/reference/cfile-class.md#open).

Вторая перегрузка действует так же, как при использовании первого конструктора и сразу называемого [attach](#attach) с теми же параметрами. Дополнительные сведения см. в разделе `Attach`.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCFiles#36](../../atl-mfc-shared/reference/codesnippet/cpp/cmemfile-class_1.cpp)]

## <a name="cmemfiledetach"></a><a name="detach"></a>Кмемфиле::D етач

Вызовите эту функцию, чтобы получить указатель на блок памяти, используемый `CMemFile` .

```
BYTE* Detach();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на блок памяти, который содержит содержимое файла памяти.

### <a name="remarks"></a>Remarks

При вызове этой функции также закрывается `CMemFile` . Вы можете повторно присоединить блок памяти к `CMemFile` , вызвав [attach](#attach). Если необходимо повторно присоединить файл и использовать в нем данные, следует вызвать метод [кфиле:: DATALENGTH](../../mfc/reference/cfile-class.md#getlength) , чтобы получить длину файла перед вызовом `Detach` . Если вы подключаете блок памяти к, чтобы `CMemFile` можно было использовать его данные ( `nGrowBytes` = = 0), вы не сможете увеличить файл памяти.

## <a name="cmemfilefree"></a><a name="free"></a>Кмемфиле:: Free

Эта функция вызывается `CMemFile` функциями-членами.

```
virtual void Free(BYTE* lpMem);
```

### <a name="parameters"></a>Параметры

*лпмем*<br/>
Указатель на память, которую необходимо освободить.

### <a name="remarks"></a>Remarks

Переопределите эту функцию, чтобы реализовать пользовательское освобождение памяти. При переопределении этой функции вы, вероятно, захотите также [Alloc](#alloc) переопределить Alloc [и override](#realloc) .

## <a name="cmemfilegetbufferptr"></a><a name="getbufferptr"></a>Кмемфиле:: Жетбуфферптр

Получение или запись в буфер памяти, который создает резервную копию файла памяти.

```cpp
virtual UINT GetBufferPtr(
    UINT nCommand,
    UINT nCount = 0,
    void** ppBufStart = NULL,
    void** ppBufMax = NULL
);
```

### <a name="parameters"></a>Параметры

*Nвыполненная команда*<br/>
[Буфферкомманд](buffercommand-enumeration.md) для выполнения ( `bufferCheck` , `bufferCommit` , `bufferRead` или `bufferWrite` ).

*нкаунт*<br/>
В зависимости от *nвыполненная команда*число байтов в буфере для чтения, записи или фиксации. При чтении из буфера укажите значение-1, чтобы вернуть буфер из текущей точки в конец файла.

*ппбуфстарт*<br/>
заполняет Начало буфера. Должен быть `NULL` , если *nвыполненная команда* имеет `bufferCommit` .

*ппбуфмакс*<br/>
заполняет Конец буфера. Должен быть `NULL` , если nвыполненная команда имеет `bufferCommit` .

### <a name="return-value"></a>Возвращаемое значение

| значение *команды* | Возвращаемое значение |
|--|--|
| `buffercheck` | Возвращает [буффердирект](buffercommand-enumeration.md) , если прямая буферизация поддерживается; в противном случае — значение 0. |
| `bufferCommit` | Возвращает `0`. |
| `bufferRead` или `bufferWrite` | Возвращает число байтов в возвращенном буферном пространстве. *ппбуфстарт* и *ппбуфмакс* указывают на начало и конец буфера чтения/запись.  |

### <a name="remarks"></a>Remarks

Текущее расположение в буфере памяти ( `m_nPosition` ) расширено следующими способами, в зависимости от *nвыполненная команда*:

| *Nвыполненная команда* | расположение буфера |
|-|-|
| `bufferCommit` | Текущее расположение увеличивается на размер зафиксированного буфера. |
| `bufferRead` | Текущее расположение увеличивается на размер буфера чтения. |

## <a name="cmemfilegrowfile"></a><a name="growfile"></a>Кмемфиле:: Гровфиле

Эта функция вызывается несколькими `CMemFile` функциями-членами.

```
virtual void GrowFile(SIZE_T dwNewLen);
```

### <a name="parameters"></a>Параметры

*двневлен*<br/>
Новый размер файла памяти.

### <a name="remarks"></a>Remarks

Его можно переопределить, если нужно изменить степень `CMemFile` роста файла. Реализация по умолчанию [вызывает](#realloc) перераспределение для увеличения существующего блока (или [выделения](#alloc) для создания блока памяти), выделяя память в нескольких `nGrowBytes` значениях, указанных в конструкторе или вызове [присоединения](#attach) .

## <a name="cmemfilememcpy"></a><a name="memcpy"></a>Кмемфиле:: memcpy

Эта функция вызывается `CMemFile` переопределениями [кфиле:: Read](../../mfc/reference/cfile-class.md#read) и [кфиле:: Write](../../mfc/reference/cfile-class.md#write) для перемещения данных в файл памяти и из него.

```
virtual BYTE* Memcpy(
    BYTE* lpMemTarget,
    const BYTE* lpMemSource,
    SIZE_T nBytes);
```

### <a name="parameters"></a>Параметры

*лпмемтаржет*<br/>
Указатель на блок памяти, в который будет скопирована исходная память.

*лпмемсаурце*<br/>
Указатель на блок памяти источника.

*nBytes*<br/>
Число байтов для копирования.

### <a name="return-value"></a>Возвращаемое значение

Копия *лпмемтаржет*.

### <a name="remarks"></a>Remarks

Переопределите эту функцию, если требуется изменить способ, который `CMemFile` выполняет эти копии памяти.

## <a name="cmemfilerealloc"></a><a name="realloc"></a>Кмемфиле:: перераспределить

Эта функция вызывается `CMemFile` функциями-членами.

```
virtual BYTE* Realloc(
    BYTE* lpMem,
    SIZE_T nBytes);
```

### <a name="parameters"></a>Параметры

*лпмем*<br/>
Указатель на блок памяти, который необходимо перераспределить.

*nBytes*<br/>
Новый размер блока памяти.

### <a name="return-value"></a>Возвращаемое значение

Указатель на блок памяти, который был перераспределен (и, возможно, перемещен), или значение NULL, если произошел сбой при перераспределении.

### <a name="remarks"></a>Remarks

Переопределите эту функцию, чтобы реализовать пользовательское повторное выделение памяти. При переопределении этой функции вы, вероятно, захотите также переопределить [Alloc](#alloc) и [Free](#free) .

## <a name="see-also"></a>См. также статью

[Класс Кфиле](../../mfc/reference/cfile-class.md)<br/>
[Иерархическая диаграмма](../../mfc/hierarchy-chart.md)
