---
title: Класс CSemaphore
ms.date: 11/04/2016
f1_keywords:
- CSemaphore
- AFXMT/CSemaphore
- AFXMT/CSemaphore::CSemaphore
helpviewer_keywords:
- CSemaphore [MFC], CSemaphore
ms.assetid: 385fc7e4-8f86-4be2-85e1-d23b38c12f7f
ms.openlocfilehash: 26e1fd55d321b221f4732874d57d02a79c4c6398
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81318498"
---
# <a name="csemaphore-class"></a>Класс CSemaphore

Объект класса `CSemaphore` представляет собой "семафор" - объект синхронизации, который позволяет ограниченному числу потоков в одном или нескольких процессах получить доступ к подсчету количества потоков, в настоящее время имеющих доступ к определенному ресурсу.

## <a name="syntax"></a>Синтаксис

```
class CSemaphore : public CSyncObject
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CSemaphore::CSemaphore](#csemaphore)|Формирует объект `CSemaphore`.|

## <a name="remarks"></a>Remarks

Semaphores полезны для управления доступом к общему ресурсу, который может поддерживать только ограниченное число пользователей. Текущий подсчет `CSemaphore` объекта — это количество разрешенных дополнительных пользователей. Когда счет достигает нуля, все попытки использовать `CSemaphore` ресурс, контролируемый объектом, будут вставлены в системную очередь и ждать, пока они либо тайм-аут или количество поднимутся выше 0. При строительстве объекта указывается максимальное количество пользователей, которые `CSemaphore` могут одновременно получить доступ к контролируемому ресурсу.

Чтобы использовать `CSemaphore` объект, `CSemaphore` постройте объект, когда это необходимо. Укажите имя семафора, на который вы хотите ждать, и что ваше приложение должно изначально владеть им. Затем можно получить доступ к семафору, когда конструктор возвращается. Вызов [CSyncObject::Разблокировать,](../../mfc/reference/csyncobject-class.md#unlock) когда вы сделали доступ к контролируемому ресурсу.

Альтернативным методом `CSemaphore` использования объектов является `CSemaphore` добавление переменной типа в качестве члена данных в класс, который вы хотите контролировать. Во время строительства контролируемого объекта позвоните в конструктор автором `CSemaphore` данных, указав начальный отсчет доступа, максимальное количество доступа, имя семафора (если он будет использоваться через границы процесса) и желаемые атрибуты безопасности.

Чтобы получить доступ `CSemaphore` к ресурсам, контролируемым объектами таким образом, сначала создайте переменную типа [CSingleLock](../../mfc/reference/csinglelock-class.md) или введите [CMultiLock](../../mfc/reference/cmultilock-class.md) в функции члена доступа ресурса. Затем позвоните функции `Lock` члена объекта блокировки (например, [CSingleLock::Lock).](../../mfc/reference/csinglelock-class.md#lock) На этом этапе поток либо получит доступ к ресурсу, либо будет ждать, пока ресурс будет выпущен, и получит доступ, либо будет ждать, пока ресурс будет выпущен и тайм-аут, не получив доступа к ресурсу. В любом случае, доступ к вашему ресурсу был безопасным способом. Чтобы освободить ресурс, используйте функцию `Unlock` члена объекта блокировки (например, [CSingleLock::Unlock),](../../mfc/reference/csinglelock-class.md#unlock)или позвольте объекту блокировки выпасть из сферы охвата.

Кроме того, можно `CSemaphore` создать объект автономным и получить к нему прямой доступ, прежде чем пытаться получить доступ к контролируемому ресурсу. Этот метод, в то время как яснее для кого-то читать исходный код, более подвержен ошибкам.

Для получения дополнительной информации о том, как использовать `CSemaphore` объекты, смотрите статью [Многопоточность: Как использовать классы синхронизации](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CSyncObject](../../mfc/reference/csyncobject-class.md)

`CSemaphore`

## <a name="requirements"></a>Требования

**Заголовок:** afxmt.h

## <a name="csemaphorecsemaphore"></a><a name="csemaphore"></a>CSemaphore::CSemaphore

Строит названный или `CSemaphore` неназванный объект.

```
CSemaphore(
    LONG lInitialCount = 1,
    LONG lMaxCount = 1,
    LPCTSTR pstrName = NULL,
    LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);
```

### <a name="parameters"></a>Параметры

*lПервоначальный счет*<br/>
Первоначальный подсчет использования семафора. Должно быть больше, чем или равна 0, и меньше, чем или *равна lMaxCount*.

*lMaxCount*<br/>
Максимальное количество использования семафора. Должно быть больше 0.

*pstrName*<br/>
Название семафора. Должен быть поставлен, если семафор будет доступен через границы процесса. Если `NULL`объект будет безымянным. Если имя совпадает с существующим семафором, `CSemaphore` конструктор создает новый объект, который ссылается на семафор этого имени. Если имя совпадает с существующим объектом синхронизации, который не является семафором, конструкция выйдет из строя.

*lpsa Attributes*<br/>
Атрибуты безопасности для объекта семафора. Полное описание этой структуры [можно](/previous-versions/windows/desktop/legacy/aa379560\(v=vs.85\)) SECURITY_ATTRIBUTES в SDK Windows.

### <a name="remarks"></a>Remarks

Чтобы получить доступ `CSemaphore` к объекту или освободить объект, создайте объект [CMultiLock](../../mfc/reference/cmultilock-class.md) или [CSingleLock](../../mfc/reference/csinglelock-class.md) и позвоните [в](../../mfc/reference/csinglelock-class.md#lock) его функции lock and [Unlock.](../../mfc/reference/csinglelock-class.md#unlock)

> [!IMPORTANT]
> После создания `CSemaphore` объекта используйте [GetLastError,](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) чтобы убедиться, что mutex еще не существует. Если mutex действительно существовал неожиданно, это может означать, что процесс изгоев приседает на корточках и может быть намерен использовать mutex злонамеренно. В этом случае рекомендуемая процедура, связанная с безопасностью, заключается в том, чтобы закрыть ручку и продолжить, как если бы произошел сбой в создании объекта.

## <a name="see-also"></a>См. также раздел

[Класс CSyncObject](../../mfc/reference/csyncobject-class.md)<br/>
[Диаграмма иерархии](../../mfc/hierarchy-chart.md)
