---
title: Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX
ms.date: 09/12/2018
helpviewer_keywords:
- MFC ActiveX controls [MFC], painting
- MFC ActiveX controls [MFC], optimizing
ms.assetid: 25fff9c0-4dab-4704-aaae-8dfb1065dee3
ms.openlocfilehash: a01a66402471b295a6e57af8af265c50685b4a1f
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84618225"
---
# <a name="mfc-activex-controls-painting-an-activex-control"></a>Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX

В этой статье описывается процесс рисования элемента управления ActiveX и объясняется, как можно изменить код рисования для оптимизации процесса. (См. раздел [Оптимизация рисования элементов управления](optimizing-control-drawing.md) для приемов оптимизации рисования путем отсутствия элементов управления для индивидуального восстановления ранее выбранных объектов GDI. После прорисовки всех элементов управления контейнер может автоматически восстановить исходные объекты.)

>[!IMPORTANT]
> ActiveX — это устаревшая технология, которую не следует использовать для новой разработки. Дополнительные сведения о современных технологиях, которые заменяют ActiveX, см. в разделе [элементы управления ActiveX](activex-controls.md).

Примеры в этой статье взяты из элемента управления, созданного мастером элементов ActiveX MFC с параметрами по умолчанию. Дополнительные сведения о создании каркасного приложения для управления с помощью мастера элементов ActiveX MFC см. в статье [Мастер элементов ActiveX MFC](reference/mfc-activex-control-wizard.md).

Рассматриваются следующие темы.

- [Общий процесс рисования элемента управления и кода, созданного мастером элементов управления ActiveX для поддержки рисования](#_core_the_painting_process_of_an_activex_control)

- [Оптимизация процесса рисования](#_core_optimizing_your_paint_code)

- [Рисование элемента управления с помощью метафайлов](#_core_painting_your_control_using_metafiles)

## <a name="the-painting-process-of-an-activex-control"></a><a name="_core_the_painting_process_of_an_activex_control"></a>Процесс рисования элемента управления ActiveX

Когда элементы управления ActiveX изначально отображаются или перерисовывается, они следуют процессу рисования, аналогичному другим приложениям, разработанным с помощью MFC, с одним важным различием: элементы управления ActiveX могут находиться в активном или неактивном состоянии.

Активный элемент управления представлен в контейнере элементов управления ActiveX дочерним окном. Как и другие окна, он отвечает за рисование при получении сообщения WM_PAINT. Базовый класс элемента управления [COleControl](reference/colecontrol-class.md)обрабатывает это сообщение в своей `OnPaint` функции. Эта реализация по умолчанию вызывает `OnDraw` функцию элемента управления.

Неактивный элемент управления закрашивается по-другому. Если элемент управления неактивен, его окно либо невидимое, либо не существует, поэтому оно не может получить сообщение Paint. Вместо этого контейнер элементов управления напрямую вызывает `OnDraw` функцию элемента управления. Это отличается от процесса рисования активного элемента управления тем, что `OnPaint` функция-член никогда не вызывается.

Как обсуждалось в предыдущих абзацах, обновление элемента управления ActiveX зависит от состояния элемента управления. Однако, поскольку платформа вызывает функцию- `OnDraw` член в обоих случаях, вы добавляете большую часть кода рисования в эту функцию-член.

`OnDraw`Функция члена управляет рисованием элемента управления. Если элемент управления неактивен, контейнер элемента управления вызывает `OnDraw` , передавая контекст устройства контейнера элемента управления и координаты прямоугольной области, занимаемой элементом управления.

Прямоугольник, переданный платформой в `OnDraw` функцию члена, содержит область, занятую элементом управления. Если элемент управления активен, верхний левый угол равен (0, 0), а контекст устройства передается для дочернего окна, содержащего элемент управления. Если элемент управления неактивен, верхняя левая координата не обязательно (0, 0), а переданный контекст устройства — контейнер элемента управления, содержащего элемент управления.

> [!NOTE]
> Важно, чтобы изменения `OnDraw` не зависели от верхней левой точки прямоугольника равна (0, 0) и нарисованы только внутри прямоугольника, переданного в `OnDraw` . При рисовании за пределами области прямоугольника могут возникнуть непредвиденные результаты.

Реализация по умолчанию, предоставляемая мастером элементов управления MFC ActiveX в файле реализации элемента управления (. CPP), показанный ниже, закрашивает прямоугольник с помощью белой кисти и заполняет эллипс цветом текущего фона.

[!code-cpp[NVC_MFC_AxUI#1](codesnippet/cpp/mfc-activex-controls-painting-an-activex-control_1.cpp)]

> [!NOTE]
> При рисовании элемента управления не следует делать предположения о состоянии контекста устройства, переданного функции в качестве параметра *основного контроллера домена* `OnDraw` . Иногда контекст устройства предоставляется приложением-контейнером и не обязательно будет инициализирован в состояние по умолчанию. В частности, явно выберите перья, кисти, цвета, шрифты и другие ресурсы, от которых зависит код рисования.

## <a name="optimizing-your-paint-code"></a><a name="_core_optimizing_your_paint_code"></a>Оптимизация кода Paint

После успешного рисования элемента управления необходимо оптимизировать `OnDraw` функцию.

Реализация рисования элементов управления ActiveX по умолчанию закрашивает всю область элемента управления. Это достаточно для простых элементов управления, но во многих случаях перерисовка элемента управления будет выполняться быстрее, если только часть, которая нуждается в обновлении, была перерисована, а не весь элемент управления.

`OnDraw`Функция обеспечивает простой метод оптимизации путем передачи *рЦинвалид*, прямоугольной области элемента управления, для которой требуется перерисовка. Используйте эту область, как правило, меньше, чем вся область элемента управления, чтобы ускорить процесс рисования.

## <a name="painting-your-control-using-metafiles"></a><a name="_core_painting_your_control_using_metafiles"></a>Рисование элемента управления с помощью метафайлов

В большинстве случаев параметр *PDC* для `OnDraw` функции указывает на контекст устройства экрана (DC). Однако при печати изображений элемента управления или во время сеанса предварительного просмотра контроллер домена, полученный для подготовки к просмотру, является специальным типом, называемым "метафайл DC". В отличие от контроллера экрана, который немедленно обрабатывает отправленные им запросы, метафайл DC сохраняет запросы, которые будут воспроизводиться позже. Некоторые приложения-контейнеры также могут отображать образ элемента управления с помощью метафайла DC в режиме конструктора.

Запросы на Рисование метафайлов могут создаваться контейнером с помощью двух функций интерфейса: `IViewObject::Draw` (Эта функция также может вызываться для рисования не в метафайле) и `IDataObject::GetData` . Когда в качестве одного из параметров передается контроллер-метафайл, платформа MFC выполняет вызов [COleControl:: ондравметафиле](reference/colecontrol-class.md#ondrawmetafile). Так как это виртуальная функция-член, переопределите эту функцию в классе Control, чтобы выполнить какую-либо специальную обработку. Поведение по умолчанию вызывает `COleControl::OnDraw` .

Чтобы элемент управления можно было рисовать как в контекстах устройства, так и в метафайлах устройств, необходимо использовать только функции-члены, поддерживаемые как на экране, так и на контроллере домена метафайлов. Имейте в виду, что система координат может не измеряться в пикселях.

Поскольку реализация по умолчанию `OnDrawMetafile` вызывает функцию элемента управления `OnDraw` , используйте только функции-члены, которые подходят как для метафайла, так и для контекста устройства на экране, если только вы не переопределяете `OnDrawMetafile` . Ниже перечислены подмножество функций- `CDC` членов, которые можно использовать как в метафайле, так и в контексте устройства на экране. Дополнительные сведения об этих функциях см. в разделе класс [CDC](reference/cdc-class.md) в *справочнике по MFC*.

|Arc|бибблт|Хорда|
|---------|------------|-----------|
|`Ellipse`|`Escape`|`ExcludeClipRect`|
|`ExtTextOut`|`FloodFill`|`IntersectClipRect`|
|`LineTo`|`MoveTo`|`OffsetClipRgn`|
|`OffsetViewportOrg`|`OffsetWindowOrg`|`PatBlt`|
|`Pie`|`Polygon`|`Polyline`|
|`PolyPolygon`|`RealizePalette`|`RestoreDC`|
|`RoundRect`|`SaveDC`|`ScaleViewportExt`|
|`ScaleWindowExt`|`SelectClipRgn`|`SelectObject`|
|`SelectPalette`|`SetBkColor`|`SetBkMode`|
|`SetMapMode`|`SetMapperFlags`|`SetPixel`|
|`SetPolyFillMode`|`SetROP2`|`SetStretchBltMode`|
|`SetTextColor`|`SetTextJustification`|`SetViewportExt`|
|`SetViewportOrg`|`SetWindowExt`|`SetWindowORg`|
|`StretchBlt`|`TextOut`||

Помимо функций- `CDC` членов, существует несколько других функций, совместимых с контроллером-метафайлом. К ним относятся [кпалетте:: аниматепалетте](reference/cpalette-class.md#animatepalette), [Кфонт:: CreateFontIndirect](reference/cfont-class.md#createfontindirect)и три функции члена `CBrush` : [креатебрушиндирект](reference/cbrush-class.md#createbrushindirect), [креатедибпаттернбруш](reference/cbrush-class.md#createdibpatternbrush)и [креатепаттернбруш](reference/cbrush-class.md#createpatternbrush).

К функциям, которые не записываются в метафайл, относятся: [дравфокусрект](reference/cdc-class.md#drawfocusrect), [дравикон](reference/cdc-class.md#drawicon), [DrawText](reference/cdc-class.md#drawtext), [ексклудеупдатергн](reference/cdc-class.md#excludeupdatergn), [филлрект](reference/cdc-class.md#fillrect), [фрамерект](reference/cdc-class.md#framerect), [грайстринг](reference/cdc-class.md#graystring), [инвертрект](reference/cdc-class.md#invertrect), [скроллдк](reference/cdc-class.md#scrolldc)и [TabbedTextOut](reference/cdc-class.md#tabbedtextout). Так как метафайл DC на самом деле не связан с устройством, нельзя использовать Сетдибитс, Жетдибитс и Креатедибитмап с КОНТРОЛЛЕРом метафайла. В качестве места назначения можно использовать Сетдибитстодевице и Стретчдибитс с метафайлом DC. [Креатекомпатибледк](reference/cdc-class.md#createcompatibledc), [креатекомпатиблебитмап](reference/cbitmap-class.md#createcompatiblebitmap)и [КРЕАТЕДИСКАРДАБЛЕБИТМАП](reference/cbitmap-class.md#creatediscardablebitmap) не имеют смысла с контроллером метафайла.

Другой момент, который следует учесть при использовании метафайла DC, заключается в том, что система координат может не измеряться в пикселях. По этой причине весь код рисования должен быть настроен для размещения в прямоугольнике, переданном `OnDraw` в параметре *ркбаундс* . Это предотвращает случайное рисование вне элемента управления, так как *ркбаундс* представляет размер окна элемента управления.

После реализации отрисовки метафайлов для элемента управления используйте тестовый контейнер для тестирования метафайла. Сведения о том, как получить доступ к Контейнеру для тестирования, см. в разделе [Тестирование свойств и событий в Контейнере для тестирования](testing-properties-and-events-with-test-container.md) .

#### <a name="to-test-the-controls-metafile-using-test-container"></a>Тестирование метафайла элемента управления с помощью тестового контейнера

1. В меню **Правка** контейнера тестов выберите пункт **Вставить новый элемент управления**.

1. В поле **Вставить новый элемент управления** выберите элемент управления и нажмите кнопку **ОК**.

   Элемент управления появится в контейнере тестов.

1. В меню **Управление** выберите команду **Рисование метафайла**.

   Появится отдельное окно, в котором отображается метафайл. Вы можете изменить размер этого окна, чтобы увидеть, как масштабирование влияет на метафайл элемента управления. Это окно можно закрыть в любое время.

## <a name="see-also"></a>См. также раздел

[Элементы ActiveX библиотеки MFC](mfc-activex-controls.md)
