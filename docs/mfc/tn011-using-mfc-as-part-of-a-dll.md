---
title: 'TN011: Использование MFC как часть библиотеки DLL | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: conceptual
f1_keywords:
- vc.mfc.dll
dev_langs:
- C++
helpviewer_keywords:
- _USRDLL symbol
- USRDLLs, compiler switches
- TN011
- DLLs [MFC], linking
- MFC DLLs [MFC], linking regular MFC DLLs to MFC
ms.assetid: 76753e9c-59dc-40f6-b6a7-f6bb9a7c4190
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: bc30248fda9c179b22769230d5e09bf1da474d3b
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46435614"
---
# <a name="tn011-using-mfc-as-part-of-a-dll"></a>TN011. Использование MFC как часть библиотеки DLL

Эта заметка описывает постоянные библиотеки DLL MFC, что позволит вам использовать библиотеку MFC как часть библиотеки динамической компоновки (DLL) Windows. Предполагается, что вы знакомы с DLL Windows, а также способы их построения. Сведения о библиотеках DLL расширений MFC, с помощью которого можно создавать расширения для библиотеки MFC, см. в разделе [версии библиотеки DLL MFC](../mfc/tn033-dll-version-of-mfc.md).

## <a name="dll-interfaces"></a>Интерфейсы DLL

обычные библиотеки DLL MFC предполагается, указанные в C-подобных функций или явно экспортируемые классы интерфейсов между приложением и библиотеки DLL. Невозможно экспортировать интерфейсы классов MFC.

Если библиотека DLL и приложения требуется использовать MFC, обе имеют выбор на использование либо общего версии библиотек MFC или статическое связывание копию библиотеки. Приложения и библиотеки DLL могут используют одну из стандартных версий библиотеки MFC.

обычные библиотеки DLL MFC имеет несколько преимуществ:

- Приложение, которое использует библиотеку DLL, не нужно использовать MFC и не быть приложения Visual C++.

- С постоянные библиотеки DLL MFC, статической компоновке с MFC размер DLL зависит только от процедур среды выполнения MFC и C, используемых и связанной.

- С помощью постоянные библиотеки DLL MFC, динамически связываются с MFC экономия в оперативной памяти при использовании общей версии MFC могут быть значительными. Тем не менее, необходимо распространить общих библиотек DLL Mfc*\<версии >* DLL и Msvvcrt*\<версии >*.dll, библиотеки DLL.

- Проект библиотеки DLL не зависит от реализации классов. Проект библиотеки DLL экспортирует только к интерфейсам API, требуется. Таким образом при изменении реализации обычные библиотеки DLL MFC, остаются действительными.

- С помощью обычные библиотеки DLL MFC, статической компоновке с MFC Если библиотека DLL и приложения MFC, нет никаких проблем с приложением, которое требуется другая версия MFC DLL или наоборот. Поскольку библиотека MFC статически связана всех DLL или EXE, нет без сомнения, версия у вас есть.

## <a name="api-limitations"></a>Ограничения API

Некоторые функции MFC не применяется к версией библиотеки DLL, из-за технических ограничений или потому, что эти службы обычно предоставляются приложением. С помощью текущей версии MFC, является единственной функцией, не применяется `CWinApp::SetDialogBkColor`.

## <a name="building-your-dll"></a>Построение библиотеки DLL

При компиляции обычные библиотеки DLL MFC, статической компоновке с MFC, символы `_USRDLL` и `_WINDLL` должен быть определен. Код библиотеки DLL также должна быть скомпилирована с следующие параметры компилятора:

- **/ D_WINDLL** указывает на компиляцию для библиотеки DLL

- **/ D_USRDLL** указывает создании обычной библиотеки DLL MFC

Необходимо также определить эти символы и использовать эти параметры компилятора при компиляции обычные библиотеки DLL MFC, который динамически связан с MFC. Кроме того, символ `_AFXDLL` должны быть определены и код библиотеки DLL должна быть скомпилирована с:

- **/ D_AFXDLL** указывает, что вы создаете обычной библиотеки DLL MFC, динамически скомпонованную с MFC

Интерфейсы (API) между приложением и библиотеки DLL должны экспортироваться явным образом. Мы рекомендуем определить интерфейсы, чтобы быть низкой пропускной способностью и использовать только интерфейсы C, если это возможно. Прямой интерфейсы C легче поддерживать, чем более сложные классы C++.

Установите API-интерфейсов в отдельный заголовок, который может быть включено с файлами C и C++. См. в разделе заголовка ScreenCap.h в образце основные понятия Advanced MFC [DLLScreenCap](../visual-cpp-samples.md) пример. Чтобы экспортировать функции, введите их в `EXPORTS` разделе файла определения модуля (. DEF) или включить `__declspec(dllexport)` на определениях функций. Используйте `__declspec(dllimport)` для импорта этих функций в исполняемый файл клиента.

Необходимо добавить макрос AFX_MANAGE_STATE в начале все экспортированные функции в обычных библиотеках DLL MFC, который динамически связан с MFC. Этот макрос задает текущее состояние модуля одну библиотеку DLL. Чтобы использовать этот макрос, добавьте следующую строку кода в начале функции, экспортированные из библиотеки DLL:

`AFX_MANAGE_STATE(AfxGetStaticModuleState( ))`

## <a name="winmain---dllmain"></a>WinMain -> DllMain

Библиотека MFC определяет стандартный Win32 `DllMain` точка входа, которая инициализирует вашей [CWinApp](../mfc/reference/cwinapp-class.md) производного объекта, как показано типичное приложение MFC. Поместите все инициализации библиотеки DLL в [InitInstance](../mfc/reference/cwinapp-class.md#initinstance) метод, как показано типичное приложение MFC.

Обратите внимание, что [CWinApp::Run](../mfc/reference/cwinapp-class.md#run) механизм не применяется к библиотеке DLL, так как приложение, которому принадлежит основной конвейер сообщений. Если библиотека DLL отображает немодальные диалоговые окна или фрейма главного окна свои собственные, приложения цикла обработки сообщений необходимо вызвать подпрограмму массового экспорта библиотеки DLL, которая вызывает [CWinApp::PreTranslateMessage](../mfc/reference/cwinapp-class.md#pretranslatemessage).

Ознакомьтесь с примером DLLScreenCap для использования этой функции.

`DllMain` Функция, которая предоставляет MFC вызывает [CWinApp::ExitInstance](../mfc/reference/cwinapp-class.md#exitinstance) метод класса, который является производным от `CWinApp` перед выгрузкой библиотеки DLL.

## <a name="linking-your-dll"></a>Компоновка библиотеки DLL

Обычные библиотеки DLL MFC, статической компоновке с MFC необходимо связывать библиотеки DLL с Nafxcwd.lib или Nafxcw.lib и с версией среды выполнения C, с именем Libcmt.lib. Эти библиотеки — это предварительно созданные и могут быть установлены, указав их при запуске программы установки Visual C++.

## <a name="sample-code"></a>Пример кода

Ознакомьтесь с примером концепции Advanced MFC программировать DLLScreenCap полный пример. Далее приведены несколько интересных моментов по Обратите внимание, в этом примере.

- Флаги компилятора библиотеки DLL и приложение отличаются.

- Линии связи и. DEF-файлы для библиотеки DLL и для приложения отличаются.

- Приложение, которое использует библиотеку DLL не обязательно находиться в C++.

- Интерфейс между приложением и библиотеки DLL — это API, который можно использовать с C или C++ и экспортируется с DLLScreenCap.def.

В следующем примере показано API, который определен в обычной MFC DLL, статически скомпонованную с MFC. В этом примере объявление содержится в `extern "C" { }` блок для пользователей C++. Это имеет несколько преимуществ. Во-первых он упрощает использование ваших DLL API можно использовать отличном от C++ клиентскими приложениями. Во-вторых он сокращает издержки библиотеки DLL, поскольку искажение имени C++ не будет применяться к экспортируемое имя. Наконец, это упрощает добавление явным образом. DEF файла (для экспорта по порядковому номеру), не беспокоясь о искажением имени.

```
#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

struct TracerData
{
    BOOL bEnabled;
    UINT flags;
};

BOOL PromptTraceFlags(TracerData FAR* lpData);


#ifdef __cplusplus
}
#endif
```

Структуры, используемые API, не являющихся производными от классов MFC и определяются в заголовке API. Это уменьшает сложность интерфейс между приложения и библиотеки DLL и библиотеки DLL можно использовать C программами.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)

