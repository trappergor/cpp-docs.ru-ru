---
title: Избежание состязания за кучу | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
dev_langs:
- C++
helpviewer_keywords:
- heap contention
ms.assetid: 797129d7-5f8c-4b0e-8974-bb93217e9ab5
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: a4f01bdbbc14e09fe8f9823eed738556ee876376
ms.sourcegitcommit: 92dbc4b9bf82fda96da80846c9cfcdba524035af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/05/2018
ms.locfileid: "43762255"
---
# <a name="avoidance-of-heap-contention"></a>Избежание состязания за кучу

Диспетчеры строка по умолчанию, предоставляемые MFC и ATL являются простыми оболочками на основе глобальной кучи. Этот глобальный кучи является полностью поточно ориентированной, это означает, что несколько потоков можно выделить и освободить память из него одновременно, без повреждения кучи. Для обеспечения потокобезопасности, куча имеет для сериализации доступа к самому себе. Обычно это осуществляется с помощью критической секции или похожий механизм блокировки. Каждый раз, когда два пытаются одновременно получить доступ к куче, один поток блокируется до завершения другого потока запроса. Для многих приложений такая ситуация возникает редко, и механизм блокировки кучи влияние на производительность незначительно. Тем не менее для приложений, которые часто обращаются к куче из нескольких потоков конкуренции за блокировки кучи может привести к приложению выполняться медленнее, чем если бы это был один поток (даже на компьютерах с несколькими процессорами).

Приложения, использующие [CStringT](../atl-mfc-shared/reference/cstringt-class.md) особенно восприимчивы к конкуренции кучи так как операции с `CStringT` объектов часто требуется перераспределение буфера строки.

Один из способов смягчению конфликтов кучи между потоками является Пусть каждый поток выделить строки из кучи частного, локальную для потока. До тех пор, пока выделены строки с помощью определенного потока распределителя используются только в этом потоке, распределитель не обязательно должны быть поточно ориентированными.

## <a name="example"></a>Пример

В приведенном ниже примере показана процедура потока, который выделяет свой собственный закрытый кучи не являющихся потокобезопасными, следует использовать для строк в этом потоке:

[!code-cpp[NVC_ATLMFC_Utilities#182](../atl-mfc-shared/codesnippet/cpp/avoidance-of-heap-contention_1.cpp)]

## <a name="comments"></a>Комментарии

Несколько потоков могут выполняться с помощью этой же процедуре потока, но так как каждый поток имеет свою собственную кучу нет конкуренции между потоками нет. Кроме того тот факт, что каждой кучи не является поточно ориентированной дает измеримое увеличение производительности, даже если выполняется только одна копия потока. Это результат кучи, не используете ресурсоемкие Блокируемые операции для защиты от одновременного доступа.

Для более сложных процедуру потока то может оказаться удобнее для хранения указателя для диспетчера потока строк в слоте (TLS) с локального хранилища потока. Благодаря этому других функциях, вызванных процедуре потока для доступа к диспетчеру строка потока.

## <a name="see-also"></a>См. также

[Управление памятью с помощью CStringT](../atl-mfc-shared/memory-management-with-cstringt.md)

