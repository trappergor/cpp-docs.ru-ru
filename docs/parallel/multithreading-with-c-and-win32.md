---
title: Реализация многопоточности на языке C с помощью функций Win32
ms.date: 08/09/2019
helpviewer_keywords:
- Windows API [C++], multithreading
- multithreading [C++], C and Win32
- Visual C, multithreading
- Win32 applications [C++], multithreading
- threading [C++], C and Win32
- Win32 [C++], multithreading
- threading [C]
ms.assetid: 67cdc99e-1ad9-452b-a042-ed246b70040e
ms.openlocfilehash: 1764561e0b2b43b8a89d8a1eb2e85d84ce33c4fc
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78867057"
---
# <a name="multithreading-with-c-and-win32"></a>Реализация многопоточности на языке C с помощью функций Win32

Microsoft C/C++ COMPILER (компилятором MSVC) обеспечивает поддержку создания многопоточных приложений. Рекомендуется использовать более одного потока, если приложению требуется выполнять ресурсоемкие операции, которые приведут к невозможности реагирования пользовательского интерфейса.

С помощью КОМПИЛЯТОРОМ MSVC существует несколько способов программирования с несколькими потоками: можно использовать C++/WinRT и библиотеку среда выполнения Windows, библиотеку Microsoft Foundation Class (MFC), C++/CLI и среду выполнения .NET, а также библиотеку времени выполнения C и API Win32. Эта статья посвящена многопоточности в C. Пример кода см. [в разделе Пример многопоточной программы на языке C](sample-multithread-c-program.md).

## <a name="multithread-programs"></a>Многопоточные программы

Поток по сути является путем выполнения программы. Это также самая маленькая единица выполнения, которую планирует Win32. Поток состоит из стека, состояния регистров ЦП и записи в списке выполнения планировщика системы. Каждый поток использует все ресурсы процесса.

Процесс состоит из одного или нескольких потоков, а также кода, данных и других ресурсов программы в памяти. Типичными ресурсами программы являются открытые файлы, семафоры и динамически выделяемая память. Программа выполняется, когда планировщик системы предоставляет один из своих потоков управления выполнением. Планировщик определяет, какие потоки должны выполняться и когда они должны выполняться. Потоки с более низким приоритетом могут ожидать, пока потоки с более высоким приоритетом завершат свои задачи. На многопроцессорных компьютерах планировщик может перемещать отдельные потоки на разные процессоры для балансировки нагрузки ЦП.

Каждый поток процесса работает независимо друг от друга. Если вы не сделаете их видимыми, потоки выполняются по отдельности и не знают о других потоках в процессе. Однако потоки, совместно использующие общие ресурсы, должны координировать свою работу с помощью семафоров или другого метода межпроцессного взаимодействия. Дополнительные сведения о синхронизации потоков см. в разделе [Написание многопоточной программы Win32](#writing-a-multithreaded-win32-program).

## <a name="library-support-for-multithreading"></a>Поддержка многопоточности библиотеками

Все версии CRT теперь поддерживают многопоточность, за исключением неблокирующих версий некоторых функций. Дополнительные сведения см. в разделе [производительность многопоточных библиотек](../c-runtime-library/multithreaded-libraries-performance.md). Сведения о версиях CRT, которые можно связать с кодом, см. в разделе [функции библиотеки CRT](../c-runtime-library/crt-library-features.md).

## <a name="include-files-for-multithreading"></a>Включаемые файлы для многопоточности

В стандартные CRT include files объявляются функции библиотеки времени выполнения C, как они реализуются в библиотеках. Если параметры компилятора задают [__fastcall или __vectorcall](../build/reference/gd-gr-gv-gz-calling-convention.md) соглашений о вызовах, компилятор предполагает, что все функции должны вызываться с помощью соглашения о вызове Register. Функции библиотеки времени выполнения используют соглашение о вызовах C, а объявления в стандартных включаемых файлах указывают компилятору на необходимость создания правильных внешних ссылок на эти функции.

## <a name="crt-functions-for-thread-control"></a>Функции CRT для управления потоками

Все программы Win32 имеют по крайней мере один поток. Любой поток может создавать дополнительные потоки. Поток может выполнять свою работу быстро, а затем прерываться или оставаться активным в течение всего жизненного цикла программы.

Библиотеки CRT предоставляют следующие функции для создания и завершения потоков: [_beginthread, _beginthreadex](../c-runtime-library/reference/beginthread-beginthreadex.md), [_endthread и _endthreadex](../c-runtime-library/reference/endthread-endthreadex.md).

Функции `_beginthread` и `_beginthreadex` создают новый поток и возвращают идентификатор потока, если операция выполнена успешно. Поток завершается автоматически при завершении выполнения. Или может завершиться с помощью вызова `_endthread` или `_endthreadex`.

> [!NOTE]
> При вызове подпрограмм среды выполнения C из программы, созданной с помощью LIBCMT. lib, необходимо запустить потоки с помощью функции `_beginthread` или `_beginthreadex`. Не используйте функции Win32 `ExitThread` и `CreateThread`. Использование `SuspendThread` может привести к взаимоблокировке, когда более чем один поток блокируется, ожидая, когда приостановленный поток завершит доступ к структуре данных времени выполнения C.

### <a name="_core_the__beginthread_function"></a>Функции _beginthread и _beginthreadex

Функции `_beginthread` и `_beginthreadex` создают новый поток. Поток использует код и сегменты данных процесса с другими потоками в процессе, но имеет собственные уникальные значения регистра, пространство стека и адрес текущей инструкции. Система предоставляет время ЦП каждому потоку, чтобы все потоки в процессе могли выполняться параллельно.

`_beginthread` и `_beginthreadex` похожи на функцию [CreateThread](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) в API Win32, но имеют следующие отличия:

- Они инициализируют определенные переменные библиотеки времени выполнения языка C. Это важно только в том случае, если вы используете библиотеку времени выполнения C в своих потоках.

- `CreateThread` обеспечивает контроль над атрибутами безопасности. Эту функцию можно использовать для запуска потока в приостановленном состоянии.

`_beginthread` и `_beginthreadex` возвращают маркер в новый поток, если он был успешным, или код ошибки, если произошла ошибка.

### <a name="_core_the__endthread_function"></a>Функции _endthread и _endthreadex

Функция [_endthread](../c-runtime-library/reference/endthread-endthreadex.md) завершает поток, созданный `_beginthread` (и аналогичным образом `_endthreadex` завершает поток, созданный `_beginthreadex`). Потоки завершаются автоматически по завершении. `_endthread` и `_endthreadex` полезны для условного завершения в рамках потока. Например, поток, предназначенный для обработки связи, может завершить работу, если не удается получить управление портом связи.

## <a name="writing-a-multithreaded-win32-program"></a>Написание многопоточной программы Win32

При написании программы с несколькими потоками необходимо координировать их поведение и [использование ресурсов программы](#_core_sharing_common_resources_between_threads). Кроме того, убедитесь, что каждый поток получает [собственный стек](#_core_thread_stacks).

### <a name="_core_sharing_common_resources_between_threads"></a>Совместное использование общих ресурсов между потоками

> [!NOTE]
> Аналогичное обсуждение точки зрения MFC см. в разделе [многопоточность. Советы по программированию](multithreading-programming-tips.md) и [многопоточность: когда следует использовать классы синхронизации](multithreading-when-to-use-the-synchronization-classes.md).

Каждый поток имеет собственный стек и его собственную копию регистров ЦП. Другие ресурсы, такие как файлы, статические данные и память кучи, совместно используются всеми потоками в процессе. Потоки, использующие эти общие ресурсы, должны быть синхронизированы. Win32 предоставляет несколько способов синхронизации ресурсов, включая семафоры, критические разделы, события и мьютексы.

Если несколько потоков обращаются к статическим данным, программа должна предоставить доступ к возможным конфликтам ресурсов. Рассмотрим программу, в которой один поток обновляет статическую структуру данных, содержащую координаты *x*,*y* для элементов, отображаемых другим потоком. Если поток обновления изменяет координату *x* и загружается до того, как он может изменить координату *y* , то поток вывода может быть запланирован до обновления координаты *y* . Элемент отображается в неправильном месте. Эту проблему можно избежать, используя семафоры для управления доступом к структуре.

Мьютекс (короткий для *Мут*ual *ex*клусион) — это способ обмена данными между потоками или процессами, выполняющими асинхронное взаимодействие друг с другом. Это взаимодействие можно использовать для координации действий нескольких потоков или процессов, обычно путем управления доступом к общему ресурсу путем блокировки и разблокировки ресурса. Чтобы решить эту проблему обновления координат *x*,*y* , поток обновления устанавливает мьютекс, указывающий, что структура данных используется до выполнения обновления. Он очистит мьютекс после обработки обеих координат. Прежде чем обновить отображение, поток вывода должен дождаться очистки мьютекса. Этот процесс ожидания мьютекса часто называется *блокировкой* мьютекса, поскольку процесс блокируется и не может продолжаться до тех пор, пока мьютекс не будет очищен.

Программа Bounce. c, показанная в [примере многопоточной программы на языке c](sample-multithread-c-program.md) , использует мьютекс с именем `ScreenMutex` для координации обновлений экрана. Каждый раз, когда один из потоков отображения готов к записи на экран, он вызывает `WaitForSingleObject` с маркером для `ScreenMutex` и постоянного бесконечности, чтобы указать, что вызов `WaitForSingleObject` должен блокироваться на мьютексе, а не истечение времени ожидания. Если `ScreenMutex` ясно, функция Wait устанавливает мьютекс так, чтобы другие потоки не могли повлиять на отображение и продолжали выполнение потока. В противном случае поток блокируется до тех пор, пока мьютекс не очистится. Когда поток завершает обновление дисплея, он освобождает мьютекс, вызывая `ReleaseMutex`.

На экране отображаются и статические данные — только два из ресурсов, которые требуют тщательного управления. Например, программа может иметь несколько потоков, обращающихся к одному и тому же файлу. Поскольку другой поток мог переместить указатель файла, каждый поток должен сбросить указатель на файл перед чтением или записью. Кроме того, каждый поток должен убедиться, что он не был вытеснен между моментом, когда он помещает указатель, и временем, когда он обращается к файлу. Эти потоки должны использовать семафор для координирования доступа к файлу с помощью квадратных скобок для доступа к файлам с помощью `WaitForSingleObject` и `ReleaseMutex`ных вызовов. Этот метод показан в следующем примере кода:

```C
HANDLE    hIOMutex = CreateMutex (NULL, FALSE, NULL);

WaitForSingleObject( hIOMutex, INFINITE );
fseek( fp, desired_position, 0L );
fwrite( data, sizeof( data ), 1, fp );
ReleaseMutex( hIOMutex);
```

### <a name="_core_thread_stacks"></a>Стеки потоков

Все пространство стека приложения по умолчанию выделяется первому потоку выполнения, который называется потоком 1. В результате необходимо указать объем памяти, выделяемый для отдельного стека для каждого дополнительного потока, необходимого программе. Операционная система выделяет дополнительное пространство стека для потока, если это необходимо, но необходимо указать значение по умолчанию.

Первый аргумент в `_beginthread` вызове является указателем на функцию `BounceProc`, которая выполняет потоки. Второй аргумент задает размер стека по умолчанию для потока. Последний аргумент — это ИДЕНТИФИКАЦИОНный номер, который передается в `BounceProc`. `BounceProc` использует ИДЕНТИФИКАЦИОНный номер для заполнения генератора случайных чисел, а также для выбора атрибута цвета потока и отображаемого символа.

Потоки, которые выполняют вызовы к библиотеке времени выполнения C или API Win32, должны разрешать достаточное пространство стека для библиотеки и функций API, которые они вызывают. Функция C `printf` требует более 500 байт пространства стека, и при вызове подпрограмм Win32 API должен быть доступен 2 КБ памяти стека.

Поскольку каждый поток имеет собственный стек, можно избежать потенциальных конфликтов между элементами данных, используя как можно меньше статических данных. Разработайте программу для использования автоматических переменных стека для всех данных, которые могут быть частными для потока. Единственными глобальными переменными в программе Bounce. c являются мьютексы или переменные, которые никогда не изменяются после инициализации.

Win32 также предоставляет локальное хранилище потока (TLS) для хранения данных для каждого потока. Дополнительные сведения см. в статье [локальная память потока (TLS)](thread-local-storage-tls.md).

## <a name="avoiding-problem-areas-with-multithread-programs"></a>Устранение потенциальных проблем при работе с многопоточными программами

Существует несколько проблем, которые могут возникнуть при создании, компоновке или исполнении многопоточной программы на языке C. Некоторые из наиболее распространенных проблем описаны в следующей таблице. (Для подобного обсуждения точки зрения MFC см. раздел [многопоточность. Советы по программированию](multithreading-programming-tips.md).)

|Проблема|Возможные причины|
|-------------|--------------------|
|Появится окно сообщения, в котором программа привела к нарушению защиты.|Многие ошибки программирования Win32 приводят к нарушениям защиты. Распространенной причиной нарушений защиты является неявное назначение данных пустым указателям. Так как в результате программа пытается получить доступ к памяти, которая не принадлежит ей, выдается нарушение защиты.<br /><br /> Простой способ обнаружить причину нарушения защиты заключается в компиляции программы с отладочной информацией, а затем запускать ее с помощью отладчика в среде Visual Studio. Когда происходит сбой защиты, Windows передает управление отладчику, и курсор размещается на строке, вызвавшей проблему.|
|Программа создает многочисленные ошибки компиляции и компоновки.|Многие потенциальные проблемы можно устранить, установив уровень предупреждений компилятора равным одному из его самых высоких значений и изменяя предупреждающие сообщения. С помощью параметров уровня предупреждений уровень 3 или 4 можно обнаружить непреднамеренное преобразование данных, отсутствующие прототипы функций и использовать функции, отличные от ANSI.|

## <a name="see-also"></a>См. также раздел

[Поддержка многопоточности для старого кода (Visual C++)](multithreading-support-for-older-code-visual-cpp.md)\
[Пример многопоточной программы на языке C](sample-multithread-c-program.md)\
\ [локального хранилища потоков (TLS)](thread-local-storage-tls.md)
[Параллельные и асинхронные операции C++с/WinRT](/windows/uwp/cpp-and-winrt-apis/concurrency)\
[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
