---
title: 'Многопоточность: Использование классов синхронизации | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- threading [MFC], synchronization classes
- resources [C++], multithreading
- synchronization classes [C++]
- synchronization [C++], multithreading
- controlled resource access [C++]
- synchronization access classes [C++]
- threading [C++], synchronization
- multithreading [C++], synchronization classes
ms.assetid: 4914f54e-68ac-438f-93c9-c013455a657e
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: b3556bace6c578edec8eaedffb528d21cb1644f5
ms.sourcegitcommit: 6f8dd98de57bb80bf4c9852abafef1c35a7600f1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2018
ms.locfileid: "42606068"
---
# <a name="multithreading-when-to-use-the-synchronization-classes"></a>Многопоточность. Использование классов синхронизации
Многопоточные классы, предоставляемые MFC делятся на две категории: объекты синхронизации ([CSyncObject](../mfc/reference/csyncobject-class.md), [CSemaphore](../mfc/reference/csemaphore-class.md), [CMutex](../mfc/reference/cmutex-class.md), [ CCriticalSection](../mfc/reference/ccriticalsection-class.md), и [CEvent](../mfc/reference/cevent-class.md)) и синхронизации доступ к объектам ([CMultiLock](../mfc/reference/cmultilock-class.md) и [CSingleLock](../mfc/reference/csinglelock-class.md)).  
  
Классы синхронизации используются в том случае, когда необходимо контролировать доступ к ресурсу для обеспечения целостности ресурса. Классы синхронного доступа используются для получения доступа к этим ресурсам управляемой. В этом разделе приводится описание использования каждого класса.  
  
Чтобы определить, какой класс синхронизации, следует использовать, ответьте на следующие вопросы:  
  
1. Приложение нужно ждать, что-то произошло. Прежде чем он может получить доступ к ресурсу (например, данные должны быть получены из COM-портом перед его записью в файл)?  
  
     Если Да, используйте `CEvent`.  
  
2. Можно более одного потока в те же права доступа приложения этого ресурса за один раз (например, приложение позволяет windows до 5 с представлениями в том же документе)?  
  
     Если Да, используйте `CSemaphore`.  
  
3. Более одного приложения можно использовать этот ресурс (например, ресурс находится в библиотеке DLL)?  
  
     Если Да, используйте `CMutex`.  
  
     Если нет, используйте `CCriticalSection`.  
  
`CSyncObject` никогда не используется напрямую. Это базовый класс для других четырех классов синхронизации.  
  
## <a name="example-1-using-three-synchronization-classes"></a>Пример 1: Использование трех классов синхронизации  
 
Например рассмотрим приложение, поддерживающее связанный список учетных записей. Это приложение позволяет до трех учетных записей в отдельных окнах, но можно обновить в любой момент времени только один. При обновлении учетной записи, обновленные данные отправляются по сети в архив данных.  
  
В этом примере приложения используются все три типа классов синхронизации. Так как она допускает до трех учетных записей за один раз, он использует `CSemaphore` для ограничения доступа к трем объектам просмотра. При попытке просмотра четвертой учетной записи приложение находится в ожидании одной из первых трех windows закрывает или завершается с ошибкой. При обновлении учетной записи, приложение использует `CCriticalSection` чтобы убедиться, что только одна учетная запись обновляется одновременно. После успешного обновления, он сообщает о `CEvent`, который освобождает поток ожидает события. Этот поток отправляет новые данные в архив данных.  
  
## <a name="example-2-using-synchronization-access-classes"></a>Пример 2: Использование классов синхронизации доступа к  
 
Выбор используемого класса доступа синхронизации использовать еще проще. Если приложение отвечает за доступ к только один управляемый ресурс, используйте `CSingleLock`. Если ему требуется доступ к одному из нескольких управляемых ресурсов, используйте `CMultiLock`. В примере 1 `CSingleLock` будет использоваться, так как в каждом конкретном случае требуется только один ресурс в любой момент времени.  
  
Сведения об использовании классов синхронизации, см. в разделе [Многопоточность: Практическое использование классов синхронизации](../parallel/multithreading-how-to-use-the-synchronization-classes.md). Сведения о синхронизации см. в разделе [синхронизации](http://msdn.microsoft.com/library/windows/desktop/ms686353) в пакете Windows SDK. Сведения о поддержке многопоточности в MFC, см. в разделе [многопоточность с помощью C++ и MFC](../parallel/multithreading-with-cpp-and-mfc.md).  
  
## <a name="see-also"></a>См. также  
 
[Реализация многопоточности на языке C++ с помощью классов MFC](../parallel/multithreading-with-cpp-and-mfc.md)