---
title: 'Многопоточность: Советы по программированию MFC | Документация Майкрософт'
ms.custom: ''
ms.date: 08/27/2018
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- multithreading [C++], programming tips
- handle maps [C++]
- access control [C++], multithreading
- objects [C++], multiple threads and
- non-MFC threads [C++]
- threading [MFC], programming tips
- critical sections [C++]
- synchronization [C++], multithreading
- programming [C++], multithreaded
- communications [C++], between threads
- threading [C++], best practices
- troubleshooting [C++], multithreading
- Windows handle maps [C++]
ms.assetid: ad14cc70-c91c-4c24-942f-13a75e58bf8a
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 28446576fefe52dfaa99b69ae410a87424e28e3b
ms.sourcegitcommit: f7703076b850c717c33d72fb0755fbb2215c5ddc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/28/2018
ms.locfileid: "43132042"
---
# <a name="multithreading-mfc-programming-tips"></a>Многопоточность: Советы по программированию MFC
Многопоточные приложения требуют больше внимания, чем однопоточные приложения, чтобы убедиться, что операции выполняются в последовательности и любые данные, к которому обращаются несколько потоков не поврежден. В этом разделе описаны способы предотвращения потенциальных проблем, при программировании многопоточных приложений с помощью библиотеки Microsoft Foundation Class (MFC).  
  
- [Доступ к объектам из нескольких потоков](#_core_accessing_objects_from_multiple_threads)  
  
- [Доступ к объектам MFC из потоков не являющихся MFC](#_core_accessing_mfc_objects_from_non.2d.mfc_threads)  
  
- [Дескриптор карты Windows](#_core_windows_handle_maps)  
  
- [Взаимодействие между потоками](#_core_communicating_between_threads)  
  
##  <a name="_core_accessing_objects_from_multiple_threads"></a> Доступ к объектам из нескольких потоков  
 
MFC-объекты не являются поточно ориентированными сами по себе. Два отдельных потока не может управлять тот же объект, если вы не используете классов MFC синхронизации и/или соответствующих объектов синхронизации Win32, таких как критические секции. Дополнительные сведения о критических секциях и других связанных объектов, см. в разделе [синхронизации](/windows/desktop/Sync/synchronization) в пакете Windows SDK.  
  
Библиотека классов использует критические секции для защиты глобальные структуры данных, таких как выделение памяти отладки.  
  
##  <a name="_core_accessing_mfc_objects_from_non.2d.mfc_threads"></a> Доступ к объектам MFC из потоков не являющихся MFC  
 
Если у вас есть многопоточного приложения, которое создает поток не с помощью с [CWinThread](../mfc/reference/cwinthread-class.md) объекта, воспользоваться другими объектами MFC из этого потока. Другими словами, если вы хотите получить доступ к любому объекту MFC из второго потока, необходимо создать этот поток с одним из методов, описанных в [Многопоточность: создание потоков пользовательского интерфейса](multithreading-creating-user-interface-threads.md) или [Многопоточность: Создание рабочих потоков](multithreading-creating-worker-threads.md). Эти методы являются единственными, позволяющие библиотеке классов для инициализации внутренних переменных, необходимых для многопоточных приложений.  
  
##  <a name="_core_windows_handle_maps"></a> Дескриптор карты Windows  
 
Как правило поток может получить доступ к только объектов MFC, созданные им. Это обусловлено временных и постоянных maps дескриптор Windows, хранятся в локальном хранилище потока в целях обеспечения защиты от одновременного доступа нескольких потоков. Например, рабочий поток не производят вычисление и затем вызвать документа `UpdateAllViews` функцию-член для окон, которые содержат новые измененные данные. Это не влияет, так как сопоставление от `CWnd` объектов HWND является локальным для основного потока. Это означает, что один поток может иметь сопоставление из дескриптора Windows для объекта C++, но другой поток может сопоставить тот же дескриптор другому объекту C++. Изменения, внесенные в одном потоке не будут отражаться в другом.  
  
Существует несколько способов решения проблемы. Первый — для передачи отдельных дескрипторов (HWND) вместо того, чтобы объекты C++ на рабочий поток. Рабочий поток затем добавит эти объекты во временное сопоставление, вызывая соответствующий `FromHandle` функция-член. Можно также добавить объект постоянное сопоставление потока путем вызова `Attach`, но это следует делать только в том случае, если гарантируется, что объект будет существовать дольше, чем поток.  
  
Другой метод заключается в создании новых определяемых пользователем сообщений, соответствующих различным задачам рабочих потоков будет и помещают эти сообщения в главное окно приложения с помощью `::PostMessage`. Данный метод взаимодействия аналогична два разных приложения, обменивающиеся данными, за исключением того, что оба потока выполняются в том же адресном пространстве.  
  
Дополнительные сведения о сопоставлении дескрипторов см. в разделе [технические Примечание 3](../mfc/tn003-mapping-of-windows-handles-to-objects.md). Дополнительные сведения о локальной памяти потока, см. в разделе [локальное хранилище потока](/windows/desktop/ProcThread/thread-local-storage) и [с помощью локального хранилища потока](/windows/desktop/ProcThread/using-thread-local-storage) в пакете Windows SDK.  
  
##  <a name="_core_communicating_between_threads"></a> Взаимодействие между потоками  
 
MFC предоставляет ряд классов, которые позволяют потокам синхронизировать доступ к объектам, для обеспечения безопасности потока. Описывается использование этих классов в [Многопоточность: Практическое использование классов синхронизации](multithreading-how-to-use-the-synchronization-classes.md) и [Многопоточность: использование классов синхронизации](multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения об этих объектах см. в разделе [синхронизации](/windows/desktop/Sync/synchronization) в пакете Windows SDK.  
  
## <a name="see-also"></a>См. также  

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)