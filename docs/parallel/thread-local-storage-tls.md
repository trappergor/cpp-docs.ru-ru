---
title: Локальное хранилище потока (TLS)
ms.date: 08/09/2019
helpviewer_keywords:
- multithreading [C++], Thread Local Storage
- TLS [C++]
- threading [C++], Thread Local Storage
- storing thread-specific data
- thread attribute
- Thread Local Storage [C++]
ms.assetid: 80801907-d792-45ca-b776-df0cf2e9f197
ms.openlocfilehash: 888a33161cd33b20d5f40a07f9b54235f06b8bd8
ms.sourcegitcommit: 57e26bdd7839fce3c4154a61e987d165f0ba6f5b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/02/2020
ms.locfileid: "84301970"
---
# <a name="thread-local-storage-tls"></a>Локальное хранилище потока (TLS)

Локальное хранилище потока (TLS) — это механизм, с помощью которого каждый поток в указанном многопоточном процессе может выделять расположения для хранения данных определенного потока. Динамически связанные данные потока (среды выполнения) поддерживаются API TLS ([TlsAlloc](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsalloc)). В дополнение к существующей реализации API в Win32 и компиляторе Microsoft C++ теперь поддерживаются статически связанные данные (время загрузки) для каждого потока.

## <a name="compiler-implementation-for-tls"></a><a name="_core_compiler_implementation_for_tls"></a>Реализация компилятора для TLS

**C++ 11:**  `thread_local`Описатель класса хранения — это рекомендуемый способ указания локального хранилища потока для объектов и членов класса. Дополнительные сведения см. в разделе [классы хранения данных (C++)](../cpp/storage-classes-cpp.md).

КОМПИЛЯТОРОМ MSVC также предоставляет атрибут, [поток](../cpp/thread.md), зависящий от Майкрософт, как модификатор расширенного класса хранения. Объявите переменную **потока** с помощью ключевого слова **__declspec** . В следующем примере кода показано, как объявлять целочисленную локальную переменную потока и инициализировать её некоторым значением:

```C
__declspec( thread ) int tls_i = 1;
```

## <a name="rules-and-limitations"></a>Правила и ограничения

При объявлении статистически связываемых локальных объектов и переменных потока необходимо соблюдать следующие рекомендации. Эти рекомендации применяются как к [потокам](../cpp/thread.md) , так и к [thread_local](../cpp/storage-classes-cpp.md):

- Атрибут **Thread** может применяться только к объявлениям и определениям классов и данных. Его нельзя использовать в объявлениях или определениях функций. Например, следующий код вызовет ошибку компиляции:

    ```C
    __declspec( thread )void func();     // This will generate an error.
    ```

- Модификатор **потока** может быть указан только для элементов данных со **статическим** экстентом. В том числе глобальные объекты данных ( **статические** и **Внешние**), локальные статические объекты и статические элементы данных классов C++. Автоматические объекты данных нельзя объявлять с помощью атрибута **Thread** . Следующий код вызывает ошибки компилятора:

    ```C
    void func1()
    {
        __declspec( thread )int tls_i;            // This will generate an error.
    }

    int func2(__declspec( thread )int tls_i )     // This will generate an error.
    {
        return tls_i;
    }
    ```

- Объявления и определение локального объекта потока должны указывать атрибут **Thread** . Например, следующий код вызывает ошибку:

    ```C
    #define Thread  __declspec( thread )
    extern int tls_i;        // This will generate an error, since the
    int __declspec( thread )tls_i;        // declaration and definition differ.
    ```

- Атрибут **Thread** нельзя использовать в качестве модификатора типа. Например, следующий код вызовет ошибку компиляции:

    ```C
    char __declspec( thread ) *ch;        // Error
    ```

- Так как объявление объектов C++, использующих атрибут **Thread** , разрешено, два следующих примера семантически эквивалентны:

    ```cpp
    __declspec( thread ) class B
    {
    // Code
    } BObject;  // OK--BObject is declared thread local.

    class B
    {
    // Code
    };
    __declspec( thread ) B BObject;  // OK--BObject is declared thread local.
    ```

- Адрес локального объекта потока не считается константой, а любое выражение, включающее такой адрес, не считается константным выражением. В стандартной версии C результатом является запрет использования адреса локальной переменной потока в качестве инициализатора для объекта или указателя. Например, компилятор C отмечает следующий код как ошибочный:

    ```C
    __declspec( thread ) int tls_i;
    int *p = &tls_i;       //This will generate an error in C.
    ```

   Это ограничение не распространяется на C++. Так как C++ допускает динамическую инициализацию всех объектов, можно инициализировать объект с помощью выражения, которое использует адрес локальной переменной потока. Это делается так же, как и создание локальных объектов потока. Например, приведенный ранее код не создает ошибку при компиляции в виде исходного файла C++. Адрес локальной переменной потока допустим только при условии, что поток, в котором был сделан адрес, все еще существует.

- Стандартный C позволяет инициализировать объект или переменную с выражением, которое включает ссылку на себя, но только для объектов нестатической области. Хотя C++ обычно поддерживает такую динамическую инициализацию объектов с помощью выражения, которое включает ссылку на себя, такой тип инициализации не разрешен с локальными объектами потока. Пример:

    ```C
    __declspec( thread )int tls_i = tls_i;                // Error in C and C++
    int j = j;                               // OK in C++, error in C
    __declspec( thread )int tls_i = sizeof( tls_i )       // Legal in C and C++
    ```

   `sizeof`Выражение, включающее инициализируемый объект, не представляет ссылку на себя и включено в C и C++.

   C++ не допускает подобную динамическую инициализацию данных потока, так как в будущем это может привести к последующим улучшениям в механизме локального хранения потока.

- В операционных системах Windows до Windows Vista `__declspec( thread )` есть некоторые ограничения. Если библиотека DLL объявляет любые данные или объект как `__declspec( thread )` , это может привести к сбою защиты при динамической загрузке. После загрузки библиотеки DLL с помощью [LoadLibrary](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw)происходит сбой системы, когда код ссылается на `__declspec( thread )` данные. Поскольку пространство глобальных переменных для потока выделяется во время выполнения, размер данного пространства основан на расчете требований приложению, а также требований всех библиотек DLL, которые привязываются статически. При использовании нельзя `LoadLibrary` расширить это пространство, чтобы разрешить использование локальных переменных потока, объявленных с помощью `__declspec( thread )` . Используйте API-интерфейсы TLS, такие как [TlsAlloc](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsalloc), в библиотеке DLL, чтобы выделить TLS, если библиотека DLL может быть загружена с помощью `LoadLibrary` .

## <a name="see-also"></a>См. также раздел

[Реализация многопоточности на языке C с помощью функций Win32](multithreading-with-c-and-win32.md)
