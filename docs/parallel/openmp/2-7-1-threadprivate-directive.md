---
title: 2.7.1 директива threadprivate | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 08e0b70f-5359-4607-b0ca-38c2d570d7b3
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 31c9c70940b558d0b4cc3f77677665235417694d
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46398148"
---
# <a name="271-threadprivate-directive"></a>2.7.1 Директива threadprivate

`threadprivate` Директива делает именованные области видимости файла, область пространства имен то есть статические области видимости блока переменные, указанные в *списка переменной* частной для потока. *переменная list* является разделенный запятыми список переменных, у которых нет неполный тип. Синтаксис `threadprivate` директива выглядит следующим образом:

```
#pragma omp threadprivate(variable-list) new-line
```

Каждая копия `threadprivate` переменная инициализируется один раз, в неизвестной точке в программе перед первым обращением к этой копии и обычным способом (т. е. как мастер-копии будет инициализироваться в последовательное выполнение программы). Обратите внимание, что если в инициализатор явные ссылки на объект `threadprivate` переменной и значения объекта изменяется перед первым обращением к копия переменной, то поведение не определено.

Как с любой частную переменную, поток не должна ссылаться на другой поток копию `threadprivate` объекта. Во время последовательной и master областями программы ссылки будут для главного потока копию объекта.

После выполнения первого параллельной области данных в `threadprivate` объектов гарантированно сохраняются, только если динамического потока механизм была отключена, и если количество потоков остается неизменным для всех параллельных регионов.

Ограничения, которые необходимо `threadprivate` директива таковы:

- Объект `threadprivate` директива для переменных области видимости файла или области видимости пространства имен должна находиться за пределами любое определение или объявление, а также должно лексически предшествовать все ссылки на все переменные в списке.

- Каждая переменная в *списка переменной* из `threadprivate` директивы в области видимости файла или пространства имен должны ссылаться на объявление переменной на уровне файлов или пространств имен, лексически предшествующей директиве.

- Объект `threadprivate` директива для переменных статические области видимости блока должны располагаться в области этой переменной, а не во вложенной области. Директива должно лексически предшествовать все ссылки на все переменные в списке.

- Каждая переменная в *списка переменной* из `threadprivate` директивы в области видимости блока должны ссылаться на объявление переменной в той же области, лексически предшествующей директиве. Объявление переменной необходимо использовать описатель статических классов хранения.

- Если переменная задается в `threadprivate` директивы в одной записи преобразования, он должен быть указан в `threadprivate` директив в каждую запись преобразования в котором она объявлена.

- Объект `threadprivate` переменной не должны присутствовать в любое предложение, за исключением `copyin`, `copyprivate`, `schedule`, `num_threads`, или **Если** предложение.

- Адрес `threadprivate` переменная не константу адреса.

- Объект `threadprivate` переменная не должна иметь неполный тип или ссылочным типом.

- Объект `threadprivate` переменной с типом класса, отличных от POD должны иметь доступный и однозначный копирования конструктору, если он объявляется с помощью инициализатора явной.

В следующем примере показано, как изменение, отображаемый в инициализаторе переменной может привести к непредсказуемому поведению и как избежать этой проблемы, используя это вспомогательный объект и конструктор копии.

```
int x = 1;
T a(x);
const T b_aux(x); /* Capture value of x = 1 */
T b(b_aux);
#pragma omp threadprivate(a, b)

void f(int n) {
   x++;
   #pragma omp parallel for
   /* In each thread:
   * Object a is constructed from x (with value 1 or 2?)
   * Object b is copy-constructed from b_aux
   */
   for (int i=0; i<n; i++) {
      g(a, b); /* Value of a is unspecified. */
   }
}
```

## <a name="cross-references"></a>Перекрестные ссылки:

- Динамические потоки, см. в разделе [разделе 3.1.7](../../parallel/openmp/3-1-7-omp-set-dynamic-function.md) на стр. 39.

- `OMP_DYNAMIC` переменной, см. в разделе среды [разделе 4.3](../../parallel/openmp/4-3-omp-dynamic.md) на стр.