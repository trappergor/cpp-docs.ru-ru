---
title: Пошаговое руководство. Отладка приложения C++ AMP
ms.date: 04/23/2019
helpviewer_keywords:
- debugging, C++ Accelerated Massive Parallelism
- C++ AMP, debugging
- C++ Accelerated Massive Parallelism, debugging
- debugging, C++ AMP
ms.assetid: 40e92ecc-f6ba-411c-960c-b3047b854fb5
ms.openlocfilehash: 6eb93d617ac9909a67719b144a44ed461701225e
ms.sourcegitcommit: 6b3d793f0ef3bbb7eefaf9f372ba570fdfe61199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2020
ms.locfileid: "86404721"
---
# <a name="walkthrough-debugging-a-c-amp-application"></a>Пошаговое руководство. Отладка приложения C++ AMP

В этом разделе показано, как выполнить отладку приложения, использующего C++ Accelerated Massive Parallelism (C++ AMP), чтобы воспользоваться преимуществами графического процессора (GPU). Он использует программу параллельного сокращения, которая суммирует большой массив целых чисел. В данном пошаговом руководстве рассмотрены следующие задачи:

- Запуск отладчика GPU.

- Проверка потоков GPU в окне потоков GPU.

- Использование окна **Параллельные стеки** для одновременного наблюдения за стеками вызовов нескольких потоков GPU.

- Использование окна " **Параллельные контрольные** значения" для проверки значений одного выражения в нескольких потоках одновременно.

- Пометка, замораживание, размораживание и группирование потоков GPU.

- Исполнение всех потоков плитки в определенное место в коде.

## <a name="prerequisites"></a>Предварительные требования

Перед началом работы с этим пошаговым руководством:

- Ознакомьтесь [C++ amp обзором](../../parallel/amp/cpp-amp-overview.md).

- Убедитесь, что номера строк отображаются в текстовом редакторе. Дополнительные сведения см. в разделе [инструкции. Отображение номеров строк в редакторе](/visualstudio/ide/reference/how-to-display-line-numbers-in-the-editor).

- Убедитесь, что вы используете как минимум Windows 8 или Windows Server 2012 для поддержки отладки в эмуляторе программного обеспечения.

[!INCLUDE[note_settings_general](../../mfc/includes/note_settings_general_md.md)]

### <a name="to-create-the-sample-project"></a>Создание примера проекта

Инструкции по созданию проекта зависят от используемой версии Visual Studio. Убедитесь, что выбрана правильная версия в левом верхнем углу этой страницы.

::: moniker range="vs-2019"

### <a name="to-create-the-sample-project-in-visual-studio-2019"></a>Создание примера проекта в Visual Studio 2019

1. В строке меню выберите **Файл** > **Создать** > **Проект**, чтобы открыть диалоговое окно **Создание проекта**.

1. В верхней части диалогового окна для параметра **Язык** выберите значение **C++** , для параметра **Платформа** — значение **Windows**, а для параметра **Тип проекта** — значение **Консоль**.

1. В отфильтрованном списке типов проектов щелкните **Консольное приложение**, а затем нажмите кнопку **Далее**. На следующей странице введите `AMPMapReduce` в поле **Имя**, чтобы указать название проекта, и при необходимости укажите расположение проекта.

   ![Назовите проект.](../../build/media/mathclient-project-name-2019.png "Назовите проект.")

1. Нажмите кнопку **Создать**, чтобы создать клиентский проект.

::: moniker-end

::: moniker range="<=vs-2017"

### <a name="to-create-the-sample-project-in-visual-studio-2017-or-visual-studio-2015"></a>Создание примера проекта в Visual Studio 2017 или Visual Studio 2015

1. Запустите среду Visual Studio.

1. В строке меню щелкните **Файл** > **Создать** > **Проект**.

1. В разделе **установленные** в области шаблоны выберите **Visual C++**.

1. Выберите **консольное приложение Win32**, введите `AMPMapReduce` в поле **имя** , а затем нажмите кнопку **ОК** .

1. Нажмите кнопку **Далее**.

1. Снимите флажок **предкомпилированный заголовок** , а затем нажмите кнопку **Готово** .

1. В **Обозреватель решений**удалите файл *stdafx. h*, *targetver. h*и *stdafx. cpp* из проекта.

::: moniker-end

Далее:

1. Откройте Ампмапредуце. cpp и замените его содержимое следующим кодом.

```cpp
    // AMPMapReduce.cpp defines the entry point for the program.
    // The program performs a parallel-sum reduction that computes the sum of an array of integers.

    #include <stdio.h>
    #include <tchar.h>
    #include <amp.h>

    const int BLOCK_DIM = 32;

    using namespace concurrency;

    void sum_kernel_tiled(tiled_index<BLOCK_DIM> t_idx, array<int, 1> &A, int stride_size) restrict(amp)
    {
        tile_static int localA[BLOCK_DIM];

        index<1> globalIdx = t_idx.global * stride_size;
        index<1> localIdx = t_idx.local;

        localA[localIdx[0]] =  A[globalIdx];

        t_idx.barrier.wait();

        // Aggregate all elements in one tile into the first element.
        for (int i = BLOCK_DIM / 2; i > 0; i /= 2)
        {
            if (localIdx[0] < i)
            {

                localA[localIdx[0]] += localA[localIdx[0] + i];
            }

            t_idx.barrier.wait();
        }

        if (localIdx[0] == 0)
        {
            A[globalIdx] = localA[0];
        }
    }

    int size_after_padding(int n)
    {
        // The extent might have to be slightly bigger than num_stride to
        // be evenly divisible by BLOCK_DIM. You can do this by padding with zeros.
        // The calculation to do this is BLOCK_DIM * ceil(n / BLOCK_DIM)
        return ((n - 1) / BLOCK_DIM + 1) * BLOCK_DIM;
    }

    int reduction_sum_gpu_kernel(array<int, 1> input)
    {
        int len = input.extent[0];

        //Tree-based reduction control that uses the CPU.
        for (int stride_size = 1; stride_size < len; stride_size *= BLOCK_DIM)
        {
            // Number of useful values in the array, given the current
            // stride size.
            int num_strides = len / stride_size;

            extent<1> e(size_after_padding(num_strides));

            // The sum kernel that uses the GPU.
            parallel_for_each(extent<1>(e).tile<BLOCK_DIM>(), [&input, stride_size] (tiled_index<BLOCK_DIM> idx) restrict(amp)
            {
                sum_kernel_tiled(idx, input, stride_size);
            });
        }

        array_view<int, 1> output = input.section(extent<1>(1));
        return output[0];
    }

    int cpu_sum(const std::vector<int> &arr) {
        int sum = 0;
        for (size_t i = 0; i < arr.size(); i++) {
            sum += arr[i];
        }
        return sum;
    }

    std::vector<int> rand_vector(unsigned int size) {
        srand(2011);

        std::vector<int> vec(size);
        for (size_t i = 0; i < size; i++) {
            vec[i] = rand();
        }
        return vec;
    }

    array<int, 1> vector_to_array(const std::vector<int> &vec) {
        array<int, 1> arr(vec.size());
        copy(vec.begin(), vec.end(), arr);
        return arr;
    }

    int _tmain(int argc, _TCHAR* argv[])
    {
        std::vector<int> vec = rand_vector(10000);
        array<int, 1> arr = vector_to_array(vec);

        int expected = cpu_sum(vec);
        int actual = reduction_sum_gpu_kernel(arr);

        bool passed = (expected == actual);
        if (!passed) {
            printf("Actual (GPU): %d, Expected (CPU): %d", actual, expected);
        }
        printf("sum: %s\n", passed  "Passed!" : "Failed!");

        getchar();

        return 0;
    }
```

1. В строке меню выберите **файл**  >  **сохранить все**.

1. В **Обозреватель решений**откройте контекстное меню для **ампмапредуце**и выберите пункт **Свойства**.

1. В диалоговом окне **страницы свойств** в разделе **Свойства конфигурации**выберите предкомпилированные заголовки **C/C++**  >  **Precompiled Headers**.

1. Для свойства **предкомпилированного заголовка** установите флажок **не использовать предварительно скомпилированные заголовки**, а затем нажмите кнопку **ОК** .

1. В строке меню последовательно выберите **Сборка** > **Собрать решение**.

## <a name="debugging-the-cpu-code"></a>Отладка кода ЦП

В этой процедуре вы будете использовать локальный отладчик Windows, чтобы убедиться в правильности кода ЦП в этом приложении. Сегмент кода ЦП в этом приложении, который особенно интересно, является `for` циклом в `reduction_sum_gpu_kernel` функции. Он управляет параллельным снижением на основе дерева, которое выполняется на GPU.

### <a name="to-debug-the-cpu-code"></a>Отладка кода ЦП

1. В **Обозреватель решений**откройте контекстное меню для **ампмапредуце**и выберите пункт **Свойства**.

2. В диалоговом окне **страницы свойств** в разделе **Свойства конфигурации**выберите **Отладка**. Убедитесь, что в списке **отладчик для запуска** выбран параметр **локальный отладчик Windows** .

3. Вернитесь в **Редактор кода**.

4. Установите точки останова на строках кода, показанных на следующем рисунке (примерно в строках 67 строки 70).

   ![Точки останова ЦП](../../parallel/amp/media/campcpubreakpoints.png "Точки останова ЦП") <br/>
   Точки останова ЦП

5. В строке меню выберите **Отладка**  >  **начать отладку**.

6. В окне **локальные** значения Обратите внимание на значение `stride_size` до тех пор, пока не будет достигнута точка останова в строке 70.

7. В строке меню выберите **Отладка**  >  **Отключить отладку**.

## <a name="debugging-the-gpu-code"></a>Отладка кода GPU

В этом разделе показано, как выполнить отладку кода GPU, который является кодом, содержащимся в `sum_kernel_tiled` функции. Код GPU вычисляет сумму целых чисел для каждого "блока" в параллельном режиме.

### <a name="to-debug-the-gpu-code"></a>Отладка кода GPU

1. В **Обозреватель решений**откройте контекстное меню для **ампмапредуце**и выберите пункт **Свойства**.

2. В диалоговом окне **страницы свойств** в разделе **Свойства конфигурации**выберите **Отладка**.

3. В списке **Загружаемый отладчик** выберите **Локальный отладчик Windows**.

4. Убедитесь, что в списке **Тип отладчика** выбрано значение **Авто** .

    Значение **Auto** является значением по умолчанию. До Windows 10 **только GPU** является обязательным значением вместо **Auto**.

5. Нажмите кнопку **ОК** .

6. Установите точку останова в строке 30, как показано на следующем рисунке.

   ![Точки останова GPU](../../parallel/amp/media/campgpubreakpoints.png "Точки останова GPU") <br/>
   Точка останова GPU

7. В строке меню выберите **Отладка**  >  **начать отладку**. Точки останова в коде ЦП в строках 67 и 70 не выполняются во время отладки GPU, поскольку эти строки кода выполняются на ЦП.

### <a name="to-use-the-gpu-threads-window"></a>Использование окна "потоки GPU"

1. Чтобы открыть окно **потоков GPU** , в строке меню выберите **Отладка**  >  **Windows**  >  **потоков GPU**Windows.

   Вы можете проверить состояние потоков GPU в появившемся окне " **потоки GPU** ".

2. Закрепите окно **потоков GPU** в нижней части Visual Studio. Нажмите кнопку **развернуть потоковый переключатель** , чтобы отобразить текстовые поля плитки и потока. В окне **потоков GPU** отображается общее число активных и заблокированных потоков GPU, как показано на следующем рисунке.

   ![Окно "Потоки GPU" с 4 активными потоками](../../parallel/amp/media/campc.png "Окно "Потоки GPU" с 4 активными потоками") <br/>
   Окно "Потоки GPU"

   Для этого вычисления выделено 313 плиток. Каждая плитка содержит 32 потоков. Поскольку локальная отладка GPU выполняется в эмуляторе программного обеспечения, существует четыре активных потока GPU. Четыре потока выполняют инструкции одновременно, а затем переходят к следующей инструкции.

   В окне **потоков GPU** имеется четыре активных потока GPU и 28 потоков GPU, заблокированных на [tile_barrier:: wait](reference/tile-barrier-class.md#wait) , определенный в около строки 21 ( `t_idx.barrier.wait();` ). Все потоки GPU 32 принадлежат к первой плитке, `tile[0]` . Стрелка указывает на строку, содержащую текущий поток. Чтобы переключиться на другой поток, используйте один из следующих методов.

    - В строке потока для переключения в окне **потоки GPU** откройте контекстное меню и выберите **Переключение к потоку**. Если строка представляет более одного потока, будет переключен на первый поток в соответствии с координатами потока.

    - Введите значения плиток и потоков потока в соответствующих текстовых полях, а затем нажмите кнопку **переключения потока** .

   В окне **Стек вызовов** отображается стек вызовов текущего потока GPU.

### <a name="to-use-the-parallel-stacks-window"></a>Использование окна «Параллельные стеки»

1. Чтобы открыть окно **Параллельные стеки** , в строке меню выберите **Отладка**  >  **Windows**  >  **параллельных стеков**Windows.

   Окно **Параллельные стеки** можно использовать для одновременного проверки кадров стека нескольких потоков GPU.

2. Закрепите окно **Параллельные стеки** в нижней части Visual Studio.

3. Убедитесь, что в списке в левом верхнем углу выбраны **потоки** . На следующем рисунке в окне **Параллельные стеки** показано представление потоков GPU, которые вы видели в окне **потоков GPU** , в стеке вызовов.

   ![Окно "Параллельные стеки" с 4 активными потоками](../../parallel/amp/media/campd.png "Окно "Параллельные стеки" с 4 активными потоками") <br/>
   Окно "Параллельные стеки"

   32. потоки перешли в `_kernel_stub` лямбда-инструкцию в `parallel_for_each` вызове функции, а затем на `sum_kernel_tiled` функцию, где происходит снижение параллелизма. 28 из 32 потоков продвигаемся к инструкции [tile_barrier:: wait](reference/tile-barrier-class.md#wait) и остается заблокированной в строке 22, тогда как остальные 4 потока остаются активными в `sum_kernel_tiled` функции в строке 30.

   Вы можете проверить свойства потока GPU, которые доступны в окне **потоки GPU** в параметрах подсказки в окне **Параллельные стеки** . Для этого наведите указатель мыши на кадр стека **sum_kernel_tiled**. На следующем рисунке показана подсказка.

   ![DataTip для окна "Параллельные стеки"](../../parallel/amp/media/campe.png "DataTip для окна "Параллельные стеки"") <br/>
   Подсказка потока GPU

   Дополнительные сведения о окне **Параллельные стеки** см. [в разделе Использование окна Параллельные стеки](/visualstudio/debugger/using-the-parallel-stacks-window).

### <a name="to-use-the-parallel-watch-window"></a>Использование параллельных окно контрольных значений

1. Чтобы открыть окно **параллельных контрольных значений** , в строке меню выберите **Отладка**параллельных  >  **Windows**  >  **контрольных значений Windows параллельный**Просмотр  >  **1**.

   Окно **Параллельные контрольные** значения можно использовать для проверки значений выражения в нескольких потоках.

2. Закрепите окно **Параллельные контрольные значения 1** в нижней части Visual Studio. В таблице в окне " **контроль параллельных** данных" содержится 32 строк. Каждый соответствует потоку GPU, который отображается как в окне потоков GPU, так и в окне **Параллельные стеки** . Теперь можно ввести выражения, значения которых необходимо проверить во всех потоках GPU 32.

3. Щелкните заголовок столбца **добавить контрольные значения** , введите `localIdx` , а затем нажмите клавишу **Ввод** .

4. Снова щелкните заголовок столбца **добавить контрольные значения** , введите `globalIdx` , а затем нажмите клавишу **Ввод** .

5. Снова щелкните заголовок столбца **добавить контрольные значения** , введите `localA[localIdx[0]]` , а затем нажмите клавишу **Ввод** .

   Можно выполнить сортировку по указанному выражению, выбрав соответствующий заголовок столбца.

   Выберите заголовок столбца **Local [локалидкс [0]]** , чтобы отсортировать столбец. На следующем рисунке показаны результаты сортировки по **местному [локалидкс [0]]**.

   ![Окно "Контроль параллельных данных" с отсортированными результатами](../../parallel/amp/media/campf.png "Окно "Контроль параллельных данных" с отсортированными результатами") <br/>
   Результаты сортировки

   Вы можете экспортировать содержимое в окно " **контроль параллельных** данных" в Excel, нажав кнопку **Excel** и выбрав пункт **Открыть в Excel**. Если на компьютере разработчика установлен Excel, откроется лист Excel, содержащий содержимое.

6. В правом верхнем углу окна " **контроль параллельных** данных" есть элемент управления фильтра, который можно использовать для фильтрации содержимого с помощью логических выражений. Введите `localA[localIdx[0]] > 20000` в текстовом поле элемент управления фильтр, а затем нажмите клавишу **Ввод** .

   Теперь окно содержит только потоки, в которых `localA[localIdx[0]]` значение больше 20000. Содержимое по-прежнему сортируется по `localA[localIdx[0]]` столбцу, что является действием сортировки, выполненным ранее.

## <a name="flagging-gpu-threads"></a>Пометка потоков GPU

Вы можете пометить определенные потоки GPU, пометив их в окне **потоков GPU** , в окне " **контроль параллельных** " или в подсказке в окне " **Параллельные стеки** ". Если строка в окне потоков GPU содержит более одного потока, помечая флагом строки все потоки, содержащиеся в строке.

### <a name="to-flag-gpu-threads"></a>Пометка потоков GPU

1. Выберите заголовок столбца **[thread]** в окне " **контроль параллельных значений 1** " для сортировки по индексу плитки и индексу потока.

2. В строке меню выберите **Отладка**  >  **продолжить**, что приводит к тому, что четыре потока, которые были активны, выполняются в следующем барьере (определяется в строке 32 ампмапредуце. cpp).

3. Выберите символ флага в левой части строки, содержащий четыре активных потока.

   На следующем рисунке показаны четыре активных помеченных потока в окне **потоков GPU** .

   ![Окно "Потоки GPU" с помеченными потоками](../../parallel/amp/media/campg.png "Окно "Потоки GPU" с помеченными потоками") <br/>
   Активные потоки в окне "Потоки GPU"

   Окно **Параллельные контрольные значения** и подсказка в окне **Параллельные стеки** обозначают помеченные потоки.

4. Если вы хотите сосредоточиться на четырех отмеченных Вами потоках, можно выбрать отображение в окнах **потоки GPU**, **параллельное наблюдение**и **Параллельные стеки** только отмеченные потоки.

   Нажмите кнопку **Показывать только помеченные флажки** в любой из окон или на панели инструментов **место отладки** . На следующем рисунке показана кнопка **Показать только помеченные** , на панели инструментов **место отладки** .

   ![Панель инструментов "Место отладки" со значком "Показать только помеченные"](../../parallel/amp/media/camph.png "Панель инструментов "Место отладки" со значком "Показать только помеченные"") <br/>
   Кнопка " **Показывать только помеченные** "

   Теперь окна **потоков GPU**, **параллельных контрольных значений**и **параллельных стеков** отображают только отмеченные потоки.

## <a name="freezing-and-thawing-gpu-threads"></a>Замораживание и размораживание потоков GPU

Вы можете заморозить (приостановить) и разморозить (возобновить) потоки GPU в окне **потоков GPU** или в окне **контроль параллельных значений** . Вы можете заморозить и разморозить потоки ЦП таким же образом. Дополнительные сведения см. в разделе [как использовать окно "потоки](/visualstudio/debugger/how-to-use-the-threads-window)".

### <a name="to-freeze-and-thaw-gpu-threads"></a>Замораживание и размораживание потоков GPU

1. Нажмите кнопку **Показать только помеченные** , чтобы отобразить все потоки.

2. В строке меню выберите **Отладка**  >  **продолжить**.

3. Откройте контекстное меню активной строки и выберите пункт **заморозить**.

   На следующей иллюстрации окна **потоков GPU** показано, что все четыре потока заморожены.

   ![Окно "Потоки GPU", в котором показаны замороженные потоки](../../parallel/amp/media/campk.png "Окно "Потоки GPU", в котором показаны замороженные потоки") <br/>
   Замороженные потоки в окне " **потоки GPU** "

   Аналогичным образом окно **параллельных контрольных значений** показывает, что все четыре потока заморожены.

4. В строке меню выберите **Отладка**  >  **продолжить** , чтобы разрешить выполнение следующих четырех потоков GPU за пределами барьера в строке 22 и для достижения точки останова в строке 30. Окно **потоков GPU** показывает, что четыре ранее замороженных потока остаются замороженными и находятся в активном состоянии.

5. В строке меню выберите **Отладка**, **продолжить**.

6. В окне **контроль параллельных значений** можно также разморозить отдельные или несколько потоков GPU.

### <a name="to-group-gpu-threads"></a>Группирование потоков GPU

1. В контекстном меню для одного из потоков в окне **потоки GPU** выберите **Группировать по**, **адрес**.

   Потоки в окне **потоков GPU** группируются по адресу. Адрес соответствует инструкции в дизассемблированного кода, где размещается каждая группа потоков. 24 потока находятся в строке 22, где выполняется [метод tile_barrier:: wait](reference/tile-barrier-class.md#wait) . 12 потоков — это инструкция для барьера в строке 32. Четыре из этих потоков помечены. Восемь потоков находятся в точке останова в строке 30. Четыре из этих потоков заморожены. На следующем рисунке показаны сгруппированные потоки в окне **потоков GPU** .

   ![Окно "Потоки GPU" с потоками, сгруппированными по адресам](../../parallel/amp/media/campl.png "Окно "Потоки GPU" с потоками, сгруппированными по адресам") <br/>
   Сгруппированные потоки в окне **потоков GPU**

2. Можно также выполнить операцию **Group By** , открыв контекстное меню сетки данных окна **контроль параллельных значений** , выбрав **Группировать по**и выбрав пункт меню, соответствующий тому, как нужно сгруппировать потоки.

## <a name="running-all-threads-to-a-specific-location-in-code"></a>Выполнение всех потоков в определенном месте в коде

Все потоки в заданной плитке выполняются в строке, содержащей курсор, с помощью команды **запустить текущую плитку в курсоре**.

### <a name="to-run-all-threads-to-the-location-marked-by-the-cursor"></a>Выполнение всех потоков в расположении, помеченном курсором

1. В контекстном меню для замороженных потоков выберите **разморозить**.

2. В **редакторе кода**наведите курсор на строку 30.

3. В контекстном меню **редактора кода**выберите пункт **запустить текущую плитку в курсоре**.

   24 потока, которые ранее были заблокированы в барьере в строке 21, были выполнены до строки 32. Это показано в окне **потоков GPU** .

## <a name="see-also"></a>См. также раздел

[Обзор C++ AMP](../../parallel/amp/cpp-amp-overview.md)<br/>
[Отладка кода GPU](/visualstudio/debugger/debugging-gpu-code)<br/>
[Практическое руководство. использование окна потоков GPU](/visualstudio/debugger/how-to-use-the-gpu-threads-window)<br/>
[Практическое руководство. Использование окна контроля параллельных данных](/visualstudio/debugger/how-to-use-the-parallel-watch-window)<br/>
[Анализ кода C++ AMP с помощью визуализатора параллелизма](/archive/blogs/nativeconcurrency/analyzing-c-amp-code-with-the-concurrency-visualizer)
