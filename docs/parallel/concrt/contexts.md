---
title: Контексты | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-concrt
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- contexts [Concurrency Runtime]
ms.assetid: 10c1d861-8fbb-4ba0-b2ec-61876b11176e
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 7be66658c9452fa97c1971ae6719dccb06dbd836
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46378225"
---
# <a name="contexts"></a>Контексты

В этом документе описывается роль контекстов в среде выполнения с параллелизмом. Поток, который присоединяется к планировщика называется *контекст выполнения*, или просто *контекст*. [Concurrency::wait](reference/concurrency-namespace-functions.md#wait) функция и параллелизма::[класс контекста](../../parallel/concrt/reference/context-class.md) позволяют управлять поведением контекстов. Используйте `wait` функция приостанавливает текущий контекст в течение указанного времени. Используйте `Context` класса, когда требуется больший контроль над при контекстов блокировать, разблокировать и разрешать или если вы хотите текущего контекста.

> [!TIP]
>  Среда выполнения с параллелизмом предоставляет планировщик по умолчанию, и таким образом не требуется создавать планировщик в приложении. Поскольку планировщик задач помогает оптимизировать производительность приложений, мы рекомендуем начать с [библиотеки параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md) или [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md) при наличии создать среду выполнения с параллелизмом.

## <a name="the-wait-function"></a>Функция ожидания

[Concurrency::wait](reference/concurrency-namespace-functions.md#wait) функция совместно передает выполнение в текущем контексте для указанного числа миллисекунд. Среда выполнения использует время передачи для выполнения других задач. После истечения указанного времени, среда выполнения переносит контекст для выполнения. Таким образом `wait` функция может заблокировать текущий контекст больше времени, чем значение, указанное для `milliseconds` параметра.

Передача значения 0 (ноль) `milliseconds` параметр заставляет среду выполнения для приостановки контекст текущего объекта до всех остальных активных контекстов предоставляется возможность для выполнения работы. Это позволяет передать задачу всем активным задачам.

### <a name="example"></a>Пример

Пример, использующий `wait` функцию для получения текущего контекста, сократив тем самым для других контекстов для запуска, см. в разделе [как: используйте группы расписаний для влияют на порядок выполнения](../../parallel/concrt/how-to-use-schedule-groups-to-influence-order-of-execution.md).

## <a name="the-context-class"></a>Класс контекста

Параллелизм::[класс контекста](../../parallel/concrt/reference/context-class.md) предоставляет программную абстракцию для контекста выполнения, а также две важные функции: возможность совместно блокировать, разблокировать и выполнять текущий контекст и возможность превышать лимит подписки текущего контекста.

### <a name="cooperative-blocking"></a>Совместное блокирование

`Context` Класс позволяет блокировать или разрешать текущего контекста выполнения. Блокирование или разрешение полезно, когда текущий контекст не может продолжаться, поскольку ресурс не поддерживается.

[Concurrency::Context:: Block](reference/context-class.md#block) метод блокирует текущий контекст. Контекст, который блокируется дает свои ресурсы для обработки, таким образом, чтобы среда выполнения может выполнять другие задачи. [Concurrency::Context:: Unblock](reference/context-class.md#unblock) метод разблокирует Заблокированный контекст. `Context::Unblock` Метод должен вызываться в контексте, отличном от того, который вызывается `Context::Block`. Среда выполнения создает [concurrency::context_self_unblock](../../parallel/concrt/reference/context-self-unblock-class.md) Если контекст пытается разблокировать себя.

Для совместной блокировки и разблокирования контекста, обычно вызывают [Concurrency::Context:: CurrentContext](reference/context-class.md#currentcontext) для получения указателя на `Context` объект, связанный с текущим потоком и сохранить результат. Затем можно вызвать `Context::Block` метод для блокирования текущего контекста. Необходимо вызвать `Context::Unblock` из отдельного контекста разблокировать заблокированный контекст.

Должно соответствовать каждая пара вызовов `Context::Block` и `Context::Unblock`. Среда выполнения создает [concurrency::context_unblock_unbalanced](../../parallel/concrt/reference/context-unblock-unbalanced-class.md) при `Context::Block` или `Context::Unblock` метод вызывается последовательно без соответствующего вызова другого метода. Тем не менее, нет необходимости вызывать `Context::Block` перед вызовом метода `Context::Unblock`. Например, если один контекст вызывает `Context::Unblock` до другой контекст вызовов `Context::Block` же контекста, контекст остается незаблокированным.

[Concurrency::Context:: yield](reference/context-class.md#yield) метод передает выполнение, чтобы среда выполнения может выполнять другие задачи, а затем перепланировать контекст для выполнения. При вызове `Context::Block` метода, среда выполнения не перепланировать контекст.

#### <a name="example"></a>Пример

Пример, использующий `Context::Block`, `Context::Unblock`, и `Context::Yield` методы для реализации класса семафора, см. в разделе [как: использование класса Context для реализации семафора совместной](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md).

##### <a name="oversubscription"></a>Превышение лимита подписки

Планировщик по умолчанию создает столько же потоков имеется доступных аппаратных потоков. Можно использовать *превышение лимита подписки* для создания дополнительных потоков для заданного аппаратного потока.

Для операций с большим объемом вычислений превышение лимита подписки обычно не масштабируется, так как она порождает дополнительную нагрузку. Тем не менее для задач, которые имеют большой объем задержки, например, чтение данных с диска или из сетевого подключения, превышение лимита подписки может повысить общую эффективность некоторых приложений.

> [!NOTE]
>  Разрешать превышение лимита подписки следует только в потоке, созданном средой выполнения с параллелизмом. Превышение лимита подписки не оказывает влияния при вызове из потока, который не был создан средой выполнения (в том числе и в основном потоке).

Чтобы разрешить превышение лимита подписки в текущем контексте, вызовите [Concurrency::Context:: Oversubscribe](reference/context-class.md#oversubscribe) метод с `_BeginOversubscription` параметру присвоить `true`. Когда вы включаете превышение лимита подписки в потоке, который был создан средой выполнения с параллелизмом, среда выполнения для создания одному дополнительному потоку. После завершения всех задач, требующих превышения лимита подписки, вызовите `Context::Oversubscribe` с `_BeginOversubscription` параметру присвоить `false`.

Вы можете разрешить превышение лимита подписки несколько раз из текущего контекста, но его необходимо отключить такое же количество раз, в которых он включен. Превышение лимита подписки также могут быть вложенными; то есть задачу, которая создается с другой задачей, которая использует превышение лимита подписки можно также превысить предел подписок его контекста. Тем не менее если и это вложенная задача и родительская принадлежит к тому же контексту, только внешний вызов `Context::Oversubscribe` вызывает создание дополнительных потоков.

> [!NOTE]
>  Среда выполнения создает [concurrency::invalid_oversubscribe_operation](../../parallel/concrt/reference/invalid-oversubscribe-operation-class.md) Если превышение лимита подписки запрещено для ее включения.

###### <a name="example"></a>Пример

Например, превышение лимита подписки для смещения задержки, вызванной чтение данных из сетевого подключения, см. в разделе [как: превышение лимита подписки используйте к задержке смещение](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

## <a name="see-also"></a>См. также

[Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Практическое руководство. Использование групп планирования для определения порядка выполнения](../../parallel/concrt/how-to-use-schedule-groups-to-influence-order-of-execution.md)<br/>
[Практическое руководство. Использование класса Context для реализации семафора, поддерживающего параллельный доступ](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)<br/>
[Практическое руководство. Использование лимита подписки для устранения задержек](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md)

