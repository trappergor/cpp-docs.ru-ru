---
title: Контексты
ms.date: 11/04/2016
helpviewer_keywords:
- contexts [Concurrency Runtime]
ms.assetid: 10c1d861-8fbb-4ba0-b2ec-61876b11176e
ms.openlocfilehash: 7df75ae7c1ac2b1d8c0b73ff1f1e3f2800d559b9
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87194879"
---
# <a name="contexts"></a>Контексты

В этом документе описывается роль контекстов в среда выполнения с параллелизмом. Поток, присоединенный к планировщику, называется *контекстом выполнения*или просто *контекстом*. Функция [Concurrency:: wait](reference/concurrency-namespace-functions.md#wait) и класс Concurrency::[context](../../parallel/concrt/reference/context-class.md) позволяют управлять поведением контекстов. Используйте `wait` функцию, чтобы приостановить текущий контекст в течение заданного времени. Используйте `Context` класс, если требуется больший контроль над тем, когда контексты блокируют, разблокируются и выдают, или когда требуется переписывать текущий контекст.

> [!TIP]
> Среда выполнения с параллелизмом предоставляет планировщик по умолчанию, и таким образом не требуется создавать планировщик в приложении. Поскольку планировщик задач помогает точно настроить производительность приложений, рекомендуется начать с [библиотеки параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md) или [библиотеки асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) , если вы не знакомы с среда выполнения с параллелизмом.

## <a name="the-wait-function"></a>Функция wait

Функция [Concurrency:: wait](reference/concurrency-namespace-functions.md#wait) выполняет совместное выполнение текущего контекста в течение указанного числа миллисекунд. Среда выполнения использует время получения для выполнения других задач. По истечении указанного времени среда выполнения перепланирует контекст для выполнения. Таким образом, `wait` функция может приостановить текущий контекст дольше, чем указано в `milliseconds` параметре.

Передача значения 0 (нуль) для `milliseconds` параметра приводит к тому, что среда выполнения приостанавливает текущий контекст до тех пор, пока всем остальным его активным не будет предоставлена возможность выполнения работы. Это позволяет получить задачу для всех других активных задач.

### <a name="example"></a>Пример

Пример, использующий `wait` функцию для получения текущего контекста и, таким образом, для выполнения других контекстов, см. в разделе [как использовать группы расписаний для влияния на порядок выполнения](../../parallel/concrt/how-to-use-schedule-groups-to-influence-order-of-execution.md).

## <a name="the-context-class"></a>Класс контекста

Класс Concurrency::[context](../../parallel/concrt/reference/context-class.md) обеспечивает абстракцию программирования для контекста выполнения и предлагает две важные функции: возможность совместно блокировать, разблокировать и выдавать текущий контекст, а также возможность переписывать текущий контекст.

### <a name="cooperative-blocking"></a>Совместное блокирование

`Context`Класс позволяет блокировать или выдавать текущий контекст выполнения. Блокировка или передается, если текущий контекст не может продолжить работу, так как ресурс недоступен.

Метод [Concurrency:: Context:: Block](reference/context-class.md#block) блокирует текущий контекст. Заблокированный контекст выдает ресурсы для обработки, чтобы среда выполнения могла выполнять другие задачи. Метод [Concurrency:: Context:: reblock](reference/context-class.md#unblock) разблокирует Заблокированный контекст. `Context::Unblock`Метод должен вызываться в контексте, отличном от контекста, в котором он был вызван `Context::Block` . Среда выполнения вызывает метод [Concurrency:: context_self_unblock](../../parallel/concrt/reference/context-self-unblock-class.md) , если контекст пытается разблокировать себя.

Для совместного блокирования и разблокировки контекста обычно вызывается [Concurrency:: Context:: CurrentContext](reference/context-class.md#currentcontext) , чтобы получить указатель на `Context` объект, связанный с текущим потоком, и сохранить результат. Затем вызывается `Context::Block` метод для блокировки текущего контекста. Затем вызовите `Context::Unblock` из отдельного контекста, чтобы разблокировать заблокированный контекст.

Необходимо сопоставить каждую пару вызовов `Context::Block` и `Context::Unblock` . Среда выполнения вызывает метод [Concurrency:: context_unblock_unbalanced](../../parallel/concrt/reference/context-unblock-unbalanced-class.md) при `Context::Block` `Context::Unblock` последовательном вызове метода или без соответствующего вызова другого метода. Однако нет необходимости вызывать метод `Context::Block` перед вызовом метода `Context::Unblock` . Например, если один контекст вызывает вызов `Context::Unblock` до вызова другого контекста `Context::Block` для того же контекста, этот контекст остается незаблокированным.

Метод [Concurrency:: Context:: Yield](reference/context-class.md#yield) выдает выполнение, чтобы среда выполнения могла выполнять другие задачи, а затем перепланировать контекст для выполнения. При вызове `Context::Block` метода среда выполнения не перепланирует контекст.

#### <a name="example"></a>Пример

Пример, в котором используются `Context::Block` методы, `Context::Unblock` и `Context::Yield` для реализации класса семафора с совместным использованием, см. в разделе [как использовать класс контекста для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md).

##### <a name="oversubscription"></a>Превышение лимита подписки

Планировщик по умолчанию создает то же число потоков, что и доступные аппаратные потоки. *Превышение лимита подписки* можно использовать для создания дополнительных потоков для данного аппаратного потока.

Для ресурсоемких операций превышение лимита подписки обычно не масштабируется, так как в нем реализованы дополнительные издержки. Однако для задач с большим количеством задержек, например считывания данных с диска или с сетевого подключения, превышение лимита подписки может повысить общую эффективность некоторых приложений.

> [!NOTE]
> Разрешать превышение лимита подписки следует только в потоке, созданном средой выполнения с параллелизмом. Превышение лимита подписки не имеет силы при вызове из потока, который не был создан средой выполнения (включая основной поток).

Чтобы включить превышение лимита подписки в текущем контексте, вызовите метод [Concurrency:: Context:: resubscribe](reference/context-class.md#oversubscribe) с `_BeginOversubscription` параметром, для которого задано значение **`true`** . При включении превышения лимита подписки для потока, созданного среда выполнения с параллелизмом, среда выполнения создает еще один дополнительный поток. После всех задач, требующих завершения работы с превышением лимита подписки, вызовите `Context::Oversubscribe` с `_BeginOversubscription` параметром, имеющим значение **`false`** .

Превышение лимита подписки можно включить несколько раз из текущего контекста, но необходимо отключить это количество раз, когда она была включена. Превышение лимита подписки также может быть вложенным; Это значит, что задача, созданная другой задачей, использующей превышение лимита подписки, также может быть переподписана ее контекстом. Однако если как вложенная задача, так и ее родитель относятся к одному и тому же контексту, только внешний вызов `Context::Oversubscribe` вызывает создание дополнительного потока.

> [!NOTE]
> Среда выполнения вызывает метод [Concurrency:: invalid_oversubscribe_operation](../../parallel/concrt/reference/invalid-oversubscribe-operation-class.md) , если превышение лимита подписки отключено перед включением.

###### <a name="example"></a>Пример

Пример использования превышения лимита подписки для смещения задержки, вызванной считыванием данных из сетевого подключения, см. [в разделе как использовать превышение лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

## <a name="see-also"></a>См. также раздел

[планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Как использовать группы расписаний для влияния на порядок выполнения](../../parallel/concrt/how-to-use-schedule-groups-to-influence-order-of-execution.md)<br/>
[Как использовать класс контекста для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)<br/>
[Как использовать превышение лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md)
