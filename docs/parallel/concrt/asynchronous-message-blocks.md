---
title: Асинхронные блоки сообщений
ms.date: 11/04/2016
helpviewer_keywords:
- non-greedy join [Concurrency Runtime]
- asynchronous message blocks
- greedy join [Concurrency Runtime]
ms.assetid: 79c456c0-1692-480c-bb67-98f2434c1252
ms.openlocfilehash: 6697bdd296a3c71f03bc22986efa47dd586d5d9e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87217913"
---
# <a name="asynchronous-message-blocks"></a>Асинхронные блоки сообщений

Библиотека агентов предоставляет несколько типов блоков сообщений, которые позволяют передавать сообщения между компонентами приложения в безопасном для потоков режиме. Эти типы блоков сообщений часто используются с различными поддействиями передачи сообщений, такими как [Concurrency:: send](reference/concurrency-namespace-functions.md#send), [Concurrency:: asend](reference/concurrency-namespace-functions.md#asend), [Concurrency:: receive](reference/concurrency-namespace-functions.md#receive)и [Concurrency:: try_receive](reference/concurrency-namespace-functions.md#try_receive). Дополнительные сведения о подпрограммых передачи сообщений, определенных библиотекой агентов, см. в разделе [функции передачи сообщений](../../parallel/concrt/message-passing-functions.md).

## <a name="sections"></a><a name="top"></a>Священ

Этот раздел состоит из следующих подразделов.

- [Источники и целевые блоки](#sources_and_targets)

- [Распространение сообщений](#propagation)

- [Общие сведения о типах блоков сообщений](#overview)

- [Класс unbounded_buffer](#unbounded_buffer)

- [Класс overwrite_buffer](#overwrite_buffer)

- [Класс single_assignment](#single_assignment)

- [Класс Call](#call)

- [Класс transformer](#transformer)

- [Класс choice](#choice)

- [Классы присоединений и multitype_join](#join)

- [Класс Timer](#timer)

- [Фильтрация сообщений](#filtering)

- [Резервирование сообщений](#reservation)

## <a name="sources-and-targets"></a><a name="sources_and_targets"></a>Источники и целевые объекты

Источники и целевые объекты — это два важных участника передачи сообщений. *Источник* ссылается на конечную точку взаимодействия, которая отправляет сообщения. *Целевой объект* ссылается на конечную точку обмена данными, которая получает сообщения. Источник можно считать конечной точкой, из которой выполняется чтение, и целевым объектом в качестве конечной точки, в которую вы пишете. Приложения связывают источники и целевые объекты для формирования *сетей обмена сообщениями*.

Библиотека агентов использует два абстрактных класса для представления источников и целевых объектов: [Concurrency:: ISource](../../parallel/concrt/reference/isource-class.md) и [Concurrency:: ITarget](../../parallel/concrt/reference/itarget-class.md). Типы блоков сообщений, выступающих в качестве источников, являются `ISource` типами блоков сообщений, которые являются целями, производными от `ITarget` . Типы блоков сообщений, выступающие в качестве источников и целевых объектов, являются производными от `ISource` и `ITarget` .

[[Top](#top)]

## <a name="message-propagation"></a><a name="propagation"></a>Распространение сообщений

*Распространение сообщений* — это акт отправки сообщения из одного компонента в другой. Когда блок сообщений предлагает сообщение, он может принять, отклонить или отложить это сообщение. Каждый тип блока сообщений хранит и передает сообщения различными способами. Например, `unbounded_buffer` класс хранит неограниченное количество сообщений, `overwrite_buffer` класс сохраняет одно сообщение за раз, а класс transformer сохраняет измененную версию каждого сообщения. Эти типы блоков сообщений подробно описаны далее в этом документе.

Когда блок сообщений принимает сообщение, он может при необходимости выполнить работу и, если блок сообщений является источником, передать полученное сообщение другому члену сети. Блок сообщений может использовать функцию фильтра для отклонения сообщений, которые не требуется принимать. Фильтры более подробно описаны далее в этом разделе, в разделе [Фильтрация сообщений](#filtering). Блок сообщений, который откладывает сообщение, может зарезервировать это сообщение и использовать его позже. Резервирование сообщений подробно описано далее в этом разделе в разделе [резервирование сообщений](#reservation)раздела.

Библиотека агентов позволяет блокам сообщений асинхронно или синхронно передавать сообщения. Если сообщение передается в блок сообщений синхронно, например с помощью `send` функции, среда выполнения блокирует текущий контекст до тех пор, пока целевой блок не примет или не отклонит сообщение. Если сообщение передается в блок сообщений асинхронно, например с помощью `asend` функции, среда выполнения предоставляет сообщение целевому объекту, а если целевой объект принимает сообщение, среда выполнения планирует асинхронную задачу, которая распространяет сообщение получателю. Среда выполнения использует упрощенные задачи для распространения сообщений в совместном режиме. Дополнительные сведения о упрощенных задачах см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

Приложения связывают источники и целевые объекты для формирования сетей обмена сообщениями. Как правило, вы связываете сеть и вызываете `send` или `asend` передаете данные в сеть. Чтобы подключить блок исходного сообщения к целевому объекту, вызовите метод [Concurrency:: ISource:: link_target](reference/isource-class.md#link_target) . Чтобы отключить исходный блок от целевого объекта, вызовите метод [Concurrency:: ISource:: unlink_target](reference/isource-class.md#unlink_target) . Чтобы отключить исходный блок от всех его целевых объектов, вызовите метод [Concurrency:: ISource:: unlink_targets](reference/isource-class.md#unlink_targets) . Если один из предопределенных типов блоков сообщений оставляет область или уничтожается, он автоматически отключается от любых целевых блоков. Некоторые типы блоков сообщений ограничивают максимальное количество целевых объектов, в которые они могут записывать. В следующем разделе описаны ограничения, которые применяются к предопределенным типам блоков сообщений.

[[Top](#top)]

## <a name="overview-of-message-block-types"></a><a name="overview"></a>Общие сведения о типах блоков сообщений

В следующей таблице кратко описаны роли важных типов блоков сообщений.

[unbounded_buffer](#unbounded_buffer)<br/>
Хранит очередь сообщений.

[overwrite_buffer](#overwrite_buffer)<br/>
Хранит одно сообщение, которое может быть записано и прочитано несколько раз.

[single_assignment](#single_assignment)<br/>
Хранит одно сообщение, которое может быть записано в один раз и прочитано несколько раз.

[call](#call)<br/>
Выполняет работу при получении сообщения.

[образователь](#transformer)<br/>
Выполняет работу при получении данных и отправляет результат этой работы в другой целевой блок. `transformer`Класс может работать с различными типами входных и выходных данных.

[choice](#choice)<br/>
Выбирает первое доступное сообщение из набора источников.

[соединение и многотиповое соединение](#join)<br/>
Дождитесь получения всех сообщений из набора источников, а затем объедините сообщения в одно сообщение для другого блока сообщений.

[активности](#timer)<br/>
Отправляет сообщение в целевой блок через обычный интервал.

Эти типы блоков сообщений имеют различные характеристики, которые делают их полезными в различных ситуациях. Ниже приведены некоторые характеристики.

- *Тип распространения*: указывает, выступает ли блок сообщений в качестве источника данных, получателя данных или и того, и другого.

- *Упорядочение сообщений*: указывает, поддерживает ли блок сообщений исходный порядок отправки или получения сообщений. Каждый предопределенный тип блока сообщений поддерживает исходный порядок, в котором он отправляет или получает сообщения.

- *Число источников*: максимальное число источников, из которых может считываться блок сообщений.

- *Целевое число*: максимальное количество целевых объектов, в которые блок сообщений может выполнять запись.

В следующей таблице показано, как эти характеристики связаны с различными типами блоков сообщений.

|Тип блока сообщения|Тип распространения (источник, цель или оба)|Упорядочение сообщений (упорядоченный или неупорядоченный)|Число источников|Число целевых объектов|
|------------------------|--------------------------------------------------|-----------------------------------------------|------------------|------------------|
|`unbounded_buffer`|Оба|Заказано|Unbounded|Unbounded|
|`overwrite_buffer`|Оба|Заказано|Unbounded|Unbounded|
|`single_assignment`|Оба|Заказано|Unbounded|Unbounded|
|`call`|Назначение|Заказано|Unbounded|Неприменимо|
|`transformer`|Оба|Заказано|Unbounded|1|
|`choice`|Оба|Заказано|10|1|
|`join`|Оба|Заказано|Unbounded|1|
|`multitype_join`|Оба|Заказано|10|1|
|`timer`|Источник|Неприменимо|Неприменимо|1|

В следующих разделах более подробно описаны типы блоков сообщений.

[[Top](#top)]

## <a name="unbounded_buffer-class"></a><a name="unbounded_buffer"></a>Класс unbounded_buffer

Класс [Concurrency:: unbounded_buffer](reference/unbounded-buffer-class.md) представляет структуру общего назначения для асинхронного обмена сообщениями. В этом классе хранится очередь сообщений типа «первым вошел — первым вышел» (FIFO), в которую могут записывать данные несколько источников и из которой могут читать данные несколько целевых объектов. Когда целевой объект получает сообщение от `unbounded_buffer` объекта, это сообщение удаляется из очереди сообщений. Таким образом, хотя `unbounded_buffer` у объекта может быть несколько целевых объектов, каждое сообщение получит только один целевой объект. Класс `unbounded_buffer` удобен, если нужно передать несколько сообщений другому компоненту и этот компонент должен принять каждое сообщение.

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `unbounded_buffer` классом. Этот пример отправляет три значения в `unbounded_buffer` объект, а затем считывает их обратно из того же объекта.

[!code-cpp[concrt-unbounded_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_1.cpp)]

В этом примере выводятся следующие данные:

```Output
334455
```

Полный пример, демонстрирующий использование `unbounded_buffer` класса, см. в разделе [как реализовать различные шаблоны "производитель-получатель"](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).

[[Top](#top)]

## <a name="overwrite_buffer-class"></a><a name="overwrite_buffer"></a>Класс overwrite_buffer

Класс [Concurrency:: overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) напоминает `unbounded_buffer` класс, за исключением того, что `overwrite_buffer` объект хранит только одно сообщение. Кроме того, когда целевой объект получает сообщение от `overwrite_buffer` объекта, это сообщение не удаляется из буфера. Поэтому копию сообщения могут получить несколько целевых объектов.

`overwrite_buffer`Класс полезен, если требуется передать несколько сообщений другому компоненту, но этому компоненту требуется только самое последнее значение. Этот класс также может оказаться полезным при необходимости широковещательной передачи сообщения нескольким компонентам.

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `overwrite_buffer` классом. Этот пример отправляет три значения в `overwrite _buffer` объект, а затем считывает текущее значение из того же объекта три раза. Этот пример похож на пример для `unbounded_buffer` класса. Однако `overwrite_buffer` класс хранит только одно сообщение. Кроме того, среда выполнения не удаляет сообщение из `overwrite_buffer` объекта после его считывания.

[!code-cpp[concrt-overwrite_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_2.cpp)]

В этом примере выводятся следующие данные:

```Output
555555
```

Полный пример, демонстрирующий использование `overwrite_buffer` класса, см. в разделе [как реализовать различные шаблоны "производитель-получатель"](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).

[[Top](#top)]

## <a name="single_assignment-class"></a><a name="single_assignment"></a>Класс single_assignment

Класс [Concurrency:: single_assignment](../../parallel/concrt/reference/single-assignment-class.md) напоминает `overwrite_buffer` класс, за исключением того, что `single_assignment` объект может быть записан только один раз. Как и в случае с классом `overwrite_buffer`, когда целевой объект получает сообщение от объекта `single_assignment`, это сообщение не удаляется. Поэтому копию сообщения могут получить несколько целевых объектов. `single_assignment`Класс полезен, если нужно транслировать одно сообщение нескольким компонентам.

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `single_assignment` классом. Этот пример отправляет три значения `single_assignment` объекту, а затем считывает текущее значение из того же объекта три раза. Этот пример похож на пример для `overwrite_buffer` класса. Несмотря на то `overwrite_buffer` `single_assignment` , что классы и хранят одно сообщение, `single_assignment` класс может быть записан только один раз.

[!code-cpp[concrt-single_assignment-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_3.cpp)]

В этом примере выводятся следующие данные:

```Output
333333
```

Полный пример, демонстрирующий использование `single_assignment` класса, см. в разделе [Пошаговое руководство. Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md).

[[Top](#top)]

## <a name="call-class"></a><a name="call"></a>Класс Call

Класс [Concurrency:: Call](../../parallel/concrt/reference/call-class.md) выступает в качестве получателя сообщений, который выполняет рабочую функцию при получении данных. Эта Рабочая функция может быть лямбда-выражением, объектом функции или указателем на функцию. `call`Объект работает иначе, чем обычный вызов функции, так как он действует параллельно с другими компонентами, которые отправляют в него сообщения. Если `call` объект выполняет работу при получении сообщения, он добавляет это сообщение в очередь. Каждый `call` объект обрабатывает сообщения в очереди в том порядке, в котором они получены.

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `call` классом. В этом примере создается `call` объект, который выводит каждое полученное на консоль значение. Затем в примере в объект отправляется три значения `call` . Поскольку `call` объект обрабатывает сообщения в отдельном потоке, этот пример также использует переменную счетчика и объект [события](../../parallel/concrt/reference/event-class.md) , чтобы убедиться, что `call` объект обрабатывает все сообщения перед `wmain` возвратом функции.

[!code-cpp[concrt-call-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_4.cpp)]

В этом примере выводятся следующие данные:

```Output
334455
```

Полный пример, демонстрирующий использование `call` класса, см. в разделе [как предоставить рабочие функции классам Call и transformer](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md).

[[Top](#top)]

## <a name="transformer-class"></a><a name="transformer"></a>Класс transformer

Класс [Concurrency:: transformer](../../parallel/concrt/reference/transformer-class.md) выступает в качестве получателя сообщения и отправителя сообщения. `transformer`Класс напоминает `call` класс, так как он выполняет определяемую пользователем рабочую функцию при получении данных. Однако `transformer` класс также отправляет результат рабочей функции объектам получателя. Как и `call` объект, `transformer` объект работает параллельно с другими компонентами, которые отправляют в него сообщения. Если `transformer` объект выполняет работу при получении сообщения, он добавляет это сообщение в очередь. Каждый `transformer` объект обрабатывает сообщения в очереди в том порядке, в котором они получены.

`transformer`Класс отправляет свое сообщение одному целевому объекту. Если `_PTarget` для параметра в конструкторе задано значение `NULL` , можно позднее указать целевой объект, вызвав метод [concurrency:: link_target](reference/source-block-class.md#link_target) .

В отличие от всех других асинхронных типов блоков сообщений, предоставляемых библиотекой агентов, `transformer` класс может работать с различными типами входных и выходных данных. Эта возможность преобразования данных из одного типа в другой делает `transformer` класс ключевым компонентом во многих одновременных сетях. Кроме того, в функцию работы объекта можно добавить более детализированные параллельные функции `transformer` .

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `transformer` классом. В этом примере создается `transformer` объект, который является кратным каждому входному **`int`** значению на 0,33, чтобы получить **`double`** значение в качестве выходных данных. Затем пример получает преобразованные значения из того же `transformer` объекта и выводит их на консоль.

[!code-cpp[concrt-transformer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_5.cpp)]

В этом примере выводятся следующие данные:

```Output
10.8914.5218.15
```

Полный пример, демонстрирующий использование `transformer` класса, см. в разделе [как использовать преобразователь в конвейере данных](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md).

[[Top](#top)]

## <a name="choice-class"></a><a name="choice"></a>Класс choice

Класс [Concurrency:: Choice](../../parallel/concrt/reference/choice-class.md) выбирает первое доступное сообщение из набора источников. `choice`Класс представляет механизм потока управления вместо механизма потока данных (в разделе [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) описываются различия между потоком данных и потоком управления).

Чтение из объекта Choice напоминает вызов функции Windows API, `WaitForMultipleObjects` Если `bWaitAll` для параметра задано значение `FALSE` . Однако `choice` класс привязывает данные к самому событию, а не к внешнему объекту синхронизации.

Как правило, класс используется `choice` вместе с функцией [Concurrency:: Receive](reference/concurrency-namespace-functions.md#receive) , чтобы управлять потоком управления в приложении. Используйте `choice` класс, если нужно выбрать несколько буферов сообщений с разными типами. Используйте `single_assignment` класс, если нужно выбрать один из буферов сообщений с одинаковым типом.

Порядок связывания источников с `choice` объектом важен, так как он может определить, какое сообщение выбрано. Например, рассмотрим случай, когда вы связываете несколько буферов сообщений, которые уже содержат сообщение, в `choice` объект. `choice`Объект выбирает сообщение из первого связанного с ним источника. После связывания всех источников `choice` объект сохраняет порядок, в котором каждый источник получает сообщение.

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `choice` классом. В этом примере используется функция [Concurrency:: make_choice](reference/concurrency-namespace-functions.md#make_choice) для создания `choice` объекта, который выбирает один из трех блоков сообщений. Затем в примере вычисляются различные числа Фибоначчи и каждый результат сохраняется в другом блоке сообщений. Затем пример выводит на консоль сообщение, основанное на операции, которая завершилась первой.

[!code-cpp[concrt-choice-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_6.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
fib35 received its value first. Result = 9227465
```

Поскольку задача, вычисляющая 35-<sup>й</sup> номер Фибоначчи, не гарантированно завершается первым, выходные данные этого примера могут различаться.

В этом примере используется алгоритм [arallel_invoke Concurrency::p](reference/concurrency-namespace-functions.md#parallel_invoke) для параллельного расчета чисел Фибоначчи. Дополнительные сведения о `parallel_invoke` см. в разделе [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

Полный пример, демонстрирующий использование `choice` класса, см. в разделе [практические руководства. Выбор между завершенными задачами](../../parallel/concrt/how-to-select-among-completed-tasks.md).

[[Top](#top)]

## <a name="join-and-multitype_join-classes"></a><a name="join"></a>Классы присоединений и multitype_join

Классы [Concurrency:: Join](../../parallel/concrt/reference/join-class.md) и [concurrency:: multitype_join](../../parallel/concrt/reference/multitype-join-class.md) позволяют ожидать, пока каждый член набора источников получит сообщение. `join`Класс работает с объектами-источниками, имеющими общий тип сообщений. `multitype_join`Класс работает с объектами-источниками, которые могут иметь различные типы сообщений.

Чтение из `join` объекта или `multitype_join` напоминает вызов функции Windows API, `WaitForMultipleObjects` Если `bWaitAll` для параметра задано значение `TRUE` . Однако, как `choice` и объект, `join` и `multitype_join` объекты используют механизм событий, который привязывает данные к самому событию, а не к внешнему объекту синхронизации.

При чтении из `join` объекта создается объект std::[vector](../../standard-library/vector-class.md) . При чтении из `multitype_join` объекта создается объект std::[Tuple](../../standard-library/tuple-class.md) . Элементы отображаются в этих объектах в том же порядке, в котором соответствующие исходные буферы связаны с `join` объектом или `multitype_join` . Так как порядок, в котором исходные буферы связываются с `join` `multitype_join` объектом или, связан с порядком элементов в результирующем `vector` объекте или `tuple` , рекомендуется не отменять связь существующего исходного буфера с соединением. Это может привести к неопределенному поведению.

### <a name="greedy-versus-non-greedy-joins"></a>Жадные и нежадные объединения

`join`Классы и `multitype_join` поддерживают концепцию жадных и нежадных соединений. *Жадное соединение* принимает сообщение от каждого из его источников по мере того, как сообщения становятся доступными до тех пор, пока не будет доступно все сообщение. *Нежадное соединение* получает сообщения в два этапа. Во-первых, нежадное соединение ждет, пока не будет предложено сообщение от каждого из его источников. Во-вторых, после того, как все исходные сообщения будут доступны, нежадное соединение попытается зарезервировать каждое из этих сообщений. Если он может зарезервировать каждое сообщение, он потребляет все сообщения и распространяет их на целевой объект. В противном случае он выдает или отменяет, что зарезервированные сообщения и еще раз ожидают, пока каждый источник получит сообщение.

Жадные объединения работают лучше, чем нежадные объединения, так как они принимают сообщения немедленно. Однако в редких случаях жадные объединения могут привести к взаимоблокировкам. Используйте нежадное соединение при наличии нескольких соединений, содержащих один или несколько объектов с общим исходным кодом.

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `join` классом. В этом примере используется функция [Concurrency:: make_join](reference/concurrency-namespace-functions.md#make_join) для создания `join` объекта, который получает от трех `single_assignment` объектов. Этот пример выполняет вычисление различных чисел Фибоначчи, сохраняет каждый результат в другом `single_assignment` объекте, а затем выводит на консоль каждый результат, который `join` содержит объект. Этот пример похож на пример для `choice` класса, за исключением того, что `join` класс ожидает получения сообщения всеми блоками исходного сообщения.

[!code-cpp[concrt-join-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_7.cpp)]

В этом примере выводятся следующие данные:

```Output
fib35 = 9227465fib37 = 24157817half_of_fib42 = 1.33957e+008
```

В этом примере используется алгоритм [arallel_invoke Concurrency::p](reference/concurrency-namespace-functions.md#parallel_invoke) для параллельного расчета чисел Фибоначчи. Дополнительные сведения о `parallel_invoke` см. в разделе [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

Полные примеры, демонстрирующие использование `join` класса, см. в разделе [Практическое руководство. выбор среди завершенных задач](../../parallel/concrt/how-to-select-among-completed-tasks.md) и [Пошаговое руководство. использование Join для предотвращения взаимоблокировок](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md).

[[Top](#top)]

## <a name="timer-class"></a><a name="timer"></a>Класс Timer

Класс Concurrency::[Timer](../../parallel/concrt/reference/timer-class.md) выступает в качестве источника сообщения. `timer`Объект отправляет сообщение целевому объекту по истечении указанного периода времени. `timer`Класс полезен в тех случаях, когда необходимо отложить отправку сообщения или необходимо отправить сообщение с постоянным интервалом.

`timer`Класс отправляет свое сообщение только одному целевому объекту. Если `_PTarget` для параметра в конструкторе задано значение `NULL` , можно позднее указать целевой объект, вызвав метод [Concurrency:: ISource:: link_target](reference/source-block-class.md#link_target) .

`timer`Объект может быть повторяющимся или неповторяющимся. Чтобы создать повторяющийся таймер, передайте **`true`** `_Repeating` параметр при вызове конструктора. В противном случае передайте **`false`** `_Repeating` параметр, чтобы создать неповторяющийся таймер. Если таймер повторяется, он отправляет то же самое сообщение целевому объекту после каждого интервала.

Библиотека агентов создает `timer` объекты в незапущенном состоянии. Чтобы запустить объект Timer, вызовите метод [Concurrency:: Timer:: Start](reference/timer-class.md#start) . Чтобы завершить работу `timer` объекта, удалите объект или вызовите метод [Concurrency:: Timer:: останавливаться](reference/timer-class.md#stop) . Чтобы приостановить повторяющийся таймер, вызовите метод [Concurrency:: Timer::p Аусе](reference/timer-class.md#pause) .

### <a name="example"></a>Пример

В следующем примере показана базовая структура работы с `timer` классом. В примере используются `timer` `call` объекты и для сообщения о ходе длительной операции.

[!code-cpp[concrt-timer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_8.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Computing fib(42)..................................................result is 267914296
```

Полный пример, демонстрирующий использование `timer` класса, см. в разделе [как отправить сообщение с регулярным интервалом](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md).

[[Top](#top)]

## <a name="message-filtering"></a><a name="filtering"></a>Фильтрация сообщений

При создании объекта блока сообщений можно указать *функцию фильтра* , которая определяет, будет ли блок сообщений принимать или отклонять сообщение. Функция фильтра — это удобный способ гарантировать, что блок сообщений получает только определенные значения.

В следующем примере показано, как создать `unbounded_buffer` объект, использующий функцию фильтра, чтобы принимать только четные числа. `unbounded_buffer`Объект отклоняет нечетные числа и, следовательно, не распространяет нечетные числа в целевые блоки.

[!code-cpp[concrt-filter-function#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_9.cpp)]

В этом примере выводятся следующие данные:

```Output
0 2 4 6 8
```

Функция фильтра может быть лямбда-функцией, указателем функции или объектом функции. Каждая функция фильтра принимает одну из следующих форм.

```Output
bool (T)
bool (T const &)
```

Чтобы исключить ненужное копирование данных, используйте вторую форму при наличии статистического типа, распространяемого по значению.

Фильтрация сообщений поддерживает модель программирования *DataFlow* , в которой компоненты выполняют вычисления при получении данных. Примеры использования функций фильтров для управления потоком данных в сети передачи сообщений см. [в разделе Практическое руководство. Использование фильтра блоков сообщений](../../parallel/concrt/how-to-use-a-message-block-filter.md), [Пошаговое руководство. Создание агента потока](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)данных и [Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

[[Top](#top)]

## <a name="message-reservation"></a><a name="reservation"></a>Резервирование сообщений

*Резервирование сообщений* позволяет блоку сообщений резервировать сообщение для последующего использования. Как правило, резервирование сообщений не используется напрямую. Тем не менее, сведения о резервировании сообщений помогут лучше понять поведение некоторых предопределенных типов блоков сообщений.

Рассмотрите возможность нежадных и жадных соединений. Оба они используют резервирование сообщений для резервирования сообщений для последующего использования. Как было сказано ранее, нежадное соединение получает сообщения в два этапа. На первом этапе нежадный `join` объект ожидает получения сообщения каждым из его источников. Затем нежадное соединение пытается зарезервировать каждое из этих сообщений. Если он может зарезервировать каждое сообщение, он потребляет все сообщения и распространяет их на целевой объект. В противном случае он выдает или отменяет, что зарезервированные сообщения и еще раз ожидают, пока каждый источник получит сообщение.

Жадное соединение, которое также считывает входные сообщения из нескольких источников, использует резервирование сообщений для чтения дополнительных сообщений, пока оно ожидает получения сообщения от каждого источника. Например, рассмотрим жадное соединение, которое получает сообщения от блоков сообщений `A` и `B` . Если жадное соединение получает два сообщения от B, но еще не получило сообщение от `A` , то жадное соединение сохраняет уникальный идентификатор сообщения для второго сообщения из `B` . После того как жадное соединение получает сообщение от `A` и распространяет эти сообщения, оно использует сохраненный идентификатор сообщения, чтобы проверить, доступно ли второе сообщение из `B` .

Резервирование сообщений можно использовать при реализации пользовательских типов блоков сообщений. Пример создания пользовательского типа блока сообщений см. в разделе [Пошаговое руководство. Создание пользовательского блока сообщений](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md).

[[Top](#top)]

## <a name="see-also"></a>См. также раздел

[библиотеку асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)
