---
title: "Параллелизм задач (среда выполнения с параллелизмом) | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "группы структурированных задач [среда выполнения с параллелизмом]"
  - "структурированные задачи [среда выполнения с параллелизмом]"
  - "группы задач [среда выполнения с параллелизмом]"
  - "параллелизм задач"
  - "задачи [среда выполнения с параллелизмом]"
ms.assetid: 42f05ac3-2098-494a-ba84-737fcdcad077
caps.latest.revision: 56
caps.handback.revision: 56
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# Параллелизм задач (среда выполнения с параллелизмом)
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

В среде выполнения с параллелизмом *Задача* — это единица работы, которая выполняет конкретное задание и обычно выполняется параллельно с другими задачами. Задачи, которые можно разложить на дополнительные, более мелкие задачи, которые упорядочены по *Группа задач*.  
  
 Задачи используются, когда при создании асинхронного кода требуется, чтобы после завершения асинхронной операции выполнялись некоторые операции. Например, можно использовать задачи для асинхронного чтения из файла и затем использовать другой задачи — *задача продолжения*, это объясняется далее в этом документе, для обработки данных, когда он станет доступным. И наоборот, можно использовать группы задач для разбиения параллельной работы на более мелкие части. Например, предположим, что имеется рекурсивный алгоритм, разделяющий оставшуюся работу на два раздела. С помощью групп задач вы можете одновременно запустить эти разделы, а затем подождать, пока выполнится эта разделенная задача.  
  
> [!TIP]
>  Если вы хотите применить ту же процедуру для каждого элемента коллекции параллельно, использовать параллельный алгоритм, например [concurrency::parallel_for](../Topic/parallel_for%20Function.md), вместо задача или группа задач. Дополнительные сведения об алгоритмах параллельной обработки см. в разделе [Параллельные алгоритмы](../Topic/Parallel%20Algorithms.md).  
  
## <a name="key-points"></a>Ключевые моменты  
  
-   При передаче переменных в лямбда-выражение по ссылке необходимо обеспечить сохранение существования этой переменной до завершения задачи.  
  
-   Использование задач ( [concurrency::task](../../parallel/concrt/reference/task-class-concurrency-runtime.md) класса) при написании асинхронного кода. Класс задач использует в качестве своего планировщика Windows ThreadPool (пул потоков Windows), а не среду выполнения с параллелизмом.  
  
-   Использование групп задач ( [concurrency::task_group](../Topic/task_group%20Class.md) класса или [concurrency::parallel_invoke](../Topic/parallel_invoke%20Function.md) алгоритма) Если требуется декомпозиции параллельной работы на более мелкие части, а затем подождите, пока эти меньшие части для выполнения.  
  
-   Используйте [Concurrency::Task:: Then](../Topic/task::then%20Method.md) метод для создания продолжений. A *продолжения* Задача, которая выполняется асинхронно после завершения другой задачи. Вы можете подключать любое количество продолжений для формирования цепочки асинхронной работы.  
  
-   Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение.  
  
-   Используйте [параллелизма:: ГИПЕРССЫЛКА «http://msdn.microsoft.com/library/system.threading.tasks.task.whenall (v=VS.110).aspx» when_all](../Topic/when_all%20Function.md) для создания задачи, которая выполняется после завершения каждого элемента списка задач. Используйте [concurrency::when_any](../Topic/when_all%20Function.md) для создания задачи, которая выполняется после завершения один член набора задач.  
  
-   Задачи и группы задач могут участвовать в механизме отмены библиотеки параллельных шаблонов (PPL). Дополнительные сведения см. в разделе [отмены](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md#cancellation_in_the_ppl).  
  
-   Чтобы узнать, как среда выполнения обрабатывает исключения, вызываемые задач и групп задач, см. раздел [Обработка исключений](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md).  
  
## <a name="in-this-document"></a>В этом документе  
  
- [Использование лямбда-выражения](#lambdas)  
  
- [Класс task](#task-class)  
  
- [Задачи продолжения](#continuations)  
  
- [Основанное на значении сравнение продолжения на основе задач](#value-versus-task)  
  
- [Составление задач](#composing-tasks)  
  
    - [Функция when_all](#when-all)  
  
    - [Функция when_any](#when-any)  
  
- [Отложенное выполнение задач](#delayed-tasks)  
  
- [Группы задач](#task-groups)  
  
- [Сравнение task_group для structured_task_group](#comparing-groups)  
  
- [Пример](#example)  
  
- [Надежное программирование](#robust)  
  
##  <a name="a-namelambdasa-using-lambda-expressions"></a><a name="lambdas"></a> Использование лямбда-выражения  
 Благодаря их лаконичному синтаксису лямбда-выражения часто используют для определения операций, выполняемых задачами и группами задач. Ниже приведены некоторые советы по использованию.  
  
-   Поскольку задачи обычно выполняются в фоновых потоках, помните о времени существования объекта при включении переменных в лямбда-выражения. При вводе переменной по значению в тексте лямбда-выражения создается копия этой переменной. При вводе по ссылке копия не создается. Следовательно, необходимо убедиться, что время существования любой введенной по ссылке переменной превышает время существования задачи, которая ее использует.  
  
-   При передаче лямбда-выражения в задачу не вводите переменные, которые размещаются в стеке, по ссылке.  
  
-   Четко формулируйте ввод переменных в лямбда-выражения, чтобы можно было определить, как введена переменная — по значению или по ссылке. По этой причине рекомендуется не использовать параметры `[=]` или `[&]` для лямбда-выражений.  
  
 Распространенный подход заключается в том, что одна задача в цепочке продолжения назначает переменную, а другая задача читает эту переменную. В этом случае нельзя записывать переменную по значению, поскольку каждая задача продолжения будет содержать другую копию переменной. Для переменных, размещенных в стеке, также нельзя записывать переменную по ссылке, так как переменная может перестать быть действительной.  
  
 Чтобы решить эту проблему, используйте смарт-указатель, таких как [std::shared_ptr](../../standard-library/shared-ptr-class.md), чтобы переносить переменной и передавать интеллектуального указателя по значению. Таким образом этот базовый объект можно назначать и читать, и срок его существования будет превышать срок существования задач, которые его используют. Используйте этот метод даже в том случае, если переменная является указателем или дескриптором с подсчетом ссылок (`^`) объекта среды выполнения Windows. Ниже приводится базовый пример.  
  
 [!code-cpp[concrt-lambda-task-lifetime#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_1.cpp)]  
  
 Дополнительные сведения о лямбда-выражениях см. в разделе [лямбда-выражения](../../cpp/lambda-expressions-in-cpp.md).  
  
##  <a name="a-nametask-classa-the-task-class"></a><a name="task-class"></a> Класс task  
 Можно использовать [concurrency::task](../../parallel/concrt/reference/task-class-concurrency-runtime.md) класса для создания задачи в набор зависимых операций. Эта модель композиции поддерживается понятие *продолжения*. Продолжение включает код, выполняемый при предыдущей или *предшествующей задачи*, задача завершается. Результат предшествующей задачи передается в качестве входных данных в одну или несколько задач продолжения. По завершении предшествующей задачи все ожидающие ее задачи продолжения планируются для выполнения. Каждая задача продолжения получает копию результатов предшествующей задачи. В свою очередь, эти задачи продолжения также могут быть предшествующими задачами для других продолжений, тем самым создавая цепочки задач. Продолжения помогают создавать цепочки задач произвольной длины с определенными зависимостями между входящими в них задачами. Кроме того, задача может участвовать в отмене либо до запуска, либо совместно во время выполнения. Дополнительные сведения об этой модели отмены см. в разделе [отмены](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md#cancellation_in_the_ppl).  
  
 `task` является классом шаблона. Параметр типа `T` — это тип результата, созданного задачей. Это может быть тип `void`, если задача не возвращает значение. Параметр `T` не может использовать модификатор `const`.  
  
 При создании задачи необходимо указать *рабочей функции* выполняет тело задачи. Эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Ожидания для задачи без получения результат вызова [Concurrency::Task:: wait](../Topic/task::wait%20Method.md) метод.  `task::wait` Возвращает [concurrency::task_status](../Topic/task_group_status%20Enumeration.md) описывающее, является ли задача была завершена или отменена. Чтобы получить результат задачи, вызовите [Concurrency::Task:: Get](../Topic/task::get%20Method.md) метод. Этот метод вызывает метод `task::wait` для ожидания завершения задачи и таким образом блокирует выполнение текущего потока, пока не станет доступен результат.  
  
 В следующем примере показано, как создать задачу, дождаться ее результата и отобразить полученное значение. В примерах в этой документации используются лямбда-функции, поскольку они обеспечивают более лаконичный синтаксис. Однако при использовании задач вы также можете применять указатели функций и объекты функций.  
  
 [!code-cpp[concrt-basic-task#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_2.cpp)]  
  
 При использовании [concurrency::create_task](../Topic/create_task%20Function.md) функции, можно использовать `auto` ключевое слово вместо объявления типа. Например, рассмотрим следующий код, который создает и печатает матрицу тождественности.  
  
 [!code-cpp[concrt-create-task#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_3.cpp)]  
  
 Вы можете использовать функцию `create_task` для создания эквивалентной операции.  
  
 [!code-cpp[concrt-create-task#2](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_4.cpp)]  
  
 Если во время выполнения задачи возникает исключение, среда выполнения маршалирует исключение в последующий вызов метода `task::get` или `task::wait`, или в продолжение на основе задачи. Дополнительные сведения о механизме задачи обработки исключений в разделе [Обработка исключений](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md).  
  
 Пример, использующий `task`, [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md), отмены, в разделе [Пошаговое руководство: подключение с использованием задач и HTTP-запросов XML](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md). (Класс `task_completion_event` описывается далее в этом документе.)  
  
> [!TIP]
>  Чтобы получить сведения, относящиеся к задачам в [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] приложений, в разделе [асинхронное программирование в C++](http://msdn.microsoft.com/ru-ru/512700b7-7863-44cc-93a2-366938052f31) и [Создание асинхронных операций в C++ приложений для магазина Windows](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).  
  
##  <a name="a-namecontinuationsa-continuation-tasks"></a><a name="continuations"></a> Задачи продолжения  
 В асинхронном программировании очень распространено при завершении одной асинхронной операции вызывать вторую операцию и передавать в нее данные. Как правило, это делается с помощью методов обратного вызова. В среде выполнения с параллелизмом, обеспечивают те же функциональные возможности *задач продолжения*. Задача продолжения (также известная как продолжение) — это асинхронная задача, вызываемая другой задачей, которая называется *предшествующей задачи*, при ее завершении. С помощью продолжений вы можете делать следующее.  
  
-   Передавать данные из предшествующей задачи в продолжение.  
  
-   Указывать точные условия, при которых продолжение вызывается или не вызывается.  
  
-   Отменять продолжение перед его запуском либо совместно во время его выполнения.  
  
-   Определять подсказки, как должно планироваться продолжение. (Это относится только к приложениям [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)]. Дополнительные сведения см. в разделе [Создание асинхронных операций в C++ приложений для магазина Windows](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).)  
  
-   Вызывать несколько продолжений из одной и той же предшествующей задачи.  
  
-   Вызывать одно продолжение по завершении всех или одной из нескольких предшествующих задач.  
  
-   Прикреплять продолжения одно после другого до любой длины.  
  
-   Использовать продолжение для обработки исключений, вызванных предшествующей задачей.  
  
 Эти функции позволяют выполнять одну или несколько задач после завершения первой задачи. Например, можно создать продолжение, которое сжимает файл после того, как первая задача прочитает этот файл с диска.  
  
 В следующем примере изменяется предыдущий использовать [Concurrency::Task:: Then](../Topic/task::then%20Method.md) для планирования продолжение, которое выводится значение предшествующей задачи, если оно доступно.  
  
 [!code-cpp[concrt-basic-continuation#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_5.cpp)]  
  
 Вы можете прикреплять и вкладывать задачи до любой длины. Задача также может иметь несколько продолжений. В следующем примере демонстрируется базовая цепочка продолжений, которая увеличивает значение предыдущей задачи три раза.  
  
 [!CODE [concrt-continuation-chain#1](../CodeSnippet/VS_Snippets_ConcRT/concrt-continuation-chain#1)]  
  
 Продолжение может также возвращать другую задачу. Если отмена отсутствует, то эта задача выполняется до последующего продолжения. Этот прием называется *асинхронной расшифровки*. Асинхронное развертывание удобно использовать, когда требуется выполнить дополнительную работу в фоновом режиме, но так, чтобы текущая задача не блокировала текущий поток. (Обычно это происходит в приложениях [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], где продолжения могут запускаться в потоке пользовательского интерфейса.) В следующем примере показаны три задачи. Первая задача возвращает вторую задачу, которая выполняется перед задачей продолжения.  
  
 [!code-cpp[concrt-async-unwrapping#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_6.cpp)]  
  
> [!IMPORTANT]
>  Когда продолжение задачи возвращает вложенную задачу типа `N`, результирующая задача имеет тип `N`, а не `task<N>`, и завершается при завершении вложенной задачи. Другими словами, продолжение выполняет развертывание вложенной задачи.  
  
##  <a name="a-namevalue-versus-taska-value-based-versus-task-based-continuations"></a><a name="value-versus-task"></a> Основанное на значении сравнение продолжения на основе задач  
 Принимая во внимание объект `task`, который имеет возвращаемый тип `T`, вы можете предоставить значение типа `T` или `task<T>` в соответствующие задачи продолжения. Продолжение, которое принимает тип `T` называется *Продолжение на основе значения*. Продолжение на основе значения планируется для выполнения, когда предшествующая задача завершается без ошибок и не отменяется. Продолжение, которое принимает тип `task<T>` как его параметр называется *на основе задач продолжения*. Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение. Затем можно вызвать `task::get`, чтобы получить результат предшествующей задачи. Если предшествующая задача отменена, `task::get` вызывает [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). Если предшествующая задача выдала исключение, `task::get` повторно выдает это исключение. Продолжение на основе задачи не отмечается как отмененное, когда отменяется предшествующая задача.  
  
##  <a name="a-namecomposing-tasksa-composing-tasks"></a><a name="composing-tasks"></a> Составление задач  
 В этом разделе описываются [concurrency::when_all](../Topic/when_all%20Function.md) и [concurrency::when_any](../Topic/when_all%20Function.md) функций, которые помогут вам создать ряд задач для реализации общих шаблонов.  
  
###  <a name="a-namewhen-alla-the-whenall-function"></a><a name="when-all"></a> Функция when_all  
 Функция `when_all` создает задачу, которая выполняется после завершения набора задач. Эта функция возвращает std::[вектор](vector%20Class.md) объект, содержащий результат каждой задачи в наборе. В следующем базовом примере функция `when_all` используется для создания задачи, которая представляет завершение трех других задач.  
  
 [!code-cpp[concrt-join-tasks#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_7.cpp)]  
  
> [!NOTE]
>  Задачи, которые вы передаете в функцию `when_all`, должны быть единообразными. Другими словами, все они должны возвращать один и тот же тип.  
  
 Для создания задачи, выполняемой после завершения набора задач, можно также использовать синтаксис `&&`, как показано в следующем примере.  
  
 `auto t = t1 && t2; // same as when_all`  
  
 Обычно для выполнения действия после завершения набора задач используется продолжение вместе с функцией `when_all`. В следующем примере изменяется предыдущий пример для печати суммы трех задач, каждая из которых создает результат `int`.  
  
 [!code-cpp[concrt-join-tasks#2](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_8.cpp)]  
  
 В этом примере можно указать`task<vector<int>>` для создания на основе задач продолжения.  
  
 Если какая-либо из задач в наборе задач отменяется или порождает исключение, `when_all` немедленно завершается и не ждет завершения выполнения оставшихся задач. Если выдается исключение, среда выполнения повторно выдает это исключение при вызове `task::get` или `task::wait` в объекте задачи, который возвращает `when_all`. Если исключение выдают несколько задач, среда выполнения выбирает одну из них. Поэтому убедитесь, что вы заметили все исключения после завершения всех задач; необработанное исключение задачи приведет к завершению работы приложения.  
  
 Имеется служебная функция, которая позволяет убедиться, что программа обнаруживает все исключения. Для каждой задачи в указанном диапазоне эта служебная функция `observe_all_exceptions` запускает повторную выдачу каждого возникшего исключения, а затем поглощает это исключение.  
  
 [!code-cpp[concrt-eh-when_all#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_9.cpp)]  
  
 Рассмотрим приложение [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)], которое использует C++ и XAML и записывает ряд файлов на диск. В следующем примере показано, как использовать функции `when_all` и `observe_all_exceptions`, чтобы убедиться, что программа обнаруживает все исключения.  
  
 [!code-cpp[concrt-eh-when_all#2](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_10.cpp)]  
  
##### <a name="to-run-this-example"></a>Запуск примера  
  
1.  Добавьте в файл MainPage.xaml элемент управления `Button`.  
  
 [!code-xml[concrt-eh-when_all#3](../../parallel/concrt/codesnippet/Xaml/task-parallelism-concurrency-runtime_11.xaml)]  
  
2.  В MainPage.xaml.h добавьте в раздел `private` объявления класса `MainPage` следующие предваряющие объявления.  
  
 [!code-cpp[concrt-eh-when_all#4](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_12.h)]  
  
3.  В MainPage.xaml.cpp реализуйте обработчик событий `Button_Click`.  
  
 [!code-cpp[concrt-eh-when_all#5](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_13.cpp)]  
  
4.  В MainPage.xaml.cpp реализуйте `WriteFilesAsync`, как показано в примере.  
  
> [!TIP]
> Функция `when_all` является функцией без блокировки, в качестве результата создающей `task`. В отличие от [task::wait](../Topic/task::wait%20Method.md), безопасно вызывать данную функцию [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] приложения в потоке ASTA (STA приложения).  
  
###  <a name="a-namewhen-anya-the-whenany-function"></a><a name="when-any"></a> Функция when_any  
 Функция `when_any` создает задачу, которая выполняется после завершения первой задачи в наборе задач. Эта функция возвращает [std::pair](../../standard-library/pair-structure.md) объект, содержащий результат выполнения задачи и индекс этой задачи в наборе.  
  
 Функция `when_any` особенно полезна в следующих ситуациях.  
  
-   Избыточные операции. Рассмотрим алгоритм или операцию, которые можно выполнить несколькими способами. Функцию `when_any` можно использовать для выбора операции, которая завершается первой, и последующей отмены оставшихся операций.  
  
-   Операции с чередованием. Можно запустить несколько операций, которые все должны завершиться, и использовать функцию `when_any` для обработки результатов при завершении каждой операции. После завершения одной операции можно запустить одну или несколько дополнительных задач.  
  
-   Регулируемые операции. Функцию `when_any` можно использовать для расширения предыдущего сценария путем ограничения количества параллельных операций.  
  
-   Операции с истекшим сроком действия. Функцию `when_any` можно использовать, чтобы сделать выбор между одной или несколькими задачами и задачей, завершающейся после определенного времени.  
  
 Как и в случае с функцией `when_all`, обычно для выполнения действия после завершения первой задачи в наборе используется продолжение, имеющее функцию `when_any`. В следующем базовом примере функция `when_any` используется для создания задачи, которая выполняется после завершения первой из трех других задач.  
  
 [!code-cpp[concrt-select-task#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_14.cpp)]  
  
 В этом примере можно также указать `task<pair<int, size_t>>`, чтобы создать продолжение на основе задачи.  
  
> [!NOTE]
>  Как и при использовании функции `when_all`, задачи, которые вы передаете в `when_any`, должны возвращать один и тот же тип.  
  
 Для создания задачи, выполняемой после завершения первой задачи в наборе, можно также использовать синтаксис `||`, как показано в следующем примере.  
  
 `auto t = t1 || t2; // same as when_any`  
  
> [!TIP]
>  Как и `when_all`, функция `when_any` является функцией без блокировки, и ее можно безопасно вызывать в приложении [!INCLUDE[win8_appname_long](../../build/includes/win8_appname_long_md.md)] в потоке ASTA.  
  
##  <a name="a-namedelayed-tasksa-delayed-task-execution"></a><a name="delayed-tasks"></a> Отложенное выполнение задач  
 Иногда требуется отложить выполнение задачи до выполнения условия или запустить задачу в ответ на внешнее событие. Например, в асинхронном программировании может потребоваться запустить задачу в ответ на событие завершения операции ввода-вывода.  
  
 Это можно сделать двумя способами: использовать продолжение или запустить задачу и ожидать событие внутри рабочей функции задачи. Однако бывают случаи, когда невозможно использовать ни один из этих способов. Например, чтобы создать продолжение, необходимо иметь предшествующую задачу. Тем не менее, если у вас предшествующей задачи, можно создать *события завершения задачи* и позже цепочку этого события завершения предшествующей задачи, когда они станут доступны. Кроме того, поскольку ожидающая задача также блокирует поток, можно использовать события завершения задачи для выполнения работы при завершении асинхронной операции и тем самым освободить поток.  
  
  [Concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) класс помогает упростить такая композиция задач. Как и в классе `task`, параметр типа `T` — это тип результата, созданного задачей. Это может быть тип `void`, если задача не возвращает значение. Параметр `T` не может использовать модификатор `const`. Как правило, объект `task_completion_event` передается в поток или задачу, которые будут сообщать, когда значение для них станет доступным. В то же время одна или несколько задач устанавливаются в качестве прослушивателей этого события. Когда событие возникает, задачи прослушивателя выполняются и их продолжения планируются для запуска.  
  
 Пример, использующий `task_completion_event` реализовать задачу, которая выполняется после задержки, в разделе [как: создайте задачу, завершения после задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md).  
  
##  <a name="a-nametask-groupsa-task-groups"></a><a name="task-groups"></a> Группы задач  
 A *Группа задач* упорядочивает коллекцию задач. Группы задач помещают задачи в очередь перехвата работы. Планировщик удаляет задачи из этой очереди и выполняет их с использованием доступных вычислительных ресурсов. После добавления задач в группу задач можно ожидать завершения всех задач или отменить задачи, которые еще не запускались.  
  
 PPL использует [concurrency::task_group](../Topic/task_group%20Class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) классы, представляющие группы задач и [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) класс, представляющий задачи, которые выполняются в эти группы. Класс `task_handle` инкапсулирует код, выполняющий работу. Как и в случае класса `task`, эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Обычно не требуется работать с объектами `task_handle` напрямую. Вместо этого вы передаете рабочие функции в группу задач, а группа задач создает объекты `task_handle` и управляет ими.  
  
 PPL разделяет группы задач на эти две категории: *неструктурированные группы задач* и *структурированные группы задач*. PPL использует класс `task_group` для представления неструктурированных групп задач и класс `structured_task_group` — для представления структурированных групп задач.  
  
> [!IMPORTANT]
>  Библиотека PPL определяет также [concurrency::parallel_invoke](../Topic/parallel_invoke%20Function.md) алгоритм, который использует `structured_task_group` класса для параллельного выполнения набора задач. Поскольку алгоритм `parallel_invoke` имеет более лаконичный синтаксис, рекомендуется по возможности использовать его вместо класса `structured_task_group`. Раздел [Параллельные алгоритмы](../Topic/Parallel%20Algorithms.md) описывает `parallel_invoke` более подробно.  
  
 Используйте алгоритм `parallel_invoke`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, и перед продолжением необходимо дождаться завершения всех задач. Этот метод часто называют *разъединения и объединения* параллелизма. Используйте алгоритм `task_group`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, но дождаться завершения всех задач требуется позднее. Например, вы можете добавить задачи в объект `task_group` и дожидаться завершения этих задач в другой функции или из другого потока.  
  
 Группы задач поддерживают принцип отмены. Отмена позволяет сообщить всем активным задачам, что необходимо отменить всю операцию. Отмена также предотвращает запуск задач, которые еще не начали выполняться. Дополнительные сведения об отмене см. в разделе [отмены](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md#cancellation_in_the_ppl).  
  
 Среда выполнения также предоставляет модель обработки исключений, которая позволяет вызывать исключение из задачи и обработать это исключение при ожидании завершения группы связанных задач. Дополнительные сведения об этой модели обработки исключений см. в разделе [Обработка исключений](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md).  
  
##  <a name="a-namecomparing-groupsa-comparing-taskgroup-to-structuredtaskgroup"></a><a name="comparing-groups"></a> Сравнение task_group для structured_task_group  
 Несмотря на то что мы рекомендуем использовать `task_group` или `parallel_invoke` вместо класса `structured_task_group`, бывают ситуации, в которых вы захотите использовать класс `structured_task_group`, например при создании параллельного алгоритма, который выполняет переменное количество задач или которому требуется поддержка отмены. В этом разделе описываются различия между классами `task_group` и `structured_task_group`.  
  
 Класс `task_group` является потокобезопасным. Поэтому можно добавлять задачи в объект `task_group` из нескольких потоков и ожидать или отменять объект `task_group` из нескольких потоков. Создание и уничтожение объекта `structured_task_group` должно происходить в одной лексической области. Кроме того, все операции с объектом `structured_task_group` должны происходить в одном потоке. Исключением из этого правила является [Concurrency::structured_task_group:: Cancel](../Topic/structured_task_group::cancel%20Method.md) и [concurrency::structured_task_group::is_canceling](../Topic/structured_task_group::is_canceling%20Method.md) методы. Дочерняя задача может вызывать эти методы для отмены родительской группы задач или проверки на предмет отмены в любое время.  
  
 Можно выполнить дополнительные задачи `task_group` объекта после вызова [Concurrency::task_group:: wait](../Topic/task_group::wait%20Method.md) или [Concurrency::task_group:: run_and_wait](../Topic/task_group::run_and_wait%20Method.md) метод. И наоборот Если выполнить дополнительные задачи `structured_task_group` объекта после вызова [Concurrency::structured_task_group:: wait](../Topic/structured_task_group::wait%20Method.md) или [Concurrency::structured_task_group:: run_and_wait](../Topic/structured_task_group::run_and_wait%20Method.md) методов, то поведение не определено.  
  
 Поскольку класс `structured_task_group` не синхронизируется в потоках, он имеет меньше затрат на выполнение, чем класс `task_group`. Таким образом, если проблема не требует планирования работы в нескольких потоках и нельзя использовать алгоритм `parallel_invoke`, класс `structured_task_group` класс может помочь написать более производительный код.  
  
 При использовании одного объекта `structured_task_group` внутри другого объекта `structured_task_group` внутренний объект должен быть завершен и уничтожен до завершения внешнего объекта. Класс `task_group` не требуется для завершения вложенных групп задач до завершения внешней группы.  
  
 Неструктурированные группы задач и структурированные группы задач работают с дескрипторами задач по-разному. Вы можете передавать рабочие функции непосредственно в объект `task_group`; объект `task_group` будет создавать дескриптор задач и управлять им. Класс `structured_task_group` требует, чтобы вы управляли объектом `task_handle` для каждой задачи. Каждый объект `task_handle` должен оставаться допустимым в течение всего времени существования связанного объекта `structured_task_group`. Используйте [concurrency::make_task](../Topic/make_task%20Function.md) функцию для создания `task_handle` объекта, как показано в следующем примере:  
  
 [!code-cpp[concrt-make-task-structure#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_15.cpp)]  
  
 Чтобы управлять дескрипторами задач в случае, когда имеется переменное число задач, использовать подпрограммы выделение стека, например [_malloca](../../c-runtime-library/reference/malloca.md) или класс контейнера, например, std::[вектор](vector%20Class.md).  
  
 И `task_group`, и `structured_task_group` поддерживают отмену. Дополнительные сведения об отмене см. в разделе [отмены](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md#cancellation_in_the_ppl).  
  
##  <a name="a-nameexamplea-example"></a><a name="example"></a> Пример  
 В следующем базовом примере показано, как работать с группами задач. В этом примере используется алгоритм `parallel_invoke` для выполнения двух задач одновременно. Каждая задача добавляет подзадачи в объект `task_group`. Обратите внимание, что класс `task_group` позволяет добавлять в него задачи одновременно нескольким задачам.  
  
 [!code-cpp[concrt-using-task-groups#1](../../parallel/concrt/codesnippet/CPP/task-parallelism-concurrency-runtime_16.cpp)]  
  
 Ниже приведен пример выходных данных для данного примера.  
  
```Output  
Message from task: Hello  
Message from task: 3.14  
Message from task: 42  
```  
  
 Поскольку алгоритм `parallel_invoke` выполняет задачи параллельно, порядок выходных сообщений может меняться.  
  
 Полные примеры, которые демонстрируют использование `parallel_invoke` алгоритм, см. [Практическое руководство: использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) и [как: использование функции parallel_invoke для выполнения параллельных операций](../Topic/How%20to:%20Use%20parallel_invoke%20to%20Execute%20Parallel%20Operations.md). Полный пример, использующий `task_group` класса для реализации асинхронных фьючерсов см. в разделе [Пошаговое руководство: реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md).  
  
##  <a name="a-namerobusta-robust-programming"></a><a name="robust"></a> Надежное программирование  
 Убедитесь, что понимаете роль отмены и обработки исключений при использовании задач, групп задач и параллельных алгоритмов. Например, в дереве параллельной работы отмененная задача предотвращает запуск дочерних задач. Это может вызвать проблемы, если одна из дочерних задач выполняет операцию, важную для приложения, например высвобождает ресурс. Кроме того, если дочерняя задача создает исключение, это исключение может распространиться через деструктор объекта и вызвать неопределенное поведение в приложении. Пример, иллюстрирующий эти случаи см. в разделе [понимание как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) раздела рекомендации в документе библиотеки параллельных шаблонов. Дополнительные сведения об отмене и модели обработки исключений в PPL см. в разделе [отмены](../../parallel/concrt/cancellation-in-the-ppl.md) и [обработку исключений](../Topic/Exception%20Handling%20in%20the%20Concurrency%20Runtime.md).  
  
## <a name="related-topics"></a>Связанные разделы  
  
|Заголовок|Описание|  
|-----------|-----------------|  
|[Практическое руководство: использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|  
|[Практическое руководство: использование функции parallel_invoke для выполнения параллельных операций](../Topic/How%20to:%20Use%20parallel_invoke%20to%20Execute%20Parallel%20Operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|  
|[Практическое руководство: Создание задачи, выполняемой после задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)|Показано, как использовать `task`, `cancellation_token_source`, `cancellation_token`, и `task_completion_event` классы для создания задачи, выполняемой после задержки.|  
|[Пошаговое руководство: Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md)|Показано, как объединить существующие функциональные возможности в среде выполнения с параллелизмом в то, что делает больше.|  
|[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывается библиотека PPL, которая предоставляет императивную модель программирования для разработки параллельных приложений.|  
  
## <a name="reference"></a>Ссылка  
 [Класс Task (среда выполнения параллелизма)](../../parallel/concrt/reference/task-class-concurrency-runtime.md)  
  
 [Класс task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md)  
  
 [Функция when_all](../Topic/when_all%20Function.md)  
  
 [Функция when_any](../Topic/when_any%20Function.md)  
  
 [Класс task_group](../Topic/task_group%20Class.md)  
  
 [Функция parallel_invoke](../Topic/parallel_invoke%20Function.md)  
  
 [Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)
