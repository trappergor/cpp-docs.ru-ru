---
title: Отмена в PPL | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-concrt
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- parallel algorithms, canceling [Concurrency Runtime]
- canceling parallel algorithms [Concurrency Runtime]
- parallel tasks, canceling [Concurrency Runtime]
- cancellation in the PPL
- parallel work trees [Concurrency Runtime]
- canceling parallel tasks [Concurrency Runtime]
ms.assetid: baaef417-b2f9-470e-b8bd-9ed890725b35
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 17babc058ef3e1851da686e9a8c5bf17cefbc2fd
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/19/2018
ms.locfileid: "46427008"
---
# <a name="cancellation-in-the-ppl"></a>Отмена в библиотеке параллельных шаблонов

В этом документе рассматривается роль отмены в библиотеке параллельных шаблонов (PPL), а также объясняется, как отменить параллельную работу и как определить, что параллельная работа отменена.

> [!NOTE]
>  Среда выполнения использует обработку исключений для реализации отмены. Не следует перехватывать или обрабатывать эти исключения в своем коде. Кроме того, рекомендуется писать безопасный в отношении исключений код в функциях для ваших задач. Например, можно использовать *Получение ресурса есть инициализация* шаблон (RAII) для обеспечения корректной обработки ресурсов при возникновении исключения в теле задачи. Полный пример, использующий шаблон RAII для очистки ресурса в задаче с возможностью отмены, см. в разделе [Пошаговое руководство: удаление задач из потока пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md).

## <a name="key-points"></a>Ключевые моменты

- Отмена выполняется совместно и обеспечивает координацию между кодом, запрашивающим отмену запросов, и задачей, которая отвечает за отмену.

- Если возможно, используйте токены отмены, чтобы отменить работу. [Concurrency::cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) класс определяет токен отмены.

- При использовании токенов отмены используйте [Concurrency::cancellation_token_source:: Cancel](reference/cancellation-token-source-class.md#cancel) метод, чтобы инициировать отмену и [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) функции реагировать на Отмена. Используйте [Concurrency::cancellation_token:: is_canceled](reference/cancellation-token-class.md#is_canceled) метод для проверки, запросил ли любой другой задаче отмены.

- Отмена не происходит немедленно. Хотя новая работа не запускается, если задача или группа задач отменяются, выполняющаяся работа должна выполнить проверку и отреагировать на отмену.

- Продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи. Продолжение на основе задачи никогда не наследует токен своей предшествующей задачи.

- Используйте [concurrency::cancellation_token:: none](reference/cancellation-token-class.md#none) метод при вызове конструктора или функции, которая принимает `cancellation_token` объект, но, чтобы операция поддерживала отмену. Кроме того Если вы не передаете токен отмены, который [concurrency::task](../../parallel/concrt/reference/task-class.md) конструктор или [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) функции, эта задача не будет поддерживать отмену.

##  <a name="top"></a> В этом документе

- [Деревья параллельной работы](#trees)

- [Отмена параллельных задач](#tasks)

    - [Использование токена отмены для отмены параллельной работы](#tokens)

    - [С помощью метода cancel для отмены параллельной работы](#cancel)

    - [Использование исключений для отмены параллельной работы](#exceptions)

- [Отмена параллельных алгоритмов](#algorithms)

- [Когда не следует использовать отмену](#when)

##  <a name="trees"></a> Деревья параллельной работы

В PPL для управления детализированными задачами и вычислениями используются задачи и группы задач. Можно вложить группы задач для формирования *деревьев* параллельной работы. На следующем рисунке показано дерево параллельной работы. На этом рисунке `tg1` и `tg2` представляют группы задач; `t1`, `t2`, `t3`, `t4` и `t5` представляют работы, которые выполняют группы задач.

![Дерево параллельной работы](../../parallel/concrt/media/parallelwork_trees.png "parallelwork_trees")

В следующем примере показан код, который необходим для создания дерева на рисунке. В этом примере `tg1` и `tg2` являются [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) объектов; `t1`, `t2`, `t3`, `t4`, и `t5` являются [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) объектов.

[!code-cpp[concrt-task-tree#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_1.cpp)]

Можно также использовать [concurrency::task_group](reference/task-group-class.md) класса для создания подобного дерева работы. [Concurrency::task](../../parallel/concrt/reference/task-class.md) класс также поддерживает понятие дерева работы. Однако дерево `task` является деревом зависимостей. В дереве `task` следующие задания выполняются после текущих. В дереве группы задач внутренняя работа завершается до внешней работы. Дополнительные сведения о различиях между задачами и группами задач см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).

[[В начало](#top)]

##  <a name="tasks"></a> Отмена параллельных задач

Существует несколько способов отмены параллельной работы. Предпочтительный способ — использование токена отмены. Группы задач также поддерживают [Concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) метод и [Concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) метод. Еще один способ — создать исключение в теле рабочей функции задачи. Какой бы метод вы ни выбрали, нужно понимать, что отмена не происходит немедленно. Хотя новая работа не запускается, если задача или группа задач отменяются, выполняющаяся работа должна выполнить проверку и отреагировать на отмену.

Дополнительные примеры отмены параллельных задач см. в разделе [Пошаговое руководство: подключение с использованием задач и HTTP-запросов XML](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md), [как: использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md), и [как: использование Обработки исключений для выхода из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

###  <a name="tokens"></a> Использование токена отмены для отмены параллельной работы

Классы `task`, `task_group` и `structured_task_group` поддерживают отмену посредством использования токенов отмены. Библиотека PPL определяет [concurrency::cancellation_token_source](../../parallel/concrt/reference/cancellation-token-source-class.md) и [concurrency::cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) классы для этой цели. При использовании токена отмены, чтобы отменить работу, среда выполнения не запускает новую работу, которая подписывается на этот токен. Можно использовать уже active [is_canceled](../../parallel/concrt/reference/cancellation-token-class.md#is_canceled) функция-член для отслеживания токен отмены и остановки, когда это возможно.

Чтобы инициировать отмену, вызовите [Concurrency::cancellation_token_source:: Cancel](reference/cancellation-token-source-class.md#cancel) метод. Можно реагировать на отмену следующими способами.

- Для `task` объекты, используют [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) функции. `cancel_current_task` отменяет текущую задачу и любое ее продолжение, основанное на значении. (Он не отменяет отмену *маркера* связанный с задачей или ее продолжениями.)

- Для групп задач и параллельных алгоритмов, используйте [concurrency::is_current_task_group_canceling](reference/concurrency-namespace-functions.md#is_current_task_group_canceling) функцию, чтобы отследить отмену и как можно скорее вернуться из тела задачи, когда эта функция возвращает `true`. (Не вызывайте `cancel_current_task` из группы задач.)

В следующем примере показан первый базовый шаблон для отмены задачи. Тело задачи время от времени проверяет, нет ли отмены внутри цикла.

[!code-cpp[concrt-task-basic-cancellation#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_2.cpp)]

Функция `cancel_current_task` создает исключение, поэтому нет необходимости явно возвращаться из текущего цикла или функции.

> [!TIP]

>  Кроме того, можно вызвать [concurrency::interruption_point](reference/concurrency-namespace-functions.md#interruption_point) вместо функции `cancel_current_task`.

Необходимо вызвать `cancel_current_task` при реагировании на отмену, поскольку она переводит задачу в отмененное состояние. Если вы вернулись раньше вместо вызова `cancel_current_task`, операция переходит в состояние завершения, и все продолжения, основанные на значении, выполняются.

> [!CAUTION]
>  Никогда не вызывайте исключение `task_canceled` из своего кода. Вместо него вызовите метод `cancel_current_task`.

Когда задача завершается в отмененном состоянии, [Concurrency::Task:: Get](reference/task-class.md#get) вызывает метод [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). (И наоборот, [Concurrency::Task:: wait](reference/task-class.md#wait) возвращает [task_status::canceled](reference/concurrency-namespace-enums.md#task_group_status) и не создает исключение.) В следующем примере показано такое поведение для продолжения на основе задачи. Продолжение на основе задачи вызывается всегда, даже если предшествующая задача отменяется.

[!code-cpp[concrt-task-canceled#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_3.cpp)]

Поскольку продолжения, основанные на значении, наследуют токен их предшествующей задачи, если они не были созданы с явным токеном, продолжения немедленно входят в отмененное состояние, даже если предшествующая задача по-прежнему выполняется. Поэтому любое исключение, создаваемое предшествующей задачей после отмены, не распространяется задачам продолжения. Отмена всегда переопределяет состояние предшествующей задачи. Следующий пример похож на предыдущий, но показывает поведение продолжения, основанного на значении.

[!code-cpp[concrt-task-canceled#2](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_4.cpp)]

> [!CAUTION]

>  Если вы не передаете токен отмены, который `task` конструктор или [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) функции, эта задача не будет поддерживать отмену. Кроме того необходимо передать один и тот же токен отмены конструктору всех вложенных задач (т. е. задач, которые создаются в теле другой задачи), чтобы отменить все задачи одновременно.

Может понадобиться выполнить собственный код, когда токен отмены отменен. Например, если пользователь выбирает **отменить** кнопку в пользовательском интерфейсе для отмены операции, может отключить эту кнопку, пока пользователь запускает другую операцию. В следующем примере показано, как использовать [Concurrency::cancellation_token:: register_callback](reference/cancellation-token-class.md#register_callback) метод, чтобы зарегистрировать функцию обратного вызова, который выполняется, когда токен отмены отменяется.

[!code-cpp[concrt-task-cancellation-callback#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_5.cpp)]

Документ [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) объясняются различия между по значениям и на основе задач продолжения. Если не предоставить объект `cancellation_token` задаче продолжения, продолжение наследует токен отмены из предшествующей задачи следующими способами.

- Продолжение, основанное на значении, всегда наследует токен отмены предшествующей задачи.

- Продолжение на основе задач никогда не наследует токен отмены предшествующей задачи. Единственный способ сделать продолжение на основе задач отменяемым — явно передать токен отмены.

Эти поведения не изменяются из-за сбоя задачи (той, которая создает исключение). В этом случае продолжение на основе значения отменяется, а продолжение на основе задачи не отменяется.

> [!CAUTION]
>  Задача, которая создается внутри другой задачи (вложенная задача), не наследует токен отмены от родительской задачи. Только продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи.

> [!TIP]

>  Используйте [concurrency::cancellation_token:: none](reference/cancellation-token-class.md#none) метод при вызове конструктора или функции, которая принимает `cancellation_token` и объект, чтобы операция поддерживала отмену.

Также можно предоставить токен отмены конструктору объекта `task_group` или `structured_task_group`. Важным аспектом является то, что дочерние группы задач наследуют этот токен отмены. Пример, демонстрирующий эту концепцию с помощью [concurrency::run_with_cancellation_token](reference/concurrency-namespace-functions.md#run_with_cancellation_token) функции для вызова `parallel_for`, см. в разделе [Отмена параллельных алгоритмов](#algorithms) ниже в этом документ.

[[В начало](#top)]

#### <a name="cancellation-tokens-and-task-composition"></a>Токены отмены и композиция задач

[Concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) и [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) функции помогают объединять несколько задач для реализации общих шаблонов. В этом разделе описывается, как эти функции работают с токенами отмены.

Если предоставляется токен отмены для любой из функций `when_all` и `when_any`, эта функция отменяется, только если отменяется этот токен отмены, или одна из участвующих задач заканчивается в отмененном состоянии или создает исключение.

Функция `when_all` наследует токен отмены от каждой задачи, формирующей общую операцию, если ей не предоставляется токен отмены. Задача, возвращаемая из `when_all`, отменяется, если отменяется любой из этих токенов и хотя бы одна из участвующих задач еще не началась или выполняется. Такое же поведение наблюдается, когда одна из задач вызывает исключение - задачу, которая возвращается из `when_all` немедленно отменяется с этим исключением.

Среда выполнения выбирает токен отмены для задачи, которая возвращается из функции `when_any`, когда эта задача завершается. Если ни одна из участвующих задач не заканчивается в завершенном состоянии или одна или более задач создают исключение, одна из создавших исключение задач выбирается для выполнения `when_any`, а ее токен выбирается как токен для окончательной задачи. Если более чем одна задача заканчивается в завершенном состоянии, задача, возвращаемая `when_any`, заканчивается в завершенном состоянии. Среда выполнения пытается выбрать завершенную задачу, токен которой не отменяется во время завершения, чтобы задача, которая возвращается из `when_any`, не отменялась сразу же, даже если остальные выполняющиеся задачи могут завершиться позднее.

[[В начало](#top)]

###  <a name="cancel"></a> С помощью метода cancel для отмены параллельной работы

[Concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) и [Concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) методы задают для группы задач отмененное состояние. После вызова метода `cancel` группа задач не начинает выполнение следующих задач. Методы `cancel` могут вызываться несколькими дочерними задачами. Отмененная задача заставляет [Concurrency::task_group:: wait](reference/task-group-class.md#wait) и [Concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait) методам возвращать [concurrency::canceled](reference/concurrency-namespace-enums.md#task_group_status).

Если группа задач отменяется, вызовы из каждой дочерней задачи в среде выполнения могут инициировать *точку прерывания*, которая заставляет среду выполнения создавать и перехватывать тип внутреннего исключения для отмены активных задач. Среда выполнения с параллелизмом не определяет конкретные точки прерывания; они могут возникать в любом вызове среды выполнения. Среда выполнения должна обрабатывать исключения, которые она вызывает, чтобы выполнить отмену. Таким образом, не следует обрабатывать неизвестные исключения в теле задачи.

Если дочерняя задача выполняет длительную операцию и не выполняет вызовы, направленные в среду выполнения, необходимо периодически проверять ее для своевременной отмены и выхода. В следующем примере показывается один из способов определения, когда работа отменяется. Задача `t4` отменяет родительскую группу задач при обнаружении ошибки. Задача `t5` периодически вызывает метод `structured_task_group::is_canceling` для проверки отмены. Если родительская группа задач отменяется, задача `t5` выводит сообщение и завершает работу.

[!code-cpp[concrt-task-tree#6](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_6.cpp)]

В этом примере проверяется наличие отмены на каждые 100<sup>th</sup> итерации цикла задач. Частота, с которой выполняется проверка отмены, зависит от объема работы, выполняемой задачей, и того, как быстро задачи должны реагировать на отмену.

Если у вас нет доступа к объекту родительской группы задач, вызовите [concurrency::is_current_task_group_canceling](reference/concurrency-namespace-functions.md#is_current_task_group_canceling) функцию, чтобы определить, будет ли родительская группа задач отменяется.

Метод `cancel` влияет только на дочерние задачи. Например, если отменить группу задач `tg1`, показанную на рисунке дерева параллельной работы, будут затронуты все задачи в дереве (`t1`, `t2`, `t3`, `t4` и `t5`). Если отменить вложенную группу задач `tg2`, будут затронуты только задачи `t4` и `t5`.

При вызове метода `cancel` будут также отменены все дочерние группы задач. Однако отмена не повлияет ни на какие родительские объекты группы задач в дереве параллельной работы. В следующих примерах это демонстрируется с опорой на иллюстрацию дерева параллельной работы.

В первом из этих примеров создается рабочая функция для задачи `t4`, которая является дочерним элементом группы задач `tg2`. Эта рабочая функция вызывает функцию `work` в цикле. Если какой-либо вызов `work` завершается неудачно, задача отменяет свою родительскую группу задач. В результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.

[!code-cpp[concrt-task-tree#2](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_7.cpp)]

Второй пример аналогичен первому, но за тем исключением, что задача отменяет группу задач `tg1`. Это влияет на все задачи в дереве (`t1`, `t2`, `t3`, `t4` и `t5`).

[!code-cpp[concrt-task-tree#3](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_8.cpp)]

Класс `structured_task_group` не является потокобезопасным. Таким образом, дочерняя задача, которая вызывает метод своего родительского объекта `structured_task_group`, приводит к непредсказуемому поведению. Это правило не применяется `structured_task_group::cancel` и [Concurrency::structured_task_group:: is_canceling](reference/structured-task-group-class.md#is_canceling) методы. Дочерняя задача может вызывать эти методы для отмены родительской группы задач и проверки на предмет отмены.

> [!CAUTION]
>  Хотя можно использовать токен отмены, чтобы отменить работу, выполняемую группой задач, которая выполняется как дочерний элемент объекта `task`, невозможно использовать методы `task_group::cancel` или `structured_task_group::cancel`, чтобы отменить объекты `task`, выполняемые в группе задач.

[[В начало](#top)]

###  <a name="exceptions"></a> Использование исключений для отмены параллельной работы

Использование токенов отмены и метода `cancel` более эффективно, чем обработка исключений при отмене дерева параллельной работы. Токены отмены и метод `cancel` отменяют задачу и все дочерние задачи сверху вниз. Механизм обработки исключений, напротив, работает в режиме «снизу вверх», и каждую дочернюю группу задач приходится отменять независимо, поскольку исключение распространяется вверх. Раздел [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md) объясняется, как среда выполнения с параллелизмом использует исключения для сообщения об ошибках. Однако не все исключения указывают на ошибку. Например, алгоритм поиска может отменить связанную задачу при нахождении результата. Тем не менее, как упоминалось ранее, обработка исключений менее эффективна, чем использование метода `cancel` для отмены параллельной работы.

> [!CAUTION]
>  Рекомендуется использовать исключения для отмены параллельной работы только при необходимости. Токены отмены и методы `cancel` группы задач более эффективны и менее подвержены возникновению ошибок.

При создании исключения в теле рабочей функции, передаваемой в группу задач, среда выполнения сохраняет это исключение и маршалирует его в контекст, ожидающий завершения этой группы задач. Как и в случае использования метода `cancel`, среда выполнения удаляет любые задачи, которые еще не были запущены, и не принимает новые задачи.

Третий пример напоминает второй, за исключением того, что задача `t4` создает исключение для отмены группы задач `tg2`. В этом примере используется `try` - `catch` блок для проверки отмены когда группа задач `tg2` ожидает завершения своих дочерних задач. Как и в первом примере, в результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.

[!code-cpp[concrt-task-tree#4](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_9.cpp)]

В четвертом примере используется обработка исключений для отмены всего дерева работы. В этом примере перехватывается исключение, когда группа задач `tg1` ожидает завершения своих дочерних задач вместо группы задач `tg2`, ожидающей своих дочерних задач. Как и во втором примере, это приводит к переходу в отмененное состояние обеих групп задач в дереве, `tg1` и `tg2`.

[!code-cpp[concrt-task-tree#5](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_10.cpp)]

Так как методы `task_group::wait` и `structured_task_group::wait` вызываются, когда дочерняя задача создает исключение, вы не получите от них возвращаемое значение.

[[В начало](#top)]

##  <a name="algorithms"></a> Отмена параллельных алгоритмов

Параллельные алгоритмы в PPL (например, `parallel_for`) основаны на группах задач. Таким образом, многие из тех же способов можно использовать для для отмены параллельного алгоритма.

Следующие примеры иллюстрируют несколько способов отмены параллельного алгоритма.

В следующем примере функция `run_with_cancellation_token` используется для вызова алгоритма `parallel_for`. Функция `run_with_cancellation_token` принимает в качестве аргумента токен отмены и одновременно вызывает предоставленную рабочую функцию. Поскольку параллельные алгоритмы строятся на задачах, они наследуют токен отмены родительской задачи. Поэтому `parallel_for` может реагировать на отмену.

[!code-cpp[concrt-cancel-parallel-for#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_11.cpp)]

В следующем примере используется [Concurrency::structured_task_group:: run_and_wait](reference/structured-task-group-class.md#run_and_wait) метод для вызова `parallel_for` алгоритм. Метод `structured_task_group::run_and_wait` ожидает завершения предоставленной задачи. Объект `structured_task_group` позволяет рабочей функции отменить задачу.

[!code-cpp[concrt-task-tree#7](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_12.cpp)]

В этом примере формируются следующие данные:

```Output
The task group status is: canceled.
```

В следующем примере используется обработка исключений для отмены цикла `parallel_for`. Среда выполнения маршалирует исключение в вызывающий контекст.

[!code-cpp[concrt-task-tree#9](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_13.cpp)]

В этом примере формируются следующие данные:

```Output
Caught 50
```

В следующем примере используется логический флаг для координации отмены в цикле `parallel_for` Каждая задача выполняется, поскольку в этом примере не используется метод `cancel` или обработка исключений, чтобы отменить весь набор задач. Таким образом, этот метод может использовать больше вычислительных ресурсов, чем механизм отмены.

[!code-cpp[concrt-task-tree#8](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_14.cpp)]

Каждый метод отмены имеет свои преимущества по сравнению с другими. Выбирайте метод, который соответствует вашим конкретным требованиям.

[[В начало](#top)]

##  <a name="when"></a> Когда не следует использовать отмену

Использование отмены подходит в тех случаях, когда каждый член группы связанных задач может выполнить выход своевременно. Однако существуют некоторые сценарии, в которых отмена может не подойти для вашего приложения. Например, поскольку отмена задач осуществляется совместно, весь набор задач не будет отменен, если одна из задач заблокирована. Например, если одна задача еще не запущена, но разблокирует другую активную задачу, эта задача не запустится, если отменяется группа задач. Это может вызвать взаимоблокировку в приложении. Второй пример, когда использование отмены может не подойти: задача отменяется, но ее дочерняя задача выполняет важную операцию, например высвобождение ресурса. Так как при отмене родительской задачи отменяется весь набор задач, эта операция не будет выполнена. Пример, иллюстрирующий этот аспект, см. в разделе [Общие сведения о том, как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) статьи рекомендации в разделе библиотеки параллельных шаблонов.

[[В начало](#top)]

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Практическое руководство. Использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)|Показывается, как использовать отмену для реализации алгоритма параллельного поиска.|
|[Практическое руководство. Использование обработки исключений для выхода из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md)|Здесь приводятся способы использования класса `task_group` для записи алгоритма поиска для базовой структуры дерева.|
|[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)|В этом разделе описывается обработка в среде выполнения исключений, созданных группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.|
|[Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)|В этом разделе описывается, как задачи связаны с группами задач и как можно использовать структурированные и неструктурированные задачи в приложениях.|
|[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)|В этом разделе описываются параллельные алгоритмы, одновременно выполняющие работу с коллекциями данных.|
|[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)|Общие сведения о библиотеке параллельных задач.|

## <a name="reference"></a>Ссылка

[Класс task (среда выполнения с параллелизмом)](../../parallel/concrt/reference/task-class.md)

[Класс cancellation_token_source](../../parallel/concrt/reference/cancellation-token-source-class.md)

[Класс cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md)

[Класс task_group](reference/task-group-class.md)

[Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)

[Функция parallel_for](reference/concurrency-namespace-functions.md#parallel_for)

