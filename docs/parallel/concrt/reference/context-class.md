---
title: Класс контекста | Документация Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-concrt
ms.topic: reference
f1_keywords:
- Context
- CONCRT/concurrency::Context
- CONCRT/concurrency::Context::Block
- CONCRT/concurrency::Context::CurrentContext
- CONCRT/concurrency::Context::GetId
- CONCRT/concurrency::Context::GetScheduleGroupId
- CONCRT/concurrency::Context::GetVirtualProcessorId
- CONCRT/concurrency::Context::Id
- CONCRT/concurrency::Context::IsCurrentTaskCollectionCanceling
- CONCRT/concurrency::Context::IsSynchronouslyBlocked
- CONCRT/concurrency::Context::Oversubscribe
- CONCRT/concurrency::Context::ScheduleGroupId
- CONCRT/concurrency::Context::Unblock
- CONCRT/concurrency::Context::VirtualProcessorId
- CONCRT/concurrency::Context::Yield
dev_langs:
- C++
helpviewer_keywords:
- Context class
ms.assetid: c0d553f3-961d-4ecd-9a29-4fa4351673b8
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: a4a62f6e569e123b9612e922e2d7c70787371afc
ms.sourcegitcommit: 913c3bf23937b64b90ac05181fdff3df947d9f1c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2018
ms.locfileid: "46136183"
---
# <a name="context-class"></a>Класс Context
Представляет абстракцию для контекста выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```
class Context;
```  
  
## <a name="members"></a>Участники  
  
### <a name="protected-constructors"></a>Защищенные конструкторы  
  
|Имя|Описание|  
|----------|-----------------|  
|[~ Деструктор контекста](#dtor)||  
  
### <a name="public-methods"></a>Открытые методы  
  
|Имя|Описание|  
|----------|-----------------|  
|[Block](#block)|Блокирует текущий контекст.|  
|[CurrentContext](#currentcontext)|Возвращает указатель на текущий контекст.|  
|[GetId](#getid)|Возвращает идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.|  
|[GetScheduleGroupId](#getschedulegroupid)|Возвращает идентификатор для группы расписаний, контекст сейчас работает над.|  
|[GetVirtualProcessorId](#getvirtualprocessorid)|Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.|  
|[Id](#id)|Возвращает идентификатор для текущего контекста, который уникален в пределах планировщика, к которой принадлежит текущий контекст.|  
|[IsCurrentTaskCollectionCanceling](#iscurrenttaskcollectioncanceling)|Возвращает значение, указывающее, следует ли коллекция задач, которая выполняется в данный момент встроено в текущем контексте, в процессе активной отмены (или будет вскоре).|  
|[IsSynchronouslyBlocked](#issynchronouslyblocked)|Определяет, заблокирован ли контекст, синхронно. Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке.|  
|[Превысить предел подписок](#oversubscribe)|Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.|  
|[ScheduleGroupId](#schedulegroupid)|Возвращает идентификатор для группы расписаний, занимается текущего контекста.|  
|[Разблокировать](#unblock)|Разблокирует контекст и приводит к запуску.|  
|[VirtualProcessorId](#virtualprocessorid)|Возвращает идентификатор для виртуального процессора, исполняемой в текущем контексте.|  
|[Yield](#yield)|Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.|  
  
## <a name="remarks"></a>Примечания  
 Планировщик среды выполнения с параллелизмом (см. в разделе [планировщика](scheduler-class.md)) контекстов выполнения использует для выполнения работы в очереди на его в приложении. Поток Win32 является примером контекста выполнения в операционной системе Windows.  
  
 В любое время уровень параллелизма планировщика равно число виртуальных процессоров, предоставленные ему диспетчером ресурсов. Виртуальный процессор представляет собой абстракцию для обработки ресурсов и отображается в аппаратном потоке в базовой системе. В определенный момент времени только один контекст планировщика может выполняться на виртуальном процессоре.  
  
 Планировщик совместно по своей природе и выполняемый контекст может привести его виртуальный процессор в другом контексте в любое время, если он хочет перейдет в состояние ожидания. При удовлетворении его ожидания, его нельзя возобновить, пока доступный виртуальный процессор из планировщика не начнет его выполнения.  
  
## <a name="inheritance-hierarchy"></a>Иерархия наследования  
 `Context`  
  
## <a name="requirements"></a>Требования  
 **Заголовок:** concrt.h  
  
 **Пространство имен:** concurrency  
  
##  <a name="block"></a> Блок 

 Блокирует текущий контекст.  
  
```
static void __cdecl Block();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
 Если контекст вызова работает на виртуальном процессоре, виртуальный процессор найдет другого работоспособный контекст для выполнения или потенциально может создать новую.  
  
 После `Block` метод был вызван или будет вызываться, его необходимо настроить сопряжение с вызовом [Unblock](#unblock) метод из другого контекста выполнения в порядке для его повторный запуск. Имейте в виду, что имеется критический период между точкой, где код публикует его контекст для другого потока, чтобы иметь возможность вызывать `Unblock` метод и точки, где метод фактический вызов `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживать причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` -  `Unblock` пары.  
  
 Этот метод можно вызвать ряд исключений, включая [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md).  
  
##  <a name="dtor"></a> ~ Контекста 

```
virtual ~Context();
```  
  
##  <a name="currentcontext"></a> CurrentContext 

 Возвращает указатель на текущий контекст.  
  
```
static Context* __cdecl CurrentContext();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Указатель на текущий контекст.  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
##  <a name="getid"></a> GetId 

 Возвращает идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.  
  
```
virtual unsigned int GetId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Идентификатор контекста, который уникален в пределах планировщика, к которому принадлежит контекст.  
  
##  <a name="getschedulegroupid"></a> GetScheduleGroupId 

 Возвращает идентификатор для группы расписаний, контекст сейчас работает над.  
  
```
virtual unsigned int GetScheduleGroupId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Идентификатор группы расписаний контекст в настоящее время работает над.  
  
### <a name="remarks"></a>Примечания  
 Из этого метода возвращается выборка группы расписаний, контекст выполняется в данный момент. Если этот метод вызывается в контексте, отличном от текущего контекста, значение может быть устаревшим в момент возврата и полагаться на него нельзя. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="getvirtualprocessorid"></a> GetVirtualProcessorId 

 Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.  
  
```
virtual unsigned int GetVirtualProcessorId() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если контекст в данный момент на виртуальном процессоре, идентификатор виртуального процессора, выполняющийся в данный момент контекст; в в противном случае — значение `-1`.  
  
### <a name="remarks"></a>Примечания  
 Из этого метода возвращается выборка виртуального процессора, контекст выполняется в данный момент. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="id"></a> Идентификатор 

 Возвращает идентификатор для текущего контекста, который уникален в пределах планировщика, к которой принадлежит текущий контекст.  
  
```
static unsigned int __cdecl Id();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Текущий контекст, подключенного к планировщик, идентификатор для текущего контекста, который уникален в пределах планировщика, к которому принадлежит текущий контекст; в противном случае — значение `-1`.  
  
##  <a name="iscurrenttaskcollectioncanceling"></a> IsCurrentTaskCollectionCanceling 

 Возвращает значение, указывающее, следует ли коллекция задач, которая выполняется в данный момент встроено в текущем контексте, в процессе активной отмены (или будет вскоре).  
  
```
static bool __cdecl IsCurrentTaskCollectionCanceling();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если планировщик присоединен к вызывающему контексту и группа задач выполняет задачу встроено в этом контексте, указание, следует ли группа задач, в процессе активной отмены (или будет вскоре); в противном случае — значение `false`.  
  
##  <a name="issynchronouslyblocked"></a> IsSynchronouslyBlocked 

 Определяет, заблокирован ли контекст, синхронно. Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке.  
  
```
virtual bool IsSynchronouslyBlocked() const = 0;
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Является ли контекст синхронно блокируется.  
  
### <a name="remarks"></a>Примечания  
 Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке. В планировщике потоков это означает прямой вызов метода `Context::Block` или объекта синхронизации, который был создан с помощью метода `Context::Block`.  
  
 Возвращаемое значение из этого метода — это образец на данный момент ли контекст синхронно блокируется. Это значение может быть устаревшим в момент возвращается и может использоваться только в особых обстоятельствах.  
  
##  <a name="operator_delete"></a> оператор delete 

 Объект `Context` объект уничтожается внутренним образом средой выполнения. Его невозможно удалить явно.  
  
```
void operator delete(void* _PObject);
```  
  
### <a name="parameters"></a>Параметры  
*_PObject*<br/>
Указатель на объект для удаления.  
  
##  <a name="oversubscribe"></a> Превысить предел подписок 

 Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.  
  
```
static void __cdecl Oversubscribe(bool _BeginOversubscription);
```  
  
### <a name="parameters"></a>Параметры  
*_BeginOversubscription*<br/>
Если `true`, указывает на то что дополнительный виртуальный процессор должны быть добавлены в течение превышения лимита подписки. Если `false`, указывает на то что должен заканчиваться на превышение лимита подписки, и должны быть удалены ранее добавленный виртуальный процессор.  
  
##  <a name="schedulegroupid"></a> ScheduleGroupId 

 Возвращает идентификатор для группы расписаний, занимается текущего контекста.  
  
```
static unsigned int __cdecl ScheduleGroupId();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст присоединен к планировщик и работу над группой расписаний, идентификатор для планировщика группы, текущий контекст работает; в противном случае — значение `-1`.  
  
##  <a name="unblock"></a> Разблокировать 

 Разблокирует контекст и приводит к запуску.  
  
```
virtual void Unblock() = 0;
```  
  
### <a name="remarks"></a>Примечания  
 Вполне допустимо для вызова `Unblock` метода должны быть до соответствующего вызова [блок](#block) метод. Как долго, как вызовы `Block` и `Unblock` методы правильно объединены в пару, среда выполнения правильно обрабатывает машинную гонку любого порядка. `Unblock` Вызовов, поступающих перед `Block` вызов просто отменяют эффект `Block` вызова.  
  
 Существует несколько исключений, которые могут создаваться из этого метода. Если контекст пытается вызвать `Unblock` метод для себя, [context_self_unblock](context-self-unblock-class.md) будет создано исключение. Если вызовы `Block` и `Unblock` объединены неправильно (например, два вызова к `Unblock` выполняются в контексте которой выполняется в данный момент), [context_unblock_unbalanced](context-unblock-unbalanced-class.md) будет создано исключение.  
  
 Имейте в виду, что имеется критический период между точкой, где код публикует его контекст для другого потока, чтобы иметь возможность вызывать `Unblock` метод и точки, где метод фактический вызов `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживать причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` и `Unblock` пары.  
  
##  <a name="virtualprocessorid"></a> VirtualProcessorId 

 Возвращает идентификатор для виртуального процессора, исполняемой в текущем контексте.  
  
```
static unsigned int __cdecl VirtualProcessorId();
```  
  
### <a name="return-value"></a>Возвращаемое значение  
 Если текущий контекст прикрепляется к планировщик, идентификатор виртуального процессора, выполняющего текущий контекст; в противном в противном случае — значение `-1`.  
  
### <a name="remarks"></a>Примечания  
 Из этого метода возвращается выборка виртуального процессора, текущий контекст выполняется в данный момент. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.  
  
##  <a name="yield"></a> оператор yield 

 Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.  
  
```
static void __cdecl Yield();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
##  <a name="yieldexecution"></a> YieldExecution 

 Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.  
  
```
static void __cdecl YieldExecution();
```  
  
### <a name="remarks"></a>Примечания  
 В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.  
  
 Эта функция, впервые появился в Visual Studio 2015 и идентичен объекту [Yield](#yield) работать, но не конфликтует с макросом Yield в Windows.h.  
  
## <a name="see-also"></a>См. также  
 [пространство имен Concurrency](concurrency-namespace.md)   
 [Класс Scheduler](scheduler-class.md)   
 [Планировщик задач](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)



