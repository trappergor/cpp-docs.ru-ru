---
title: Предустановленные макросы
description: Список и описание предопределенных макросов препроцессора компилятора Microsoft C++.
ms.custom: update_every_version
ms.date: 11/20/2019
f1_keywords:
- _ATL_VER
- __ATOM__
- __AVX__
- __AVX2__
- __AVX512BW__
- __AVX512CD__
- __AVX512DQ__
- __AVX512F__
- __AVX512VL__
- _CHAR_UNSIGNED
- __CLR_VER
- _CONTROL_FLOW_GUARD
- __COUNTER__
- __cplusplus
- __cplusplus_cli
- __cplusplus_winrt
- _CPPRTTI
- _CPPUNWIND
- __DATE__
- _DEBUG
- _DLL
- __FILE__
- __FUNCDNAME__
- __FUNCSIG__
- __FUNCTION__
- _INTEGRAL_MAX_BITS
- _ISO_VOLATILE
- _KERNEL_MODE
- __LINE__
- _M_AMD64
- _M_ARM
- _M_ARM_ARMV7VE
- _M_ARM_FP
- _M_ARM64
- _M_CEE
- _M_CEE_PURE
- _M_CEE_SAFE
- _M_FP_EXCEPT
- _M_FP_FAST
- _M_FP_PRECISE
- _M_FP_STRICT
- _M_IX86
- _M_IX86_FP
- _M_X64
- _MANAGED
- _MFC_VER
- _MSC_BUILD
- _MSC_EXTENSIONS
- _MSC_FULL_VER
- _MSC_VER
- _MSVC_LANG
- __MSVC_RUNTIME_CHECKS
- _MT
- _NATIVE_WCHAR_T_DEFINED
- _NO_SIZED_DEALLOCATION
- _OPENMP
- _PREFAST_
- _RESUMABLE_FUNCTIONS_SUPPORTED
- _RTC_CONVERSION_CHECKS_ENABLED
- __STDC__
- __STDC_HOSTED__
- __STDCPP_THREADS__
- __TIME__
- __TIMESTAMP__
- __VA_ARGS__
- _VC_NODEFAULTLIB
- _WCHAR_T_DEFINED
- _WIN32
- _WIN64
- _WINRT_DLL
helpviewer_keywords:
- timestamps, preprocessor macro
- cl.exe compiler, version number
- version numbers, C/C++ compiler (cl.exe)
- macros, predefined C++
- preprocessor, macros
- predefined macros
- _ATL_VER macro
- __ATOM__ macro
- __AVX__ macro
- __AVX2__ macro
- __AVX512BW__ macro
- __AVX512CD__ macro
- __AVX512DQ__ macro
- __AVX512F__ macro
- __AVX512VL__ macro
- _CHAR_UNSIGNED macro
- __CLR_VER macro
- _CONTROL_FLOW_GUARD macro
- __COUNTER__ macro
- __cplusplus macro
- __cplusplus_cli macro
- __cplusplus_winrt macro
- _CPPRTTI macro
- _CPPUNWIND macro
- __DATE__ macro
- _DEBUG macro
- _DLL macro
- __FILE__ macro
- __FUNCDNAME__ macro
- __FUNCSIG__ macro
- __FUNCTION__ macro
- _INTEGRAL_MAX_BITS macro
- _ISO_VOLATILE macro
- _KERNEL_MODE macro
- __LINE__ macro
- _M_AMD64 macro
- _M_ARM macro
- _M_ARM_ARMV7VE macro
- _M_ARM_FP macro
- _M_ARM64 macro
- _M_CEE macro
- _M_CEE_PURE macro
- _M_CEE_SAFE macro
- _M_FP_EXCEPT macro
- _M_FP_FAST macro
- _M_FP_PRECISE macro
- _M_FP_STRICT macro
- _M_IX86 macro
- _M_IX86_FP macro
- _M_X64 macro
- _MANAGED macro
- _MFC_VER macro
- _MSC_BUILD macro
- _MSC_EXTENSIONS macro
- _MSC_FULL_VER macro
- _MSC_VER macro
- _MSVC_LANG macro
- __MSVC_RUNTIME_CHECKS macro
- _MT macro
- _NATIVE_WCHAR_T_DEFINED macro
- _NO_SIZED_DEALLOCATION macro
- _OPENMP macro
- _PREFAST_ macro
- _RESUMABLE_FUNCTIONS_SUPPORTED macro
- _RTC_CONVERSION_CHECKS_ENABLED macro
- __STDC__ macro
- __STDC_HOSTED__ macro
- __STDCPP_THREADS__ macro
- __TIME__ macro
- __TIMESTAMP__ macro
- __VA_ARGS__ macro
- _VC_NODEFAULTLIB macro
- _WCHAR_T_DEFINED macro
- _WIN32 macro
- _WIN64 macro
- _WINRT_DLL macro
- __func__ identifier
ms.assetid: 1cc5f70a-a225-469c-aed0-fe766238e23f
no-loc:
- _ATL_VER
- __ATOM__
- __AVX__
- __AVX2__
- __AVX512BW__
- __AVX512CD__
- __AVX512DQ__
- __AVX512F__
- __AVX512VL__
- _CHAR_UNSIGNED
- __CLR_VER
- _CONTROL_FLOW_GUARD
- __COUNTER__
- __cplusplus
- __cplusplus_cli
- __cplusplus_winrt
- _CPPRTTI
- _CPPUNWIND
- __DATE__
- _DEBUG
- _DLL
- __FILE__
- __FUNCDNAME__
- __FUNCSIG__
- __FUNCTION__
- _INTEGRAL_MAX_BITS
- _ISO_VOLATILE
- _KERNEL_MODE
- __LINE__
- _M_AMD64
- _M_ARM
- _M_ARM_ARMV7VE
- _M_ARM_FP
- _M_ARM64
- _M_CEE
- _M_CEE_PURE
- _M_CEE_SAFE
- _M_FP_EXCEPT
- _M_FP_FAST
- _M_FP_PRECISE
- _M_FP_STRICT
- _M_IX86
- _M_IX86_FP
- _M_X64
- _MANAGED
- _MFC_VER
- _MSC_BUILD
- _MSC_EXTENSIONS
- _MSC_FULL_VER
- _MSC_VER
- _MSVC_LANG
- __MSVC_RUNTIME_CHECKS
- _MT
- _NATIVE_WCHAR_T_DEFINED
- _NO_SIZED_DEALLOCATION
- _OPENMP
- _PREFAST_
- _RESUMABLE_FUNCTIONS_SUPPORTED
- _RTC_CONVERSION_CHECKS_ENABLED
- __STDC__
- __STDC_HOSTED__
- __STDCPP_THREADS__
- __TIME__
- __TIMESTAMP__
- __VA_ARGS__
- _VC_NODEFAULTLIB
- _WCHAR_T_DEFINED
- _WIN32
- _WIN64
- _WINRT_DLL
- __func__
ms.openlocfilehash: 6da1ecd178c0bbeed3b741fb611571203d79cb76
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79444949"
---
# <a name="predefined-macros"></a>Предустановленные макросы

Компилятор Microsoft C/C++ (MSVC) предварительно определяет отдельные макросы препроцессора в зависимости от языка (C или C++ ), целевого объекта компиляции и выбранных параметров компилятора.

MSVC поддерживает предопределенные макросы препроцессора, которые являются обязательными, согласно стандарту ANSI/ISO C99, а также стандартам ISO C++14 и C++17. Эта реализация также поддерживает несколько дополнительных макросов препроцессора, характерных для систем Майкрософт. Некоторые макросы определяются только для конкретных сред сборки или параметров компилятора. Если не указано иное, макросы определяются по всей единице трансляции, как если бы они были указаны в качестве аргументов параметра компилятора **/D**. Когда макросы определены, они развертываются до указанных значений препроцессором перед компиляцией. Предопределенные макросы не принимают аргументы и не могут быть определены повторно.

## <a name="standard-predefined-identifier"></a>Стандартный предопределенный идентификатор

Компилятор поддерживает этот предопределенный идентификатор, описанный стандартами ISO C99 и ISO C++11.

- `__func__` — неполное и недекорируемое имя включающей функции в виде локального для функции массива **static const** с элементами **char**.

    ```cpp
    void example(){
        printf("%s\n", __func__);
    } // prints "example"
    ```

## <a name="standard-predefined-macros"></a>Стандартные предопределенные макросы

Компилятор поддерживает эти предопределенные макросы, описанные стандартами ISO C99 и ISO C++17.

- `__cplusplus` — определяется как целочисленное литеральное значение, если единица трансляции компилируется как C++. В противном случае — не определяется.

- `__DATE__` — дата компиляции текущего файла исходного кода. Дата — строковой литерал постоянной длины в формате *ммм дд гггг*. Название месяца *ммм* совпадает с сокращенным названием месяца, созданным функцией [asctime](../c-runtime-library/reference/asctime-wasctime.md) библиотеки времени выполнения C (CRT). Первый символ даты *дд* — это пробел, если значение меньше 10. Этот макрос определяется всегда. Этот макрос определяется всегда.

- `__FILE__` — имя текущего файла исходного кода. `__FILE__` развертывается в литерал строки символов. Чтобы убедиться, что отображается полный путь к файлу, используйте [/FC (полный путь к файлу исходного кода в диагностике)](../build/reference/fc-full-path-of-source-code-file-in-diagnostics.md). Этот макрос определяется всегда.

- `__LINE__` определяется как целочисленный номер строки в текущем файле исходного кода. Значение макроса `__LINE__` можно изменить с помощью директивы `#line`. Этот макрос определяется всегда.

- `__STDC__` определяется как 1 только при компиляции в виде C и при указании параметра компилятора [/Za](../build/reference/za-ze-disable-language-extensions.md). В противном случае — не определяется.

- `__STDC_HOSTED__` определяется как 1, если реализация является *размещенной реализацией*, полностью поддерживающей необходимую стандартную библиотеку. В противном случае определяется как 0.

- `__STDCPP_THREADS__` определяется как 1, только если программа может иметь только один поток выполнения и cкомпилирована как C++. В противном случае — не определяется.

- `__TIME__` — время, в течение которого выполняется преобразование предварительно обработанной единицы трансляции. Время представляет собой литерал строки символов в форме *чч:мм:сс*, который совпадает со временем, возвращаемым функцией [asctime](../c-runtime-library/reference/asctime-wasctime.md) CRT. Этот макрос определяется всегда.

## <a name="microsoft-specific-predefined-macros"></a>Предопределенные макросы, предназначенные специально для систем Майкрософт

MSVC поддерживает эти дополнительные предопределенные макросы.

- `__ATOM__` определяется как 1, если занят параметр компилятора [/favor:ATOM](../build/reference/favor-optimize-for-architecture-specifics.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX__` определяется как 1, если заданы параметры компилятора [/arch:AVX](../build/reference/arch-x86.md), [/arch:AVX2](../build/reference/arch-x86.md) или [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX2__` определяется как 1, если задан параметр компилятора [/arch:AVX2](../build/reference/arch-x86.md) или [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX512BW__` определяется как 1, если задан параметр компилятора [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX512CD__` определяется как 1, если задан параметр компилятора [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX512DQ__` определяется как 1, если задан параметр компилятора [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX512F__` определяется как 1, если задан параметр компилятора [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `__AVX512VL__` определяется как 1, если задан параметр компилятора [/arch:AVX512](../build/reference/arch-x86.md), а целевой объект компилятора — x86 или x64. В противном случае — не определяется.

- `_CHAR_UNSIGNED` определяется как 1, если тип **char** по умолчанию не имеет знака (unsigned). Это значение определяется в том случае, если задан параметр компилятора [/J (использовать по умолчанию unsigned для типа char)](../build/reference/j-default-char-type-is-unsigned.md). В противном случае — не определяется.

- `__CLR_VER` определяется как целочисленный литерал, представляющий версию среды CLR, используемую для компиляции приложения. Значение кодируется в виде `Mmmbbbbb`, где `M` является основным номером версии среды выполнения, `mm` — это дополнительный номер версии среды выполнения, а `bbbbb` — номер сборки. `__CLR_VER` определяется, если задан параметр компилятора [/clr](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

    ```cpp
    // clr_ver.cpp
    // compile with: /clr
    using namespace System;
    int main() {
       Console::WriteLine(__CLR_VER);
    }
    ```

- `_CONTROL_FLOW_GUARD` определяется как 1, если задан параметр компилятора [/guard:cf (включение защиты потока управления)](../build/reference/guard-enable-control-flow-guard.md). В противном случае — не определяется.

- `__COUNTER__` развертывается до целочисленного литерала, начинающегося с 0. Значение увеличивается на 1 каждый раз, когда используется в файле исходного кода или во включенных заголовках файла исходного кода. `__COUNTER__` запоминает свое состояние при использовании предкомпилированных заголовков. Этот макрос определяется всегда.

  В этом примере `__COUNTER__` используется для назначения уникальных идентификаторов трем различным объектам одного типа. Конструктор `exampleClass` принимает целое число в качестве параметра. В `main` приложение объявляет три объекта типа `exampleClass` с использованием `__COUNTER__` в качестве параметра уникального идентификатора:

    ```cpp
    // macro__COUNTER__.cpp
    // Demonstration of __COUNTER__, assigns unique identifiers to
    // different objects of the same type.
    // Compile by using: cl /EHsc /W4 macro__COUNTER__.cpp
    #include <stdio.h>

    class exampleClass {
        int m_nID;
    public:
        // initialize object with a read-only unique ID
        exampleClass(int nID) : m_nID(nID) {}
        int GetID(void) { return m_nID; }
    };

    int main()
    {
        // __COUNTER__ is initially defined as 0
        exampleClass e1(__COUNTER__);

        // On the second reference, __COUNTER__ is now defined as 1
        exampleClass e2(__COUNTER__);

        // __COUNTER__ is now defined as 2
        exampleClass e3(__COUNTER__);

        printf("e1 ID: %i\n", e1.GetID());
        printf("e2 ID: %i\n", e2.GetID());
        printf("e3 ID: %i\n", e3.GetID());

        // Output
        // ------------------------------
        // e1 ID: 0
        // e2 ID: 1
        // e3 ID: 2

        return 0;
    }
    ```

- `__cplusplus_cli` определяется как целочисленное литеральное значение 200406 при компиляции как C++ и заданном параметре компилятора [/clr](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется. Когда `__cplusplus_cli` задан, он действует во всей единице трансляции.

    ```cpp
    // cplusplus_cli.cpp
    // compile by using /clr
    #include "stdio.h"
    int main() {
       #ifdef __cplusplus_cli
          printf("%d\n", __cplusplus_cli);
       #else
          printf("not defined\n");
       #endif
    }
    ```

- `__cplusplus_winrt` определяется как целочисленное литеральное значение 201009 при компиляции как C++ и заданном параметре компилятора [/ZW (компиляция среды выполнения Windows)](../build/reference/zw-windows-runtime-compilation.md). В противном случае — не определяется.

- `_CPPRTTI` определяется как 1, если задан параметр компилятора [/GR (включить информацию о типах времени выполнения)](../build/reference/gr-enable-run-time-type-information.md). В противном случае — не определяется.

- `_CPPUNWIND` определяется как 1, если задан один или несколько параметров компилятора [/GX (включение обработки исключений)](../build/reference/gx-enable-exception-handling.md), [/clr (компиляция среды CLR)](../build/reference/clr-common-language-runtime-compilation.md) или [/EH (модель обработки исключений)](../build/reference/eh-exception-handling-model.md). В противном случае — не определяется.

- `_DEBUG` определяется как 1, если задан параметр компилятора [/LDd](../build/reference/md-mt-ld-use-run-time-library.md), [/MDd](../build/reference/md-mt-ld-use-run-time-library.md) или [/MTd](../build/reference/md-mt-ld-use-run-time-library.md). В противном случае — не определяется.

- `_DLL` определяется как 1, если задан параметр компилятора [/MD](../build/reference/md-mt-ld-use-run-time-library.md) или [/MDd](../build/reference/md-mt-ld-use-run-time-library.md) (многопоточная библиотека DLL). В противном случае — не определяется.

- `__FUNCDNAME__` определяется как строковый литерал, содержащий [декорированное имя](../build/reference/decorated-names.md) включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCDNAME__` не разворачивается, если используется параметр компилятора [/EP](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [/P](../build/reference/p-preprocess-to-a-file.md).

   В этом примере макросы `__FUNCDNAME__`, `__FUNCSIG__` и `__FUNCTION__` используются для вывода информации о функции.

   [!code-cpp[NVC_Predefined_Macros_Examples#1](../preprocessor/codesnippet/CPP/predefined-macros_1.cpp)]

- `__FUNCSIG__` определяется как строковый литерал, содержащий сигнатуру включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCSIG__` не разворачивается, если используется параметр компилятора [/EP](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [/P](../build/reference/p-preprocess-to-a-file.md). При компиляции для 64-разрядных конечных вызовов — это `__cdecl` по умолчанию. Пример использования см. в разделе для макроса `__FUNCDNAME__`.

- `__FUNCTION__` определяется как строковый литерал, содержащий недекорированное имя включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCTION__` не разворачивается, если используется параметр компилятора [/EP](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [/P](../build/reference/p-preprocess-to-a-file.md). Пример использования см. в разделе для макроса `__FUNCDNAME__`.

- `_INTEGRAL_MAX_BITS` определяется как целочисленное литеральное значение 64, максимальный размер (в битах) для целочисленного типа без вектора. Этот макрос определяется всегда.

   ```cpp
   // integral_max_bits.cpp
   #include <stdio.h>
   int main() {
      printf("%d\n", _INTEGRAL_MAX_BITS);
   }
   ```

- `__INTELLISENSE__` определяется как 1 во время прохода компилятором IntelliSense в интегрированной среде разработки Visual Studio. В противном случае — не определяется. Этот макрос можно использовать для защиты кода, который компилятор IntelliSense не понимает, или для переключения между сборкой и компилятором IntelliSense. Дополнительные сведения см. в разделе [советы по устранению неполадок при медленной работе IntelliSense](https://devblogs.microsoft.com/cppblog/troubleshooting-tips-for-intellisense-slowness/).

- `_ISO_VOLATILE` определяется как 1, если задан параметр компилятора [/volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md). В противном случае — не определяется.

- `_KERNEL_MODE` определяется как 1, если задан параметр компилятора [/kernel (создание двоичного файла режима ядра)](../build/reference/kernel-create-kernel-mode-binary.md). В противном случае — не определяется.

- `_M_AMD64` определяется как целочисленное литеральное значение 100 для компиляций, предназначенных для процессоров x64. В противном случае — не определяется.

- `_M_ARM` определяется как целочисленное литеральное значение 7 для компиляций, предназначенных для процессоров ARM. В противном случае — не определяется.

- `_M_ARM_ARMV7VE` определяется как 1, если параметр компилятора [/arch:ARMv7VE](../build/reference/arch-arm.md) задан для компиляций, предназначенных для процессоров ARM. В противном случае — не определяется.

- `_M_ARM_FP` определяется как целочисленное литеральное значение, указывающее, какой параметр компилятора [/arch](../build/reference/arch-arm.md) был задан для целевых объектов процессора ARM. В противном случае — не определяется.

  - Значение в диапазоне 30–39, если не был указан параметр `/arch` ARM, указывающий, что по умолчанию задана архитектура для ARM (`VFPv3`).

  - Значение в диапазоне 40–49, если был задан `/arch:VFPv4`.

  - Дополнительные сведения см. в разделе [/arch (ARM)](../build/reference/arch-arm.md).

- `_M_ARM64` определяется как 1 для компиляций, предназначенных для 64-разрядных процессоров ARM. В противном случае — не определяется.

- `_M_CEE` определяется как 001, если задан параметр компилятора [/clr (компиляция CLR)](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_CEE_PURE` объявлен нерекомендуемым начиная с Visual Studio 2015. Определяется как 001, если задан параметр компилятора [/CLR: pure](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_CEE_SAFE` объявлен нерекомендуемым начиная с Visual Studio 2015. Определяется как 001, если задан параметр компилятора [/CLR: safe](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_FP_EXCEPT` определяется как 1, если задан параметр компилятора [/fp:except](../build/reference/fp-specify-floating-point-behavior.md) или [/fp:strict](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_FP_FAST` определяется как 1, если задан параметр компилятора [/fp:fast](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_FP_PRECISE` определяется как 1, если задан параметр компилятора [/fp:precise](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_FP_STRICT` определяется как 1, если задан параметр компилятора [/fp:strict](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_IX86` определяется как целочисленное литеральное значение 600 для компиляций, предназначенных для процессоров x86. Этот макрос не определяется для целевых объектов компиляции x64 или ARM.

- `_M_IX86_FP` определяется как целочисленное литеральное значение, указывающее, какой параметр компилятора [/arch](../build/reference/arch-arm.md) был задан, либо значение по умолчанию. Этот макрос всегда определяется, если целевым объектом компиляции является процессор x86. В противном случае — не определяется. Когда определен, значение равно:

  - 0, если задан параметр компилятора `/arch:IA32`.

  - 1, если задан параметр компилятора `/arch:SSE`.

  - 2, если задан параметр компилятора `/arch:SSE2`, `/arch:AVX`, `/arch:AVX2` или `/arch:AVX512`. Это значение используется по умолчанию, если не был указан параметр компилятора `/arch`. Если указан `/arch:AVX`, также определяется макрос `__AVX__`. Если указан `/arch:AVX2`, также определяются `__AVX__` и `__AVX2__`. Если указан `/arch:AVX512`, также определяются `__AVX__`, `__AVX2__`, `__AVX512BW__`, `__AVX512CD__`, `__AVX512DQ__`, `__AVX512F__` и `__AVX512VL__`.

  - Дополнительные сведения см. в разделе [/arch (x86)](../build/reference/arch-x86.md).

- `_M_X64` определяется как целочисленное литеральное значение 100 для компиляций, предназначенных для процессоров x64. В противном случае — не определяется.

- `_MANAGED` определяется как 1, если задан параметр компилятора [/clr](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_MSC_BUILD` определяется как целочисленный литерал, содержащий элемент номера редакции номера версии компилятора. Номер редакции — это четвертый элемент разделенного точками номера версии. Например, для номера версии компилятора Microsoft C/C++ 15.00.20706.01 макрос `_MSC_BUILD` дает значение 1. Этот макрос определяется всегда.

- `_MSC_EXTENSIONS` определяется как 1, если задан включенный по умолчанию параметр компилятора [/Ze (включение языковых расширений)](../build/reference/za-ze-disable-language-extensions.md). В противном случае — не определяется.

- `_MSC_FULL_VER` определяется как целочисленный литерал, кодирующий такие элементы номера версии компилятора, как основной номер версии, дополнительный номер версии и номер сборки. Основной номер — это первый элемент номера версии с разделителями точками, дополнительный номер — второй элемент, а номер сборки — третий. Например, для номера версии компилятора Microsoft C/C++ 15.00.20706.01 макрос `_MSC_FULL_VER` дает значение 150020706. Для просмотра номера версии компилятора введите `cl /?` в командной строке. Этот макрос определяется всегда.

- `_MSC_VER` определяется как целочисленный литерал, кодирующий такие элементы номера версии компилятора, как основной номер версии и дополнительный номер версии. Основной номер — это первый элемент номера версии с разделителями точками, а дополнительный номер — это второй элемент. Например, для номера версии компилятора Microsoft C/C++ 17.00.51106.1 макрос `_MSC_VER` дает значение 1700. Для просмотра номера версии компилятора введите `cl /?` в командной строке. Этот макрос определяется всегда.

   |Версия Visual Studio|`_MSC_VER`|
   |-|-|
   |Visual Studio 6.0|1200|
   |Visual Studio .NET 2002 (7.0)|1300|
   |Visual Studio .NET 2003 (7.1)|1310|
   |Visual Studio 2005 (8.0)|1400|
   |Visual Studio 2008 (9.0)|1500|
   |Visual Studio 2010 (10.0)|1600|
   |Visual Studio 2012 (11.0)|1700|
   |Visual Studio 2013 (12.0)|1800|
   |Visual Studio 2015 (14.0)|1900|
   |Visual Studio 2017 RTW (15.0)|1910|
   |Visual Studio 2017 версия 15.3|1911|
   |Visual Studio 2017 версии 15.5|1912|
   |Visual Studio 2017 версии 15.6|1913|
   |Visual Studio 2017 версии 15.7|1914|
   |Visual Studio 2017 версии 15.8|1915|
   |Visual Studio 2017 версии 15.9|1916|
   |Visual Studio 2019 RTW (16.0)|1920|
   |Visual Studio 2019 версии 16.1|1921|
   |Visual Studio 2019 версии 16.2|1922|
   |Visual Studio 2019 версии 16.3|1923|
   |Visual Studio 2019 версии 16.4|1924|
   |Visual Studio 2019, версия 16.5|1925|
   |Visual Studio 2019 версии 16.6|1926|

   Чтобы проверить наличие выпусков или обновлений компилятора в заданной версии Visual Studio или более поздних, используйте оператор `>=`. Его можно использовать в условной директиве для сравнения `_MSC_VER` с этой известной версией. При сравнении нескольких взаимоисключающих версий упорядочите сравнения в порядке убывания номера версии. Например, этот код проверяет компиляторы, выпущенные в Visual Studio 2017 и более поздних версиях. Затем он проверяет компиляторы, выпущенные в Visual Studio 2015 или более поздних версиях. Затем он проверяет все компиляторы, выпущенные до Visual Studio 2015:

   ```cpp
   #if _MSC_VER >= 1910
   // . . .
   #elif _MSC_VER >= 1900
   // . . .
   #else
   // . . .
   #endif
   ```

   Дополнительные сведения см. в статье [Visual C++ Compiler Version](https://devblogs.microsoft.com/cppblog/visual-c-compiler-version/) (Версия компилятора Visual C++) в блоге команды разработчиков Microsoft C++.

- `_MSVC_LANG` определяется как целочисленный литерал, указывающий стандарт языка C++, на который ориентируется компилятор. Он задается только в коде, компилируемом как C++. Этот макрос представляет собой целочисленное литеральное значение, 201402L по умолчанию или при указании параметра компилятора [/std:c++14](../build/reference/std-specify-language-standard-version.md). Макрос имеет значение 201703L, если указан параметр компилятора [/std:c++17](../build/reference/std-specify-language-standard-version.md). Если задан параметр [/std:c++latest](../build/reference/std-specify-language-standard-version.md), ему присваивается более высокое неопределенное значение. В противном случае макрос не определяется. Макрос `_MSVC_LANG` и параметры компилятора [/std (определение стандартной версии языка)](../build/reference/std-specify-language-standard-version.md) доступны начиная с Visual Studio 2015 с обновлением 3.

- `__MSVC_RUNTIME_CHECKS` определяется как 1, если задан один из параметров компилятора [/RTC](../build/reference/rtc-run-time-error-checks.md). В противном случае — не определяется.

- `_MSVC_TRADITIONAL` определяется как 0, когда задан параметр компилятора [/experimental:preprocessor](../build/reference/experimental-preprocessor.md) для режима совместимости препроцессора. Определяется как 1 по умолчанию или при заданном параметре компилятора [/experimental:preprocessor-](../build/reference/experimental-preprocessor.md), указывая на использование традиционного препроцессора. Макрос `_MSVC_TRADITIONAL` и параметр компилятора [/experimental:preprocessor (включение режима совместимости препроцессора)](../build/reference/experimental-preprocessor.md) доступны начиная с Visual Studio 2017 версии 15.8.

   ```cpp
   #if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL
   // Logic using the traditional preprocessor
   #else
   // Logic using cross-platform compatible preprocessor
   #endif
   ```

- `_MT` определяется как 1, когда задан параметр [/MD или /MDd](../build/reference/md-mt-ld-use-run-time-library.md) (многопоточная библиотека DLL) либо [/MT или /MTd](../build/reference/md-mt-ld-use-run-time-library.md) (многопоточный). В противном случае — не определяется.

- `_NATIVE_WCHAR_T_DEFINED` определяется как 1, если задан параметр компилятора [/Zc:wchar_t](../build/reference/zc-wchar-t-wchar-t-is-native-type.md). В противном случае — не определяется.

- `_OPENMP` определяется как целочисленный литерал 200203, если задан параметр компилятора [/openmp (включение поддержки OpenMP 2.0)](../build/reference/openmp-enable-openmp-2-0-support.md). Это значение представляет дату спецификации OpenMP, реализуемой компилятором MSVC. В противном случае — не определяется.

   ```cpp
   // _OPENMP_dir.cpp
   // compile with: /openmp
   #include <stdio.h>
   int main() {
      printf("%d\n", _OPENMP);
   }
   ```

- `_PREFAST_` определяется как 1, если задан параметр компилятора [/analyze](../build/reference/analyze-code-analysis.md). В противном случае — не определяется.

- `__TIMESTAMP__` определяется как строковый литерал, который содержит дату и время последнего изменения текущего исходного файла в сокращенной форме с постоянной длиной, возвращаемой функцией [asctime](../c-runtime-library/reference/asctime-wasctime.md) CRT, например `Fri 19 Aug 13:32:58 2016`. Этот макрос определяется всегда.

- `_VC_NODEFAULTLIB` определяется как 1, если задан параметр компилятора [/Zl (опущенное имя библиотеки по умолчанию)](../build/reference/zl-omit-default-library-name.md). В противном случае — не определяется.

- `_WCHAR_T_DEFINED` определяется как 1, если задан параметр компилятора [/Zc:wchar_t](../build/reference/zc-wchar-t-wchar-t-is-native-type.md), используемый по умолчанию. Макрос `_WCHAR_T_DEFINED` определен, но не имеет значения, если задан параметр компилятора `/Zc:wchar_t-`, а в системном файле заголовка, включенного в ваш проект, определен **wchar_t**. В противном случае — не определяется.

- `_WIN32` определяется как 1, если целевой объект компиляции — 32-разрядная архитектура ARM, 64-разрядная архитектура ARM, x86 или x64. В противном случае — не определяется.

- `_WIN64` определяется как 1, если целевой объект компиляции — 64-разрядная архитектура ARM или x64. В противном случае — не определяется.

- `_WINRT_DLL` определяется как 1 при компиляции в качестве C++ и при заданных параметрах компилятора [/ZW (компиляция среды выполнения Windows)](../build/reference/zw-windows-runtime-compilation.md) и [/LD или /LDd](../build/reference/md-mt-ld-use-run-time-library.md). В противном случае — не определяется.

Нет предопределенных компилятором макросов препроцессора, которые определяют версию библиотеки ATL или MFC. Заголовки библиотек ATL и MFC определяют эти макросы версий внутренним образом. Они не определены в директивах препроцессора, выполняемых до включения необходимого заголовка.

- `_ATL_VER` определяется в \<atldef.h> как целочисленный литерал, кодирующий номер версии ATL.

- `_MFC_VER` определяется в \<afxver_.h> как целочисленный литерал, кодирующий номер версии MFC.

## <a name="see-also"></a>См. также

[Макросы (C/C++)](../preprocessor/macros-c-cpp.md)<br/>
[Операторы препроцессора](../preprocessor/preprocessor-operators.md)<br/>
[Директивы препроцессора](../preprocessor/preprocessor-directives.md)
