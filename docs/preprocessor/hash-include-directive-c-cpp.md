---
title: '#Директива #include (C/C++) | Документация Майкрософт'
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-tools
ms.topic: reference
f1_keywords:
- '#include'
dev_langs:
- C++
helpviewer_keywords:
- preprocessor, directives
- '#include directive'
- include directive (#include)
ms.assetid: 17067dc0-8db1-4f2d-b43e-ec12ecf83238
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: fdf60755591dd37a541c02330554fa4fe9b92ca6
ms.sourcegitcommit: a9dcbcc85b4c28eed280d8e451c494a00d8c4c25
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50062487"
---
# <a name="include-directive-cc"></a>Директива #include (C/C++)
Указывает препроцессору, что содержимое заданного файла необходимо обработать так, как если бы оно находилось в исходной программе в той точке, в которой располагается эта директива.

## <a name="syntax"></a>Синтаксис

```
#include  "path-spec"
#include  <path-spec>
```

## <a name="remarks"></a>Примечания

Можно упорядочить постоянный и определения макроса в содержат файлы, а затем использовать **#include** директивы, чтобы добавить их к любому файлу источника. Включаемые файлы также позволяют внедрять объявления внешних переменных и сложных типов данных. Типы можно определять и именовать только один раз во включаемом файле, созданном с этой целью.

Параметр `path-spec` означает имя файла, перед которым может находиться спецификация каталога (необязательно). Имя файла должно указывать на существующий файл. Синтаксис параметра `path-spec` зависит от того, в какой операционной системе компилируется программа.

Сведения о том, как ссылаться на сборки в приложении C++, который компилируется с помощью [/CLR](../build/reference/clr-common-language-runtime-compilation.md), см. в разделе [#using](../preprocessor/hash-using-directive-cpp.md).

Какая бы из двух форм синтаксиса ни использовалась, вместо директивы подставляется все содержимое указанного включаемого файла. Различие между ними заключается в том, в каком порядке препроцессор ищет файлы заголовков, если путь указан не полностью. В приведенной ниже таблице показывается различие между этими формами синтаксиса.

|Форма синтаксиса|Действие|
|-----------------|------------|
|Форма в кавычках|Препроцессор ищет включаемые файлы в следующем порядке:<br /><br /> (1) в том же каталоге, что и файл, содержащий **#include** инструкции.<br /><br /> (2) в каталогах открытых в данный момент включаемых файлов, в обратном порядке, в котором они были открыты. Поиск начинается в каталоге родительского включаемого файла, а затем выполняется в каталогах всех включаемых файлов-прародителей.<br /><br /> (3) вдоль пути, задаваемый каждого `/I` параметр компилятора.<br /><br /> 4)<br /><br /> По путям, заданным в переменной среды INCLUDE.|
|Форма с угловыми скобками|Препроцессор ищет включаемые файлы в следующем порядке:<br /><br /> (1) вдоль пути, задаваемый каждого `/I` параметр компилятора.<br /><br /> (2) Если компиляция выполняется из командной строки, по путям, заданные в переменной среды INCLUDE.|

Как только препроцессор найдет файл с заданным именем, поиск останавливается. Если путь к включаемому файлу задан полностью и однозначно и окружен двойными кавычками (" "), то препроцессор ищет файл только по заданному пути, а стандартные каталоги пропускает.

Если имя файла в двойных кавычках представляет собой неполную спецификацию пути, то препроцессор сначала просматривает каталог "родительского" файла. Родительский файл — это файл, содержащий **#include** директива. Например, если файл `file2` включен в файл `file1`, то родительским файлом будет считаться `file1`.

Включаемые файлы, которые могут быть «вложенными»; то есть **#include** директива может отображаться в файле, который указан другой **#include** директива. Например, файл `file2` может включать `file3`. В этом случае файл `file1` останется родительским файлом для `file2`, однако для `file3` он будет уже "прародителем".

Если используются вложенные файлы и компиляция выполняется из командной строки, то поиск начинается с каталогов родительских файлов, а затем выполняется в каталогах всех файлов-прародителей. Таким образом, поиск начинается относительно каталога, в котором находится исходный файл, обрабатываемый в текущий момент. Если файл не найден, поиск перемещается в каталоги, которые определяются `/I` параметр компилятора. Наконец, производится поиск в каталогах, указанных в переменной среды INCLUDE.

Если компиляция выполняется в среде разработки, то переменная среды INCLUDE игнорируется. Сведения о том, как установить нужные каталоги, в которых производится поиск включаемых файлов — это также относится к переменной среды LIB, см. в разделе [страница свойств каталогов VC ++](../ide/vcpp-directories-property-page.md).

В приведенном ниже примере демонстрируется включение файлов с помощью угловых скобок:

```
#include <stdio.h>
```

В этом примере в исходную программу добавляется содержимое файла с именем STDIO.H. Угловые скобки вызывают препроцессор осуществлять поиск в каталогах, указанных в переменной среды INCLUDE для STDIO. H, каталогах, которые определяются `/I` параметр компилятора.

В следующем примере демонстрируется включение файлов, заданных в кавычках:

```
#include "defs.h"
```

В этом примере в исходную программу добавляется содержимое файла с именем DEFS.H. Кавычки означают, что препроцессор сначала попытается найти этот файл в каталоге, содержащем родительский исходный файл.

Для включаемых файлов поддерживается до 10 уровней вложения. Когда вложенный **#include** — обработано, препроцессор продолжает вставлять файл включения в исходный файл.

**Блок, относящийся только к системам Microsoft**

Чтобы найти включаемые исходные файлы, препроцессор сначала попытается найти каталоги, которые определяются `/I` параметр компилятора. Если `/I` параметр не указан или завершается ошибкой, то препроцессор в переменной среды INCLUDE для ищет все включаемые файлы, заданные в угловых скобках. В переменной среды INCLUDE и `/I` параметр компилятора могут содержать несколько путей, разделенных точкой с запятой (;). Если задано несколько каталогов отображается как часть `/I` параметр или в переменной среды INCLUDE, то препроцессор просматривает их в порядке, в котором они появляются.

Представим себе следующую команду:

```
CL /ID:\MSVC\INCLUDE MYPROG.C
```

Она дает препроцессору указание просмотреть папку D:\MSVC\INCLUDE\ и найти в ней включаемые файлы (например, STDIO.H). Ниже еще один пример:

```
SET INCLUDE=D:\MSVC\INCLUDE
CL MYPROG.C
```

Эта инструкция действуют точно так же. Если найти файл в обоих наборах каталогов не удастся, возникает неустранимая ошибка компилятора.

Если имя включаемого файла определено полностью, включая путь с двоеточием (например, F:\MSVC\SPECIAL\INCL\TEST.H), то препроцессор проходит по этому пути.

Для включаемых файлов, указанных в качестве `#include` "`path-spec`«, поиск начинается с каталога родительского файла, а затем переходит в каталоги всех прародительских файлов. Таким образом, поиск начинается относительно каталога, содержащего исходный файл, содержащий **#include** директивы, которые обрабатываются. Если у файла нет прародителей, а включаемый файл найти не удалось, то поиск продолжается так, как если бы его имя было заключено в угловые скобки.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)