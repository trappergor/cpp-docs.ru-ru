---
title: '#Директива import (C++)'
ms.date: 08/29/2019
f1_keywords:
- '#import'
helpviewer_keywords:
- .tlh files
- '#import directive'
- import directive (#import)
- tlh files
- tlbid switch
- preprocessor, directives
- COM, type library header file
ms.assetid: 787d1112-e543-40d7-ab15-a63d43f4030a
ms.openlocfilehash: 9cdfef091b659151f427c381e386f0e83396e741
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81332056"
---
# <a name="import-directive-c"></a>директива #import (СЗ)

**Блок, относящийся только к языку C++**

Используется для включения сведений из библиотеки типов. Содержимое библиотеки типов преобразовано в классы C++, в основном описывающие интерфейсы модели COM.

## <a name="syntax"></a>Синтаксис

> **#import** "*файловое имя*" \[ *атрибуты*
> **#import** \<атрибуты *файла*> \[*(фото)*

### <a name="parameters"></a>Параметры

*Имени файла*\
Задает тип библиотеки для импорта. *Имя файла* может быть одним из следующих видов:

- Имя файла, содержащего библиотеку типов, например OLB-, TLB- или DLL-файла. Ключевое слово, `file:`может предшествовать каждому имени файла.

- ИД программы элемента управления в библиотеке типов. Ключевое слово, `progid:`может предшествовать каждому progid. Пример:

    ```cpp
    #import "progid:my.prog.id.1.5"
    ```

   Для получения дополнительной информации о progids [см.](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber)

   При использовании 32-битного кросскомпиляра на 64-битной операционной системе компилятор может читать только 32-битный реестр. Может потребоваться использовать собственный 64-разрядный компилятор для создания и регистрации 64-разрядной библиотеки типов.

- Идентификатор библиотеки типов. Ключевое слово, `libid:`может предшествовать каждому идентификатору библиотеки. Пример:

    ```cpp
    #import "libid:12341234-1234-1234-1234-123412341234" version("4.0") lcid("9")
    ```

   Если вы не `version` указываете или, `lcid` `progid:` [правила,](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber) применяемые к также применяются к `libid:`.

- Исполняемый файл (.exe).

- Файл библиотеки (.dll), содержащий ресурс библиотеки типа (например, .ocx).

- Составной документ, содержащую библиотеку типов.

- Любой другой формат файла, который может быть понят на API **LoadTypeLib.**

*Атрибуты*\
Один или несколько [#import атрибутов.](#_predir_the_23import_directive_import_attributes) Используйте в качестве разделителя атрибутов пробел или запятую. Пример:

```cpp
#import "..\drawctl\drawctl.tlb" no_namespace, raw_interfaces_only
```

\-или-

```cpp
#import "..\drawctl\drawctl.tlb" no_namespace raw_interfaces_only
```

## <a name="remarks"></a>Remarks

### <a name="search-order-for-filename"></a><a name="_predir_the_23import_directive_searchorderforfilename"></a>Заказ на поиск имени файла

*имя файла,* по желанию, предшествует спецификации каталога. Имя файла должно указывать на существующий файл. Различие между двумя синтаксисами — это порядок, в котором препроцессор ищет файлы библиотеки типов, когда путь определен не полностью.

|Форма синтаксиса|Действие|
|-----------------|------------|
|Форма в кавычках|Поручает препроцессору искать файлы библиотеки типов сначала в каталоге файла, содержащего **#import** оператора, а затем в каталогах любых файлов, включаемых ()`#include`этого файла. Затем препроцессор выполняет поиск по путям, показанным ниже.|
|Форма с угловыми скобками|Указывает препроцессору искать файлы библиотеки типов по следующим путям.<br /><br /> 1. `PATH` Список переменных путей среды<br />2. `LIB` Список переменных путей среды<br />3. Путь, указанный опцией компилятора [/I,](../build/reference/i-additional-include-directories.md) кроме него, компилятор ищет библиотеку типов, на которую ссылались из другой библиотеки типа с [no_registry](../preprocessor/no-registry.md) атрибутом.|

### <a name="specify-the-localization-id-and-version-number"></a><a name="_predir_the_23import_directive_specifyingthelocalizationidandversionnumber"></a>Указать идентификатор локализации и номер версии

При определении идентификатора программы можно также указать идентификатор программы локализации и номер версии. Пример:

```cpp
#import "progid:my.prog.id" lcid("0") version("4.0)
```

Если вы не укажете идентификатор локализации, progid выбирается в соответствии со следующими правилами:

- Если есть только один идентификатор локализации, он используется.

- Если идентификатор локализации превышает один, используется первый с номером версии 0, 9 или 409.

- Если идентификатор локализации превышает один идентификатор и ни один из них не 0, 9 или 409, используется последний.

- Если вы не указали номер версии, используется последняя версия.

### <a name="header-files-created-by-import"></a><a name="_predir_the_23import_directive_header_files_created_by_import"></a>Файлы заголовка, созданные импортом

**#import** создает два файла заголовка, которые реконструируют содержимое библиотеки типа в исходном коде СЗ. Файл основной заголовок аналогичен файлу, производимому компилятором Microsoft Interface Definition Language (MIDL), но с дополнительным кодом и данными, генерируемыми компилером. [Файл основного заголовка](#_predir_the_primary_type_library_header_file) имеет то же базовое имя, что и библиотека типа, плюс. Расширение TLH. Вторичный файл заголовка имеет такое же базовое имя, что и библиотека типов, с расширением .TLI. Он содержит реализации созданных компилятором функций-членов и включен (`#include`) в соответствующий файл заголовка.

При импорте свойства dispinterface, использующем `byref` параметры, **#import** не генерирует __declspec [(свойств)](../cpp/property-cpp.md) выписку для функции.

Оба файла заголовка размещаются в каталоге вывода, указанном опцией [/Fo (файл объекта имени).](../build/reference/fo-object-file-name.md) Затем они считываются и компилируются компилятором, как если бы основной файл заголовка был назван директивой. `#include`

Следующие оптимизации компилятора поставляются с директивой **#import:**

- Файл заголовка, когда создан, получает ту же отметку времени, что и библиотека типов.

- При **обработке #import** компилятор сначала проверяет наличие заголовка и актуален. Если да, то он не должен быть воссоздан.

Директива **#import** также участвует в минимальной перестройке и может быть помещена в предварительно собранный файл заголовка.  Для получения дополнительной информации [см.](../build/creating-precompiled-header-files.md)

### <a name="primary-type-library-header-file"></a><a name="_predir_the_primary_type_library_header_file"></a>Файл заголовка библиотеки основного типа

Основной файл заголовка библиотеки типов состоит из 7 разделов:

- Наименование заголовка: состоит из комментариев, оператора `#include` для COMDEF.H (определяющего некоторые стандартные макросы, используемые в заголовке), и других разнообразных сведений о настройке.

- Прямые ссылки и объекты typedef. Состоит из двух структур, таких как `struct IMyInterface` и typedef.

- Смарт-указатель декларации: `_com_ptr_t` шаблон класса умный указатель. Он инкапсулирует интерфейс указатели, и устраняет `Release`необходимость `QueryInterface` вызова, `AddRef`и функции. Он также скрывает `CoCreateInstance` вызов при создании нового объекта COM. В этом разделе `_COM_SMARTPTR_TYPEDEF` используется макро-заявление для определения типовых интерфейсов COM в качестве шаблонных специализаций класса [_com_ptr_t](../cpp/com-ptr-t-class.md) шаблонов. Например, для `IMyInterface`интерфейса , . Файл TLH будет содержать:

    ```TLH
    _COM_SMARTPTR_TYPEDEF(IMyInterface, __uuidof(IMyInterface));
    ```

   который будет развернут компилятором следующим образом.

    ```cpp
    typedef _com_ptr_t<_com_IIID<IMyInterface, __uuidof(IMyInterface)> > IMyInterfacePtr;
    ```

   Тип `IMyInterfacePtr` можно затем использовать вместо начального указателя интерфейса `IMyInterface*`. Следовательно, нет необходимости вызывать различные `IUnknown` функции участника

- Заявления Typeinfo: В первую очередь состоит из определений классов `ITypeLib:GetTypeInfo`и других элементов, обнажающих отдельные элементы typeinfo, возвращенные . В этом разделе каждый объект typeinfo из библиотеки типов отражается в заголовке в форме, которая определяется информацией `TYPEKIND`.

- Необязательное прежнее определение GUID: содержит инициализации именованных констант GUID. Эти имена имеют `CLSID_CoClass` `IID_Interface`форму и, по аналогии с теми, которые генерируются компилятором MIDL.

- Оператор `#include` для заголовка второстепенной библиотеки типов.

- Стандартный нижний колонтитул: в настоящее время содержит `#pragma pack(pop)`.

Все разделы, за исключением заголовка шаблона и колонтитула шаблонной секции, заключены в пространство имен с его именем, указанным `library` в заявлении в исходном файле IDL. Имена из заголовка библиотеки типа можно использовать по явной квалификации, используя имя пространства имен. Или вы можете включить следующее утверждение:

```cpp
using namespace MyLib;
```

сразу же после **#import** в исходном коде.

Пространство имен может быть подавлено с помощью [атрибута no_namespace)](no-namespace.md) **директивы #import.** Однако подавление пространства имен может привести к конфликтам имен. Пространство имен также может быть переименовано [атрибутом rename_namespace.](rename-namespace.md)

Компилятор обеспечивает полный путь к любой зависимости библиотеки типа, требуемой библиотекой типа, которую она в настоящее время обрабатывает. Путь записывается в форме комментариев в заголовке библиотеки типов (.TLH), который компилятор создает для каждой обрабатываемой библиотеки типов.

Если библиотека типов содержит ссылки на типы, определенные в других библиотеках типов, TLH-файл включает комментарии следующей сортировки:

```TLH
//
// Cross-referenced type libraries:
//
//  #import "c:\path\typelib0.tlb"
//
```

Фактическое имя файла в **#import** комментарий — это полный путь библиотеки кросс-ссылки типа, хранящийся в реестре. Если вы столкнулись с ошибками, вызванными отсутствием определений типа, проверьте комментарии во главе . TLH, чтобы увидеть, какие библиотеки зависимого типа могут быть импортированы в первую очередь. Самыми вероятными ошибками являются синтаксические (например, C2143, C2146, C2321), C2501 (отсутствуют спецификаторы decl) и C2433 ("inline" не разрешается использовать в объявлении данных) при компиляции TLI-файла.

Чтобы разрешить ошибки зависимости, определите, какие из комментариев зависимости не предусмотрены системными заголовками, а затем предоставьте **директиву #import** в какой-то момент до **#import** директивы библиотеки зависимого типа.

### <a name="import-attributes"></a><a name="_predir_the_23import_directive_import_attributes"></a>атрибуты #import

**#import** может по желанию включить один или несколько атрибутов. Эти атрибуты указывают, что компилятор изменяет содержимое заголовка библиотеки типов. Символ backslash**\\**() может быть использован для включения дополнительных строк в одну **#import** оператора. Пример:

```cpp
#import "test.lib" no_namespace \
   rename("OldName", "NewName")
```

Для получения дополнительной информации см [#import.](../preprocessor/hash-import-attributes-cpp.md)

**Завершение блока, относящегося только к языку C++**

## <a name="see-also"></a>См. также раздел

[Предпроцессорные директивы](../preprocessor/preprocessor-directives.md)\
[Поддержка компилятора COM](../cpp/compiler-com-support.md)
